/*! For license information please see main.js.LICENSE.txt */
(()=>{var __webpack_modules__={"./constants/init-data.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initData: () => (/* binding */ initData)\n/* harmony export */ });\nvar initData = [[1317888000000, 372.5101, 375, 372.2, 372.52], [1317888060000, 372.4, 373, 372.01, 372.16], [1317888120000, 372.16, 372.4, 371.39, 371.62], [1317888180000, 371.62, 372.16, 371.55, 371.75], [1317888240000, 371.75, 372.4, 371.57, 372], [1317888300000, 372, 372.3, 371.8, 372.24], [1317888360000, 372.22, 372.45, 372.22, 372.3], [1317888420000, 372.3, 373.25, 372.3, 373.15], [1317888480000, 373.01, 373.5, 373, 373.24], [1317888540000, 373.36, 373.88, 373.19, 373.88], [1317888600000, 373.8, 374.34, 373.75, 374.29], [1317888660000, 374.29, 374.43, 374, 374.01], [1317888720000, 374.05, 374.35, 373.76, 374.35], [1317888780000, 374.41, 375.24, 374.37, 374.9], [1317888840000, 374.83, 375.73, 374.81, 374.96], [1317888900000, 374.81, 375.4, 374.81, 375.25], [1317888960000, 375.2, 375.7, 375.14, 375.19], [1317889020000, 375.43, 375.43, 374.75, 374.76], [1317889080000, 374.94, 375.5, 374.81, 375.13], [1317889140000, 375.12, 375.48, 375, 375.04], [1317889200000, 375.24, 375.24, 375, 375.08], [1317889260000, 375.16, 375.16, 374.51, 374.51], [1317889320000, 374.51, 374.75, 374.2, 374.27], [1317889380000, 374.22, 374.55, 373.83, 374.55], [1317889440000, 374.69, 374.86, 374.01, 374.2], [1317889500000, 374.32, 374.65, 374.31, 374.51], [1317889560000, 374.65, 375.12, 374.51, 375.12], [1317889620000, 375.13, 375.25, 374.83, 375.22], [1317889680000, 375.16, 375.22, 375, 375], [1317889740000, 375, 375, 374.66, 374.8], [1317889800000, 374.88, 375, 374.5, 374.85], [1317889860000, 374.41, 374.67, 374.25, 374.67], [1317889920000, 374.5, 374.75, 374.27, 374.42], [1317889980000, 374.4, 374.93, 374.38, 374.85], [1317890040000, 374.86, 375.3, 374.8, 375.09], [1317890100000, 375, 375.18, 374.9, 375.02], [1317890160000, 375.02, 375.08, 374.86, 374.87], [1317890220000, 374.93, 375.75, 374.93, 375.75], [1317890280000, 375.75, 376.5, 375.75, 376.31], [1317890340000, 376.31, 377.2, 376.19, 377.04], [1317890400000, 377.2, 377.33, 376.45, 376.47], [1317890460000, 376.75, 376.99, 376.53, 376.54], [1317890520000, 376.54, 376.67, 376.08, 376.35], [1317890580000, 376.41, 376.94, 376.2, 376.5], [1317890640000, 376.46, 376.51, 376.06, 376.09], [1317890700000, 376.38, 376.84, 376.09, 376.78], [1317890760000, 376.55, 376.6, 376.41, 376.44], [1317890820000, 376.45, 376.87, 376.31, 376.87], [1317890880000, 376.83, 377, 376.63, 376.95], [1317890940000, 376.95, 377, 376.1, 376.1], [1317891000000, 376.1, 376.17, 375.64, 375.65], [1317891060000, 375.68, 376.05, 375.32, 376.05], [1317891120000, 376.03, 376.04, 375.5, 375.72], [1317891180000, 375.83, 376.195, 375.7, 376], [1317891240000, 376.01, 376.6, 376, 376.5], [1317891300000, 376.5, 376.53, 376.11, 376.21], [1317891360000, 376.17, 376.3, 376.1, 376.25], [1317891420000, 376.4, 376.4, 376.13, 376.29], [1317891480000, 376.15, 376.39, 376.1, 376.39], [1317891540000, 376.4, 377.11, 376.4, 377], [1317891600000, 377.01, 377.15, 376.79, 377.15], [1317891660000, 377.02, 377.15, 376.55, 376.88], [1317891720000, 376.67, 376.76, 376.52, 376.53], [1317891780000, 376.78, 376.91, 376.53, 376.82], [1317891840000, 376.73, 376.86, 376.7, 376.75], [1317891900000, 376.7, 376.71, 376.5, 376.57], [1317891960000, 376.53, 376.74, 376.2, 376.2], [1317892020000, 376.17, 376.17, 375.91, 376], [1317892080000, 376, 376, 375.77, 375.77], [1317892140000, 375.78, 375.88, 375.51, 375.57], [1317892200000, 375.57, 375.79, 375.34, 375.63], [1317892260000, 375.63, 375.78, 375.35, 375.41], [1317892320000, 375.38, 375.61, 375.35, 375.58], [1317892380000, 375.55, 375.57, 375.34, 375.48], [1317892440000, 375.43, 375.57, 375.12, 375.13], [1317892500000, 375.15, 375.3, 374.86, 375], [1317892560000, 374.9, 375.31, 374.72, 375.14], [1317892620000, 375, 375.2, 374.9, 375.06], [1317892680000, 375.18, 375.6, 375.12, 375.6], [1317892740000, 375.6, 375.87, 375.5, 375.5], [1317892800000, 375.49, 375.49, 375.04, 375.25], [1317892860000, 375.25, 375.46, 375, 375.24], [1317892920000, 375.38, 375.45, 375, 375.1], [1317892980000, 375.09, 375.24, 374.83, 374.97], [1317893040000, 375.01, 375.01, 374.8, 374.87], [1317893100000, 374.98, 375.12, 374.98, 375], [1317893160000, 374.9, 374.95, 374.75, 374.87], [1317893220000, 374.89, 375.44, 374.87, 375.12], [1317893280000, 375.06, 375.12, 373.56, 374.05], [1317893340000, 374.1, 374.3, 373.16, 373.21], [1317893400000, 373.39, 375, 372.58, 374.8], [1317893460000, 374.899, 375.23, 374.33, 374.75], [1317893520000, 374.79, 376.71, 374.69, 376.31], [1317893580000, 376.32, 376.37, 375.27, 375.331], [1317893640000, 375.3301, 377.44, 375.33, 377.43], [1317893700000, 377.43, 378.14, 376.83, 377.08], [1317893760000, 377.18, 378, 376.5, 376.7], [1317893820000, 376.83, 377, 375.51, 375.79], [1317893880000, 375.6501, 376.74, 375.23, 376.39], [1317893940000, 376.38, 378.75, 376.25, 378.5], [1317894000000, 378.54, 378.63, 376.75, 376.87], [1317894060000, 376.8664, 377.62, 376.64, 376.908], [1317894120000, 376.8336, 377.88, 376.8289, 377.55], [1317894180000, 377.36, 377.9, 376.52, 376.75], [1317894240000, 376.83, 377.73, 376.71, 376.98], [1317894300000, 377, 377.69, 376.87, 377.1212], [1317894360000, 377.225, 377.33, 376.01, 376.26], [1317894420000, 376.42, 376.64, 375.55, 375.5534], [1317894480000, 375.74, 375.94, 374.77, 375.3], [1317894540000, 375.3313, 376, 374.92, 375.06], [1317894600000, 375.11, 375.46, 374.82, 374.92], [1317894660000, 374.82, 375.68, 374.64, 375.668], [1317894720000, 375.62, 376.13, 375.46, 376.13], [1317894780000, 376.14, 376.6, 375.89, 376.34], [1317894840000, 376.39, 376.39, 375.55, 375.99], [1317894900000, 376, 376.28, 375.42, 376.21], [1317894960000, 376, 377.38, 375.7, 376.591], [1317895020000, 376.59, 377.46, 376.57, 376.9348], [1317895080000, 376.9481, 377.749, 376.84, 377.563], [1317895140000, 377.452, 377.65, 376.43, 376.78], [1317895200000, 376.94, 377.01, 375.75, 375.98], [1317895260000, 376.27, 377.29, 375.95, 376.98], [1317895320000, 376.9962, 377.3, 376.69, 376.71], [1317895380000, 376.75, 377.5, 376.75, 377.41], [1317895440000, 377.26, 377.49, 376.89, 377.368], [1317895500000, 377.345, 378, 377.17, 378], [1317895560000, 377.97, 378.3199, 377.68, 377.97], [1317895620000, 378.01, 378.07, 377.25, 377.37], [1317895680000, 377.37, 377.75, 377.05, 377.12], [1317895740000, 377.16, 377.79, 377.01, 377.4512]];\n\n//# sourceURL=webpack://my-webpack-project/./constants/init-data.js?")},"./node_modules/highcharts/highstock.js":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Highstock JS v11.3.0 (2024-01-10)\n *\n * (c) 2009-2024 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */!function (t, e) {\n   true && module.exports ? (e.default = e, module.exports = t && t.document ? e(t) : e) :  true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    return e(t);\n  }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n}("undefined" != typeof window ? window : this, function (t) {\n  "use strict";\n\n  var e = {};\n  function i(e, i, s, o) {\n    e.hasOwnProperty(i) || (e[i] = o.apply(null, s), "function" == typeof CustomEvent && t.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", {\n      detail: {\n        path: i,\n        module: e[i]\n      }\n    })));\n  }\n  return i(e, "Core/Globals.js", [], function () {\n    var e, i;\n    return (i = e || (e = {})).SVG_NS = "http://www.w3.org/2000/svg", i.product = "Highcharts", i.version = "11.3.0", i.win = void 0 !== t ? t : {}, i.doc = i.win.document, i.svg = i.doc && i.doc.createElementNS && !!i.doc.createElementNS(i.SVG_NS, "svg").createSVGRect, i.userAgent = i.win.navigator && i.win.navigator.userAgent || "", i.isChrome = -1 !== i.userAgent.indexOf("Chrome"), i.isFirefox = -1 !== i.userAgent.indexOf("Firefox"), i.isMS = /(edge|msie|trident)/i.test(i.userAgent) && !i.win.opera, i.isSafari = !i.isChrome && -1 !== i.userAgent.indexOf("Safari"), i.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(i.userAgent), i.isWebKit = -1 !== i.userAgent.indexOf("AppleWebKit"), i.deg2rad = 2 * Math.PI / 360, i.hasBidiBug = i.isFirefox && 4 > parseInt(i.userAgent.split("Firefox/")[1], 10), i.hasTouch = !!i.win.TouchEvent, i.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"], i.noop = function () {}, i.supportsPassiveEvents = function () {\n      let t = !1;\n      if (!i.isMS) {\n        let e = Object.defineProperty({}, "passive", {\n          get: function () {\n            t = !0;\n          }\n        });\n        i.win.addEventListener && i.win.removeEventListener && (i.win.addEventListener("testPassive", i.noop, e), i.win.removeEventListener("testPassive", i.noop, e));\n      }\n      return t;\n    }(), i.charts = [], i.composed = [], i.dateFormats = {}, i.seriesTypes = {}, i.symbolSizes = {}, i.chartCount = 0, e;\n  }), i(e, "Core/Utilities.js", [e["Core/Globals.js"]], function (t) {\n    let e;\n    let {\n      charts: i,\n      doc: s,\n      win: o\n    } = t;\n    function r(e, i, s, a) {\n      let n = i ? "Highcharts error" : "Highcharts warning";\n      32 === e && (e = `${n}: Deprecated member`);\n      let l = p(e),\n        h = l ? `${n} #${e}: www.highcharts.com/errors/${e}/` : e.toString();\n      if (void 0 !== a) {\n        let t = "";\n        l && (h += "?"), S(a, function (e, i) {\n          t += `\n - ${i}: ${e}`, l && (h += encodeURI(i) + "=" + encodeURI(e));\n        }), h += t;\n      }\n      C(t, "displayError", {\n        chart: s,\n        code: e,\n        message: h,\n        params: a\n      }, function () {\n        if (i) throw Error(h);\n        o.console && -1 === r.messages.indexOf(h) && console.warn(h);\n      }), r.messages.push(h);\n    }\n    function a(t, e) {\n      return parseInt(t, e || 10);\n    }\n    function n(t) {\n      return "string" == typeof t;\n    }\n    function l(t) {\n      let e = Object.prototype.toString.call(t);\n      return "[object Array]" === e || "[object Array Iterator]" === e;\n    }\n    function h(t, e) {\n      return !!t && "object" == typeof t && (!e || !l(t));\n    }\n    function d(t) {\n      return h(t) && "number" == typeof t.nodeType;\n    }\n    function c(t) {\n      let e = t && t.constructor;\n      return !!(h(t, !0) && !d(t) && e && e.name && "Object" !== e.name);\n    }\n    function p(t) {\n      return "number" == typeof t && !isNaN(t) && t < 1 / 0 && t > -1 / 0;\n    }\n    function u(t) {\n      return null != t;\n    }\n    function g(t, e, i) {\n      let s;\n      let o = n(e) && !u(i),\n        r = (e, i) => {\n          u(e) ? t.setAttribute(i, e) : o ? (s = t.getAttribute(i)) || "class" !== i || (s = t.getAttribute(i + "Name")) : t.removeAttribute(i);\n        };\n      return n(e) ? r(i, e) : S(e, r), s;\n    }\n    function f(t) {\n      return l(t) ? t : [t];\n    }\n    function m(t, e) {\n      let i;\n      for (i in t || (t = {}), e) t[i] = e[i];\n      return t;\n    }\n    function x() {\n      let t = arguments,\n        e = t.length;\n      for (let i = 0; i < e; i++) {\n        let e = t[i];\n        if (null != e) return e;\n      }\n    }\n    function y(e, i) {\n      t.isMS && !t.svg && i && u(i.opacity) && (i.filter = `alpha(opacity=${100 * i.opacity})`), m(e.style, i);\n    }\n    function b(t) {\n      return Math.pow(10, Math.floor(Math.log(t) / Math.LN10));\n    }\n    function v(t, e) {\n      return t > 1e14 ? t : parseFloat(t.toPrecision(e || 14));\n    }\n    (r || (r = {})).messages = [], Math.easeInOutSine = function (t) {\n      return -.5 * (Math.cos(Math.PI * t) - 1);\n    };\n    let M = Array.prototype.find ? function (t, e) {\n      return t.find(e);\n    } : function (t, e) {\n      let i;\n      let s = t.length;\n      for (i = 0; i < s; i++) if (e(t[i], i)) return t[i];\n    };\n    function S(t, e, i) {\n      for (let s in t) Object.hasOwnProperty.call(t, s) && e.call(i || t[s], t[s], s, t);\n    }\n    function k(t, e, i) {\n      function s(e, i) {\n        let s = t.removeEventListener;\n        s && s.call(t, e, i, !1);\n      }\n      function o(i) {\n        let o, r;\n        t.nodeName && (e ? (o = {})[e] = !0 : o = i, S(o, function (t, e) {\n          if (i[e]) for (r = i[e].length; r--;) s(e, i[e][r].fn);\n        }));\n      }\n      let r = "function" == typeof t && t.prototype || t;\n      if (Object.hasOwnProperty.call(r, "hcEvents")) {\n        let t = r.hcEvents;\n        if (e) {\n          let r = t[e] || [];\n          i ? (t[e] = r.filter(function (t) {\n            return i !== t.fn;\n          }), s(e, i)) : (o(t), t[e] = []);\n        } else o(t), delete r.hcEvents;\n      }\n    }\n    function C(e, i, o, r) {\n      let a;\n      if (o = o || {}, s.createEvent && (e.dispatchEvent || e.fireEvent && e !== t)) (a = s.createEvent("Events")).initEvent(i, !0, !0), o = m(a, o), e.dispatchEvent ? e.dispatchEvent(o) : e.fireEvent(i, o);else if (e.hcEvents) {\n        o.target || m(o, {\n          preventDefault: function () {\n            o.defaultPrevented = !0;\n          },\n          target: e,\n          type: i\n        });\n        let t = [],\n          s = e,\n          r = !1;\n        for (; s.hcEvents;) Object.hasOwnProperty.call(s, "hcEvents") && s.hcEvents[i] && (t.length && (r = !0), t.unshift.apply(t, s.hcEvents[i])), s = Object.getPrototypeOf(s);\n        r && t.sort((t, e) => t.order - e.order), t.forEach(t => {\n          !1 === t.fn.call(e, o) && o.preventDefault();\n        });\n      }\n      r && !o.defaultPrevented && r.call(e, o);\n    }\n    S({\n      map: "map",\n      each: "forEach",\n      grep: "filter",\n      reduce: "reduce",\n      some: "some"\n    }, function (e, i) {\n      t[i] = function (t) {\n        return r(32, !1, void 0, {\n          [`Highcharts.${i}`]: `use Array.${e}`\n        }), Array.prototype[e].apply(t, [].slice.call(arguments, 1));\n      };\n    });\n    let A = function () {\n      let t = Math.random().toString(36).substring(2, 9) + "-",\n        i = 0;\n      return function () {\n        return "highcharts-" + (e ? "" : t) + i++;\n      };\n    }();\n    o.jQuery && (o.jQuery.fn.highcharts = function () {\n      let e = [].slice.call(arguments);\n      if (this[0]) return e[0] ? (new t[n(e[0]) ? e.shift() : "Chart"](this[0], e[0], e[1]), this) : i[g(this[0], "data-highcharts-chart")];\n    });\n    let w = {\n      addEvent: function (e, i, s, o = {}) {\n        let r = "function" == typeof e && e.prototype || e;\n        Object.hasOwnProperty.call(r, "hcEvents") || (r.hcEvents = {});\n        let a = r.hcEvents;\n        t.Point && e instanceof t.Point && e.series && e.series.chart && (e.series.chart.runTrackerClick = !0);\n        let n = e.addEventListener;\n        n && n.call(e, i, s, !!t.supportsPassiveEvents && {\n          passive: void 0 === o.passive ? -1 !== i.indexOf("touch") : o.passive,\n          capture: !1\n        }), a[i] || (a[i] = []);\n        let l = {\n          fn: s,\n          order: "number" == typeof o.order ? o.order : 1 / 0\n        };\n        return a[i].push(l), a[i].sort((t, e) => t.order - e.order), function () {\n          k(e, i, s);\n        };\n      },\n      arrayMax: function (t) {\n        let e = t.length,\n          i = t[0];\n        for (; e--;) t[e] > i && (i = t[e]);\n        return i;\n      },\n      arrayMin: function (t) {\n        let e = t.length,\n          i = t[0];\n        for (; e--;) t[e] < i && (i = t[e]);\n        return i;\n      },\n      attr: g,\n      clamp: function (t, e, i) {\n        return t > e ? t < i ? t : i : e;\n      },\n      clearTimeout: function (t) {\n        u(t) && clearTimeout(t);\n      },\n      correctFloat: v,\n      createElement: function (t, e, i, o, r) {\n        let a = s.createElement(t);\n        return e && m(a, e), r && y(a, {\n          padding: "0",\n          border: "none",\n          margin: "0"\n        }), i && y(a, i), o && o.appendChild(a), a;\n      },\n      css: y,\n      defined: u,\n      destroyObjectProperties: function (t, e) {\n        S(t, function (i, s) {\n          i && i !== e && i.destroy && i.destroy(), delete t[s];\n        });\n      },\n      diffObjects: function (t, e, i, s) {\n        let o = {};\n        return function t(e, o, r, a) {\n          let n = i ? o : e;\n          S(e, function (i, d) {\n            if (!a && s && s.indexOf(d) > -1 && o[d]) {\n              i = f(i), r[d] = [];\n              for (let e = 0; e < Math.max(i.length, o[d].length); e++) o[d][e] && (void 0 === i[e] ? r[d][e] = o[d][e] : (r[d][e] = {}, t(i[e], o[d][e], r[d][e], a + 1)));\n            } else h(i, !0) && !i.nodeType ? (r[d] = l(i) ? [] : {}, t(i, o[d] || {}, r[d], a + 1), 0 !== Object.keys(r[d]).length || "colorAxis" === d && 0 === a || delete r[d]) : (e[d] !== o[d] || d in e && !(d in o)) && (r[d] = n[d]);\n          });\n        }(t, e, o, 0), o;\n      },\n      discardElement: function (t) {\n        t && t.parentElement && t.parentElement.removeChild(t);\n      },\n      erase: function (t, e) {\n        let i = t.length;\n        for (; i--;) if (t[i] === e) {\n          t.splice(i, 1);\n          break;\n        }\n      },\n      error: r,\n      extend: m,\n      extendClass: function (t, e) {\n        let i = function () {};\n        return i.prototype = new t(), m(i.prototype, e), i;\n      },\n      find: M,\n      fireEvent: C,\n      getClosestDistance: function (t, e) {\n        let i, s, o;\n        let r = !e;\n        return t.forEach(t => {\n          if (t.length > 1) for (o = t.length - 1; o > 0; o--) (s = t[o] - t[o - 1]) < 0 && !r ? (e?.(), e = void 0) : s && (void 0 === i || s < i) && (i = s);\n        }), i;\n      },\n      getMagnitude: b,\n      getNestedProperty: function (t, e) {\n        let i = t.split(".");\n        for (; i.length && u(e);) {\n          let t = i.shift();\n          if (void 0 === t || "__proto__" === t) return;\n          if ("this" === t) {\n            let t;\n            return h(e) && (t = e["@this"]), t ?? e;\n          }\n          let s = e[t];\n          if (!u(s) || "function" == typeof s || "number" == typeof s.nodeType || s === o) return;\n          e = s;\n        }\n        return e;\n      },\n      getStyle: function t(e, i, s) {\n        let r;\n        if ("width" === i) {\n          let i = Math.min(e.offsetWidth, e.scrollWidth),\n            s = e.getBoundingClientRect && e.getBoundingClientRect().width;\n          return s < i && s >= i - 1 && (i = Math.floor(s)), Math.max(0, i - (t(e, "padding-left", !0) || 0) - (t(e, "padding-right", !0) || 0));\n        }\n        if ("height" === i) return Math.max(0, Math.min(e.offsetHeight, e.scrollHeight) - (t(e, "padding-top", !0) || 0) - (t(e, "padding-bottom", !0) || 0));\n        let n = o.getComputedStyle(e, void 0);\n        return n && (r = n.getPropertyValue(i), x(s, "opacity" !== i) && (r = a(r))), r;\n      },\n      inArray: function (t, e, i) {\n        return r(32, !1, void 0, {\n          "Highcharts.inArray": "use Array.indexOf"\n        }), e.indexOf(t, i);\n      },\n      insertItem: function (t, e) {\n        let i;\n        let s = t.options.index,\n          o = e.length;\n        for (i = t.options.isInternal ? o : 0; i < o + 1; i++) if (!e[i] || p(s) && s < x(e[i].options.index, e[i]._i) || e[i].options.isInternal) {\n          e.splice(i, 0, t);\n          break;\n        }\n        return i;\n      },\n      isArray: l,\n      isClass: c,\n      isDOMElement: d,\n      isFunction: function (t) {\n        return "function" == typeof t;\n      },\n      isNumber: p,\n      isObject: h,\n      isString: n,\n      keys: function (t) {\n        return r(32, !1, void 0, {\n          "Highcharts.keys": "use Object.keys"\n        }), Object.keys(t);\n      },\n      merge: function () {\n        let t,\n          e = arguments,\n          i = {},\n          s = function (t, e) {\n            return "object" != typeof t && (t = {}), S(e, function (i, o) {\n              "__proto__" !== o && "constructor" !== o && (!h(i, !0) || c(i) || d(i) ? t[o] = e[o] : t[o] = s(t[o] || {}, i));\n            }), t;\n          };\n        !0 === e[0] && (i = e[1], e = Array.prototype.slice.call(e, 2));\n        let o = e.length;\n        for (t = 0; t < o; t++) i = s(i, e[t]);\n        return i;\n      },\n      normalizeTickInterval: function (t, e, i, s, o) {\n        let r,\n          a = t;\n        i = x(i, b(t));\n        let n = t / i;\n        for (!e && (e = o ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === s && (1 === i ? e = e.filter(function (t) {\n          return t % 1 == 0;\n        }) : i <= .1 && (e = [1 / i]))), r = 0; r < e.length && (a = e[r], (!o || !(a * i >= t)) && (o || !(n <= (e[r] + (e[r + 1] || e[r])) / 2))); r++);\n        return v(a * i, -Math.round(Math.log(.001) / Math.LN10));\n      },\n      objectEach: S,\n      offset: function (t) {\n        let e = s.documentElement,\n          i = t.parentElement || t.parentNode ? t.getBoundingClientRect() : {\n            top: 0,\n            left: 0,\n            width: 0,\n            height: 0\n          };\n        return {\n          top: i.top + (o.pageYOffset || e.scrollTop) - (e.clientTop || 0),\n          left: i.left + (o.pageXOffset || e.scrollLeft) - (e.clientLeft || 0),\n          width: i.width,\n          height: i.height\n        };\n      },\n      pad: function (t, e, i) {\n        return Array((e || 2) + 1 - String(t).replace("-", "").length).join(i || "0") + t;\n      },\n      pick: x,\n      pInt: a,\n      pushUnique: function (t, e) {\n        return 0 > t.indexOf(e) && !!t.push(e);\n      },\n      relativeLength: function (t, e, i) {\n        return /%$/.test(t) ? e * parseFloat(t) / 100 + (i || 0) : parseFloat(t);\n      },\n      removeEvent: k,\n      splat: f,\n      stableSort: function (t, e) {\n        let i, s;\n        let o = t.length;\n        for (s = 0; s < o; s++) t[s].safeI = s;\n        for (t.sort(function (t, s) {\n          return 0 === (i = e(t, s)) ? t.safeI - s.safeI : i;\n        }), s = 0; s < o; s++) delete t[s].safeI;\n      },\n      syncTimeout: function (t, e, i) {\n        return e > 0 ? setTimeout(t, e, i) : (t.call(0, i), -1);\n      },\n      timeUnits: {\n        millisecond: 1,\n        second: 1e3,\n        minute: 6e4,\n        hour: 36e5,\n        day: 864e5,\n        week: 6048e5,\n        month: 24192e5,\n        year: 314496e5\n      },\n      uniqueKey: A,\n      useSerialIds: function (t) {\n        return e = x(t, e);\n      },\n      wrap: function (t, e, i) {\n        let s = t[e];\n        t[e] = function () {\n          let t = arguments,\n            e = this;\n          return i.apply(this, [function () {\n            return s.apply(e, arguments.length ? arguments : t);\n          }].concat([].slice.call(arguments)));\n        };\n      }\n    };\n    return w;\n  }), i(e, "Core/Chart/ChartDefaults.js", [], function () {\n    return {\n      alignThresholds: !1,\n      panning: {\n        enabled: !1,\n        type: "x"\n      },\n      styledMode: !1,\n      borderRadius: 0,\n      colorCount: 10,\n      allowMutatingData: !0,\n      ignoreHiddenSeries: !0,\n      spacing: [10, 10, 15, 10],\n      resetZoomButton: {\n        theme: {},\n        position: {}\n      },\n      reflow: !0,\n      type: "line",\n      zooming: {\n        singleTouch: !1,\n        resetButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: "right",\n            x: -10,\n            y: 10\n          }\n        }\n      },\n      width: null,\n      height: null,\n      borderColor: "#334eff",\n      backgroundColor: "#ffffff",\n      plotBorderColor: "#cccccc"\n    };\n  }), i(e, "Core/Color/Palettes.js", [], function () {\n    return {\n      colors: ["#2caffe", "#544fc5", "#00e272", "#fe6a35", "#6b8abc", "#d568fb", "#2ee0ca", "#fa4b42", "#feb56a", "#91e8e1"]\n    };\n  }), i(e, "Core/Time.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e) {\n    let {\n        win: i\n      } = t,\n      {\n        defined: s,\n        error: o,\n        extend: r,\n        isNumber: a,\n        isObject: n,\n        merge: l,\n        objectEach: h,\n        pad: d,\n        pick: c,\n        splat: p,\n        timeUnits: u\n      } = e,\n      g = t.isSafari && i.Intl && i.Intl.DateTimeFormat.prototype.formatRange,\n      f = t.isSafari && i.Intl && !i.Intl.DateTimeFormat.prototype.formatRange;\n    return class {\n      constructor(t) {\n        this.options = {}, this.useUTC = !1, this.variableTimezone = !1, this.Date = i.Date, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.update(t);\n      }\n      get(t, e) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          let i = e.getTime(),\n            s = i - this.getTimezoneOffset(e);\n          e.setTime(s);\n          let o = e["getUTC" + t]();\n          return e.setTime(i), o;\n        }\n        return this.useUTC ? e["getUTC" + t]() : e["get" + t]();\n      }\n      set(t, e, i) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          if ("Milliseconds" === t || "Seconds" === t || "Minutes" === t && this.getTimezoneOffset(e) % 36e5 == 0) return e["setUTC" + t](i);\n          let s = this.getTimezoneOffset(e),\n            o = e.getTime() - s;\n          e.setTime(o), e["setUTC" + t](i);\n          let r = this.getTimezoneOffset(e);\n          return o = e.getTime() + r, e.setTime(o);\n        }\n        return this.useUTC || g && "FullYear" === t ? e["setUTC" + t](i) : e["set" + t](i);\n      }\n      update(t = {}) {\n        let e = c(t.useUTC, !0);\n        this.options = t = l(!0, this.options, t), this.Date = t.Date || i.Date || Date, this.useUTC = e, this.timezoneOffset = e && t.timezoneOffset || void 0, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.variableTimezone = e && !!(t.getTimezoneOffset || t.timezone);\n      }\n      makeTime(t, e, i, s, o, r) {\n        let a, n, l;\n        return this.useUTC ? (a = this.Date.UTC.apply(0, arguments), n = this.getTimezoneOffset(a), a += n, n !== (l = this.getTimezoneOffset(a)) ? a += l - n : n - 36e5 !== this.getTimezoneOffset(a - 36e5) || f || (a -= 36e5)) : a = new this.Date(t, e, c(i, 1), c(s, 0), c(o, 0), c(r, 0)).getTime(), a;\n      }\n      timezoneOffsetFunction() {\n        let t = this,\n          e = this.options,\n          i = e.getTimezoneOffset;\n        return this.useUTC ? e.timezone ? t => {\n          try {\n            let [i, s, o, r, n = 0] = Intl.DateTimeFormat("en", {\n                timeZone: e.timezone,\n                timeZoneName: "shortOffset"\n              }).format(t).split(/(GMT|:)/).map(Number),\n              l = -(36e5 * (o + n / 60));\n            if (a(l)) return l;\n          } catch (t) {\n            o(34);\n          }\n          return 0;\n        } : this.useUTC && i ? t => 6e4 * i(t.valueOf()) : () => 6e4 * (t.timezoneOffset || 0) : t => 6e4 * new Date(t.toString()).getTimezoneOffset();\n      }\n      dateFormat(e, i, o) {\n        if (!s(i) || isNaN(i)) return t.defaultOptions.lang && t.defaultOptions.lang.invalidDate || "";\n        e = c(e, "%Y-%m-%d %H:%M:%S");\n        let a = this,\n          n = new this.Date(i),\n          l = this.get("Hours", n),\n          p = this.get("Day", n),\n          u = this.get("Date", n),\n          g = this.get("Month", n),\n          f = this.get("FullYear", n),\n          m = t.defaultOptions.lang,\n          x = m && m.weekdays,\n          y = m && m.shortWeekdays,\n          b = r({\n            a: y ? y[p] : x[p].substr(0, 3),\n            A: x[p],\n            d: d(u),\n            e: d(u, 2, " "),\n            w: p,\n            b: m.shortMonths[g],\n            B: m.months[g],\n            m: d(g + 1),\n            o: g + 1,\n            y: f.toString().substr(2, 2),\n            Y: f,\n            H: d(l),\n            k: l,\n            I: d(l % 12 || 12),\n            l: l % 12 || 12,\n            M: d(this.get("Minutes", n)),\n            p: l < 12 ? "AM" : "PM",\n            P: l < 12 ? "am" : "pm",\n            S: d(this.get("Seconds", n)),\n            L: d(Math.floor(i % 1e3), 3)\n          }, t.dateFormats);\n        return h(b, function (t, s) {\n          for (; -1 !== e.indexOf("%" + s);) e = e.replace("%" + s, "function" == typeof t ? t.call(a, i) : t);\n        }), o ? e.substr(0, 1).toUpperCase() + e.substr(1) : e;\n      }\n      resolveDTLFormat(t) {\n        return n(t, !0) ? t : {\n          main: (t = p(t))[0],\n          from: t[1],\n          to: t[2]\n        };\n      }\n      getTimeTicks(t, e, i, o) {\n        let a, n, l, h;\n        let d = this,\n          p = d.Date,\n          g = [],\n          f = {},\n          m = new p(e),\n          x = t.unitRange,\n          y = t.count || 1;\n        if (o = c(o, 1), s(e)) {\n          d.set("Milliseconds", m, x >= u.second ? 0 : y * Math.floor(d.get("Milliseconds", m) / y)), x >= u.second && d.set("Seconds", m, x >= u.minute ? 0 : y * Math.floor(d.get("Seconds", m) / y)), x >= u.minute && d.set("Minutes", m, x >= u.hour ? 0 : y * Math.floor(d.get("Minutes", m) / y)), x >= u.hour && d.set("Hours", m, x >= u.day ? 0 : y * Math.floor(d.get("Hours", m) / y)), x >= u.day && d.set("Date", m, x >= u.month ? 1 : Math.max(1, y * Math.floor(d.get("Date", m) / y))), x >= u.month && (d.set("Month", m, x >= u.year ? 0 : y * Math.floor(d.get("Month", m) / y)), n = d.get("FullYear", m)), x >= u.year && (n -= n % y, d.set("FullYear", m, n)), x === u.week && (h = d.get("Day", m), d.set("Date", m, d.get("Date", m) - h + o + (h < o ? -7 : 0))), n = d.get("FullYear", m);\n          let t = d.get("Month", m),\n            r = d.get("Date", m),\n            c = d.get("Hours", m);\n          e = m.getTime(), (d.variableTimezone || !d.useUTC) && s(i) && (l = i - e > 4 * u.month || d.getTimezoneOffset(e) !== d.getTimezoneOffset(i));\n          let p = m.getTime();\n          for (a = 1; p < i;) g.push(p), x === u.year ? p = d.makeTime(n + a * y, 0) : x === u.month ? p = d.makeTime(n, t + a * y) : l && (x === u.day || x === u.week) ? p = d.makeTime(n, t, r + a * y * (x === u.day ? 1 : 7)) : l && x === u.hour && y > 1 ? p = d.makeTime(n, t, r, c + a * y) : p += x * y, a++;\n          g.push(p), x <= u.hour && g.length < 1e4 && g.forEach(function (t) {\n            t % 18e5 == 0 && "000000000" === d.dateFormat("%H%M%S%L", t) && (f[t] = "day");\n          });\n        }\n        return g.info = r(t, {\n          higherRanks: f,\n          totalRange: x * y\n        }), g;\n      }\n      getDateFormat(t, e, i, s) {\n        let o = this.dateFormat("%m-%d %H:%M:%S.%L", e),\n          r = "01-01 00:00:00.000",\n          a = {\n            millisecond: 15,\n            second: 12,\n            minute: 9,\n            hour: 6,\n            day: 3\n          },\n          n = "millisecond",\n          l = n;\n        for (n in u) {\n          if (t === u.week && +this.dateFormat("%w", e) === i && o.substr(6) === r.substr(6)) {\n            n = "week";\n            break;\n          }\n          if (u[n] > t) {\n            n = l;\n            break;\n          }\n          if (a[n] && o.substr(a[n]) !== r.substr(a[n])) break;\n          "week" !== n && (l = n);\n        }\n        return this.resolveDTLFormat(s[n]).main;\n      }\n    };\n  }), i(e, "Core/Defaults.js", [e["Core/Chart/ChartDefaults.js"], e["Core/Globals.js"], e["Core/Color/Palettes.js"], e["Core/Time.js"], e["Core/Utilities.js"]], function (t, e, i, s, o) {\n    let {\n        isTouchDevice: r,\n        svg: a\n      } = e,\n      {\n        merge: n\n      } = o,\n      l = {\n        colors: i.colors,\n        symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],\n        lang: {\n          loading: "Loading...",\n          months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],\n          shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],\n          weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],\n          decimalPoint: ".",\n          numericSymbols: ["k", "M", "G", "T", "P", "E"],\n          resetZoom: "Reset zoom",\n          resetZoomTitle: "Reset zoom level 1:1",\n          thousandsSep: " "\n        },\n        global: {},\n        time: {\n          Date: void 0,\n          getTimezoneOffset: void 0,\n          timezone: void 0,\n          timezoneOffset: 0,\n          useUTC: !0\n        },\n        chart: t,\n        title: {\n          style: {\n            color: "#333333",\n            fontWeight: "bold"\n          },\n          text: "Chart title",\n          align: "center",\n          margin: 15,\n          widthAdjust: -44\n        },\n        subtitle: {\n          style: {\n            color: "#666666",\n            fontSize: "0.8em"\n          },\n          text: "",\n          align: "center",\n          widthAdjust: -44\n        },\n        caption: {\n          margin: 15,\n          style: {\n            color: "#666666",\n            fontSize: "0.8em"\n          },\n          text: "",\n          align: "left",\n          verticalAlign: "bottom"\n        },\n        plotOptions: {},\n        legend: {\n          enabled: !0,\n          align: "center",\n          alignColumns: !0,\n          className: "highcharts-no-tooltip",\n          layout: "horizontal",\n          itemMarginBottom: 2,\n          itemMarginTop: 2,\n          labelFormatter: function () {\n            return this.name;\n          },\n          borderColor: "#999999",\n          borderRadius: 0,\n          navigation: {\n            style: {\n              fontSize: "0.8em"\n            },\n            activeColor: "#0022ff",\n            inactiveColor: "#cccccc"\n          },\n          itemStyle: {\n            color: "#333333",\n            cursor: "pointer",\n            fontSize: "0.8em",\n            textDecoration: "none",\n            textOverflow: "ellipsis"\n          },\n          itemHoverStyle: {\n            color: "#000000"\n          },\n          itemHiddenStyle: {\n            color: "#666666",\n            textDecoration: "line-through"\n          },\n          shadow: !1,\n          itemCheckboxStyle: {\n            position: "absolute",\n            width: "13px",\n            height: "13px"\n          },\n          squareSymbol: !0,\n          symbolPadding: 5,\n          verticalAlign: "bottom",\n          x: 0,\n          y: 0,\n          title: {\n            style: {\n              fontSize: "0.8em",\n              fontWeight: "bold"\n            }\n          }\n        },\n        loading: {\n          labelStyle: {\n            fontWeight: "bold",\n            position: "relative",\n            top: "45%"\n          },\n          style: {\n            position: "absolute",\n            backgroundColor: "#ffffff",\n            opacity: .5,\n            textAlign: "center"\n          }\n        },\n        tooltip: {\n          enabled: !0,\n          animation: a,\n          borderRadius: 3,\n          dateTimeLabelFormats: {\n            millisecond: "%A, %e %b, %H:%M:%S.%L",\n            second: "%A, %e %b, %H:%M:%S",\n            minute: "%A, %e %b, %H:%M",\n            hour: "%A, %e %b, %H:%M",\n            day: "%A, %e %b %Y",\n            week: "Week from %A, %e %b %Y",\n            month: "%B %Y",\n            year: "%Y"\n          },\n          footerFormat: "",\n          headerShape: "callout",\n          hideDelay: 500,\n          padding: 8,\n          shape: "callout",\n          shared: !1,\n          snap: r ? 25 : 10,\n          headerFormat: \'<span style="font-size: 0.8em">{point.key}</span><br/>\',\n          pointFormat: \'<span style="color:{point.color}">‚óè</span> {series.name}: <b>{point.y}</b><br/>\',\n          backgroundColor: "#ffffff",\n          borderWidth: void 0,\n          shadow: !0,\n          stickOnContact: !1,\n          style: {\n            color: "#333333",\n            cursor: "default",\n            fontSize: "0.8em"\n          },\n          useHTML: !1\n        },\n        credits: {\n          enabled: !0,\n          href: "https://www.highcharts.com?credits",\n          position: {\n            align: "right",\n            x: -10,\n            verticalAlign: "bottom",\n            y: -5\n          },\n          style: {\n            cursor: "pointer",\n            color: "#999999",\n            fontSize: "0.6em"\n          },\n          text: "Highcharts.com"\n        }\n      };\n    l.chart.styledMode = !1;\n    let h = new s(l.time);\n    return {\n      defaultOptions: l,\n      defaultTime: h,\n      getOptions: function () {\n        return l;\n      },\n      setOptions: function (t) {\n        return n(!0, l, t), (t.time || t.global) && (e.time ? e.time.update(n(l.global, l.time, t.global, t.time)) : e.time = h), l;\n      }\n    };\n  }), i(e, "Core/Color/Color.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e) {\n    let {\n      isNumber: i,\n      merge: s,\n      pInt: o\n    } = e;\n    class r {\n      static parse(t) {\n        return t ? new r(t) : r.None;\n      }\n      constructor(e) {\n        let i, s, o, a;\n        this.rgba = [NaN, NaN, NaN, NaN], this.input = e;\n        let n = t.Color;\n        if (n && n !== r) return new n(e);\n        if ("object" == typeof e && void 0 !== e.stops) this.stops = e.stops.map(t => new r(t[1]));else if ("string" == typeof e) {\n          if (this.input = e = r.names[e.toLowerCase()] || e, "#" === e.charAt(0)) {\n            let t = e.length,\n              i = parseInt(e.substr(1), 16);\n            7 === t ? s = [(16711680 & i) >> 16, (65280 & i) >> 8, 255 & i, 1] : 4 === t && (s = [(3840 & i) >> 4 | (3840 & i) >> 8, (240 & i) >> 4 | 240 & i, (15 & i) << 4 | 15 & i, 1]);\n          }\n          if (!s) for (o = r.parsers.length; o-- && !s;) (i = (a = r.parsers[o]).regex.exec(e)) && (s = a.parse(i));\n        }\n        s && (this.rgba = s);\n      }\n      get(t) {\n        let e = this.input,\n          o = this.rgba;\n        if ("object" == typeof e && void 0 !== this.stops) {\n          let i = s(e);\n          return i.stops = [].slice.call(i.stops), this.stops.forEach((e, s) => {\n            i.stops[s] = [i.stops[s][0], e.get(t)];\n          }), i;\n        }\n        return o && i(o[0]) ? "rgb" !== t && (t || 1 !== o[3]) ? "a" === t ? `${o[3]}` : "rgba(" + o.join(",") + ")" : "rgb(" + o[0] + "," + o[1] + "," + o[2] + ")" : e;\n      }\n      brighten(t) {\n        let e = this.rgba;\n        if (this.stops) this.stops.forEach(function (e) {\n          e.brighten(t);\n        });else if (i(t) && 0 !== t) for (let i = 0; i < 3; i++) e[i] += o(255 * t), e[i] < 0 && (e[i] = 0), e[i] > 255 && (e[i] = 255);\n        return this;\n      }\n      setOpacity(t) {\n        return this.rgba[3] = t, this;\n      }\n      tweenTo(t, e) {\n        let s = this.rgba,\n          o = t.rgba;\n        if (!i(s[0]) || !i(o[0])) return t.input || "none";\n        let r = 1 !== o[3] || 1 !== s[3];\n        return (r ? "rgba(" : "rgb(") + Math.round(o[0] + (s[0] - o[0]) * (1 - e)) + "," + Math.round(o[1] + (s[1] - o[1]) * (1 - e)) + "," + Math.round(o[2] + (s[2] - o[2]) * (1 - e)) + (r ? "," + (o[3] + (s[3] - o[3]) * (1 - e)) : "") + ")";\n      }\n    }\n    return r.names = {\n      white: "#ffffff",\n      black: "#000000"\n    }, r.parsers = [{\n      regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n      parse: function (t) {\n        return [o(t[1]), o(t[2]), o(t[3]), parseFloat(t[4], 10)];\n      }\n    }, {\n      regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n      parse: function (t) {\n        return [o(t[1]), o(t[2]), o(t[3]), 1];\n      }\n    }], r.None = new r(""), r;\n  }), i(e, "Core/Animation/Fx.js", [e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e, i) {\n    let {\n        parse: s\n      } = t,\n      {\n        win: o\n      } = e,\n      {\n        isNumber: r,\n        objectEach: a\n      } = i;\n    class n {\n      constructor(t, e, i) {\n        this.pos = NaN, this.options = e, this.elem = t, this.prop = i;\n      }\n      dSetter() {\n        let t = this.paths,\n          e = t && t[0],\n          i = t && t[1],\n          s = this.now || 0,\n          o = [];\n        if (1 !== s && e && i) {\n          if (e.length === i.length && s < 1) for (let t = 0; t < i.length; t++) {\n            let a = e[t],\n              n = i[t],\n              l = [];\n            for (let t = 0; t < n.length; t++) {\n              let e = a[t],\n                i = n[t];\n              r(e) && r(i) && !("A" === n[0] && (4 === t || 5 === t)) ? l[t] = e + s * (i - e) : l[t] = i;\n            }\n            o.push(l);\n          } else o = i;\n        } else o = this.toD || [];\n        this.elem.attr("d", o, void 0, !0);\n      }\n      update() {\n        let t = this.elem,\n          e = this.prop,\n          i = this.now,\n          s = this.options.step;\n        this[e + "Setter"] ? this[e + "Setter"]() : t.attr ? t.element && t.attr(e, i, null, !0) : t.style[e] = i + this.unit, s && s.call(t, i, this);\n      }\n      run(t, e, i) {\n        let s = this,\n          r = s.options,\n          a = function (t) {\n            return !a.stopped && s.step(t);\n          },\n          l = o.requestAnimationFrame || function (t) {\n            setTimeout(t, 13);\n          },\n          h = function () {\n            for (let t = 0; t < n.timers.length; t++) n.timers[t]() || n.timers.splice(t--, 1);\n            n.timers.length && l(h);\n          };\n        t !== e || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = t, this.end = e, this.unit = i, this.now = this.start, this.pos = 0, a.elem = this.elem, a.prop = this.prop, a() && 1 === n.timers.push(a) && l(h)) : (delete r.curAnim[this.prop], r.complete && 0 === Object.keys(r.curAnim).length && r.complete.call(this.elem));\n      }\n      step(t) {\n        let e, i;\n        let s = +new Date(),\n          o = this.options,\n          r = this.elem,\n          n = o.complete,\n          l = o.duration,\n          h = o.curAnim;\n        return r.attr && !r.element ? e = !1 : t || s >= l + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), h[this.prop] = !0, i = !0, a(h, function (t) {\n          !0 !== t && (i = !1);\n        }), i && n && n.call(r), e = !1) : (this.pos = o.easing((s - this.startTime) / l), this.now = this.start + (this.end - this.start) * this.pos, this.update(), e = !0), e;\n      }\n      initPath(t, e, i) {\n        let s = t.startX,\n          o = t.endX,\n          a = i.slice(),\n          n = t.isArea,\n          l = n ? 2 : 1,\n          h,\n          d,\n          c,\n          p,\n          u = e && e.slice();\n        if (!u) return [a, a];\n        function g(t, e) {\n          for (; t.length < d;) {\n            let i = t[0],\n              s = e[d - t.length];\n            if (s && "M" === i[0] && ("C" === s[0] ? t[0] = ["C", i[1], i[2], i[1], i[2], i[1], i[2]] : t[0] = ["L", i[1], i[2]]), t.unshift(i), n) {\n              let e = t.pop();\n              t.push(t[t.length - 1], e);\n            }\n          }\n        }\n        function f(t, e) {\n          for (; t.length < d;) {\n            let e = t[Math.floor(t.length / l) - 1].slice();\n            if ("C" === e[0] && (e[1] = e[5], e[2] = e[6]), n) {\n              let i = t[Math.floor(t.length / l)].slice();\n              t.splice(t.length / 2, 0, e, i);\n            } else t.push(e);\n          }\n        }\n        if (s && o && o.length) {\n          for (c = 0; c < s.length; c++) {\n            if (s[c] === o[0]) {\n              h = c;\n              break;\n            }\n            if (s[0] === o[o.length - s.length + c]) {\n              h = c, p = !0;\n              break;\n            }\n            if (s[s.length - 1] === o[o.length - s.length + c]) {\n              h = s.length - c;\n              break;\n            }\n          }\n          void 0 === h && (u = []);\n        }\n        return u.length && r(h) && (d = a.length + h * l, p ? (g(u, a), f(a, u)) : (g(a, u), f(u, a))), [u, a];\n      }\n      fillSetter() {\n        n.prototype.strokeSetter.apply(this, arguments);\n      }\n      strokeSetter() {\n        this.elem.attr(this.prop, s(this.start).tweenTo(s(this.end), this.pos), void 0, !0);\n      }\n    }\n    return n.timers = [], n;\n  }), i(e, "Core/Animation/AnimationUtilities.js", [e["Core/Animation/Fx.js"], e["Core/Utilities.js"]], function (t, e) {\n    let {\n      defined: i,\n      getStyle: s,\n      isArray: o,\n      isNumber: r,\n      isObject: a,\n      merge: n,\n      objectEach: l,\n      pick: h\n    } = e;\n    function d(t) {\n      return a(t) ? n({\n        duration: 500,\n        defer: 0\n      }, t) : {\n        duration: t ? 500 : 0,\n        defer: 0\n      };\n    }\n    function c(e, i) {\n      let s = t.timers.length;\n      for (; s--;) t.timers[s].elem !== e || i && i !== t.timers[s].prop || (t.timers[s].stopped = !0);\n    }\n    return {\n      animate: function (e, i, h) {\n        let d,\n          p = "",\n          u,\n          g,\n          f;\n        a(h) || (f = arguments, h = {\n          duration: f[2],\n          easing: f[3],\n          complete: f[4]\n        }), r(h.duration) || (h.duration = 400), h.easing = "function" == typeof h.easing ? h.easing : Math[h.easing] || Math.easeInOutSine, h.curAnim = n(i), l(i, function (r, a) {\n          c(e, a), g = new t(e, h, a), u = void 0, "d" === a && o(i.d) ? (g.paths = g.initPath(e, e.pathArray, i.d), g.toD = i.d, d = 0, u = 1) : e.attr ? d = e.attr(a) : (d = parseFloat(s(e, a)) || 0, "opacity" !== a && (p = "px")), u || (u = r), "string" == typeof u && u.match("px") && (u = u.replace(/px/g, "")), g.run(d, u, p);\n        });\n      },\n      animObject: d,\n      getDeferredAnimation: function (t, e, s) {\n        let o = d(e),\n          r = s ? [s] : t.series,\n          n = 0,\n          l = 0;\n        r.forEach(t => {\n          let s = d(t.options.animation);\n          n = a(e) && i(e.defer) ? o.defer : Math.max(n, s.duration + s.defer), l = Math.min(o.duration, s.duration);\n        }), t.renderer.forExport && (n = 0);\n        let h = {\n          defer: Math.max(0, n - l),\n          duration: Math.min(n, l)\n        };\n        return h;\n      },\n      setAnimation: function (t, e) {\n        e.renderer.globalAnimation = h(t, e.options.chart.animation, !0);\n      },\n      stop: c\n    };\n  }), i(e, "Core/Renderer/HTML/AST.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e) {\n    let {\n        SVG_NS: i,\n        win: s\n      } = t,\n      {\n        attr: o,\n        createElement: r,\n        css: a,\n        error: n,\n        isFunction: l,\n        isString: h,\n        objectEach: d,\n        splat: c\n      } = e,\n      {\n        trustedTypes: p\n      } = s,\n      u = p && l(p.createPolicy) && p.createPolicy("highcharts", {\n        createHTML: t => t\n      }),\n      g = u ? u.createHTML("") : "",\n      f = function () {\n        try {\n          return !!new DOMParser().parseFromString(g, "text/html");\n        } catch (t) {\n          return !1;\n        }\n      }();\n    class m {\n      static filterUserAttributes(t) {\n        return d(t, (e, i) => {\n          let s = !0;\n          -1 === m.allowedAttributes.indexOf(i) && (s = !1), -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(i) && (s = h(e) && m.allowedReferences.some(t => 0 === e.indexOf(t))), s || (n(33, !1, void 0, {\n            "Invalid attribute in config": `${i}`\n          }), delete t[i]), h(e) && t[i] && (t[i] = e.replace(/</g, "&lt;"));\n        }), t;\n      }\n      static parseStyle(t) {\n        return t.split(";").reduce((t, e) => {\n          let i = e.split(":").map(t => t.trim()),\n            s = i.shift();\n          return s && i.length && (t[s.replace(/-([a-z])/g, t => t[1].toUpperCase())] = i.join(":")), t;\n        }, {});\n      }\n      static setElementHTML(t, e) {\n        if (t.innerHTML = m.emptyHTML, e) {\n          let i = new m(e);\n          i.addToDOM(t);\n        }\n      }\n      constructor(t) {\n        this.nodes = "string" == typeof t ? this.parseMarkup(t) : t;\n      }\n      addToDOM(e) {\n        return function e(s, r) {\n          let l;\n          return c(s).forEach(function (s) {\n            let h;\n            let c = s.tagName,\n              p = s.textContent ? t.doc.createTextNode(s.textContent) : void 0,\n              u = m.bypassHTMLFiltering;\n            if (c) {\n              if ("#text" === c) h = p;else if (-1 !== m.allowedTags.indexOf(c) || u) {\n                let n = "svg" === c ? i : r.namespaceURI || i,\n                  l = t.doc.createElementNS(n, c),\n                  g = s.attributes || {};\n                d(s, function (t, e) {\n                  "tagName" !== e && "attributes" !== e && "children" !== e && "style" !== e && "textContent" !== e && (g[e] = t);\n                }), o(l, u ? g : m.filterUserAttributes(g)), s.style && a(l, s.style), p && l.appendChild(p), e(s.children || [], l), h = l;\n              } else n(33, !1, void 0, {\n                "Invalid tagName in config": c\n              });\n            }\n            h && r.appendChild(h), l = h;\n          }), l;\n        }(this.nodes, e);\n      }\n      parseMarkup(t) {\n        let e;\n        let i = [];\n        if (t = t.trim().replace(/ style=(["\'])/g, " data-style=$1"), f) e = new DOMParser().parseFromString(u ? u.createHTML(t) : t, "text/html");else {\n          let i = r("div");\n          i.innerHTML = t, e = {\n            body: i\n          };\n        }\n        let s = (t, e) => {\n          let i = t.nodeName.toLowerCase(),\n            o = {\n              tagName: i\n            };\n          "#text" === i && (o.textContent = t.textContent || "");\n          let r = t.attributes;\n          if (r) {\n            let t = {};\n            [].forEach.call(r, e => {\n              "data-style" === e.name ? o.style = m.parseStyle(e.value) : t[e.name] = e.value;\n            }), o.attributes = t;\n          }\n          if (t.childNodes.length) {\n            let e = [];\n            [].forEach.call(t.childNodes, t => {\n              s(t, e);\n            }), e.length && (o.children = e);\n          }\n          e.push(o);\n        };\n        return [].forEach.call(e.body.childNodes, t => s(t, i)), i;\n      }\n    }\n    return m.allowedAttributes = ["alt", "aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup", "aria-hidden", "aria-label", "aria-labelledby", "aria-live", "aria-pressed", "aria-readonly", "aria-roledescription", "aria-selected", "class", "clip-path", "color", "colspan", "cx", "cy", "d", "dx", "dy", "disabled", "fill", "filterUnits", "flood-color", "flood-opacity", "height", "href", "id", "in", "markerHeight", "markerWidth", "offset", "opacity", "orient", "padding", "paddingLeft", "paddingRight", "patternUnits", "r", "refX", "refY", "role", "scope", "slope", "src", "startOffset", "stdDeviation", "stroke", "stroke-linecap", "stroke-width", "style", "tableValues", "result", "rowspan", "summary", "target", "tabindex", "text-align", "text-anchor", "textAnchor", "textLength", "title", "type", "valign", "width", "x", "x1", "x2", "xlink:href", "y", "y1", "y2", "zIndex"], m.allowedReferences = ["https://", "http://", "mailto:", "/", "../", "./", "#"], m.allowedTags = ["a", "abbr", "b", "br", "button", "caption", "circle", "clipPath", "code", "dd", "defs", "div", "dl", "dt", "em", "feComponentTransfer", "feDropShadow", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feOffset", "feMerge", "feMergeNode", "filter", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "i", "img", "li", "linearGradient", "marker", "ol", "p", "path", "pattern", "pre", "rect", "small", "span", "stop", "strong", "style", "sub", "sup", "svg", "table", "text", "textPath", "thead", "title", "tbody", "tspan", "td", "th", "tr", "u", "ul", "#text"], m.emptyHTML = g, m.bypassHTMLFiltering = !1, m;\n  }), i(e, "Core/Templating.js", [e["Core/Defaults.js"], e["Core/Utilities.js"]], function (t, e) {\n    let {\n        defaultOptions: i,\n        defaultTime: s\n      } = t,\n      {\n        extend: o,\n        getNestedProperty: r,\n        isArray: a,\n        isNumber: n,\n        isObject: l,\n        isString: h,\n        pick: d,\n        pInt: c\n      } = e,\n      p = {\n        add: (t, e) => t + e,\n        divide: (t, e) => 0 !== e ? t / e : "",\n        eq: (t, e) => t == e,\n        each: function (t) {\n          let e = arguments[arguments.length - 1];\n          return !!a(t) && t.map((i, s) => u(e.body, o(l(i) ? i : {\n            "@this": i\n          }, {\n            "@index": s,\n            "@first": 0 === s,\n            "@last": s === t.length - 1\n          }))).join("");\n        },\n        ge: (t, e) => t >= e,\n        gt: (t, e) => t > e,\n        if: t => !!t,\n        le: (t, e) => t <= e,\n        lt: (t, e) => t < e,\n        multiply: (t, e) => t * e,\n        ne: (t, e) => t != e,\n        subtract: (t, e) => t - e,\n        unless: t => !t\n      };\n    function u(t = "", e, o) {\n      let a = /\\{([a-zA-Z0-9\\:\\.\\,;\\-\\/<>%_@"\'= #\\(\\)]+)\\}/g,\n        n = /\\(([a-zA-Z0-9\\:\\.\\,;\\-\\/<>%_@"\'= ]+)\\)/g,\n        l = [],\n        h = /f$/,\n        c = /\\.([0-9])/,\n        f = i.lang,\n        m = o && o.time || s,\n        x = o && o.numberFormatter || g,\n        y = (t = "") => {\n          let i;\n          return "true" === t || "false" !== t && ((i = Number(t)).toString() === t ? i : r(t, e));\n        },\n        b,\n        v,\n        M = 0,\n        S;\n      for (; null !== (b = a.exec(t));) {\n        let i = n.exec(b[1]);\n        i && (b = i, S = !0), v && v.isBlock || (v = {\n          ctx: e,\n          expression: b[1],\n          find: b[0],\n          isBlock: "#" === b[1].charAt(0),\n          start: b.index,\n          startInner: b.index + b[0].length,\n          length: b[0].length\n        });\n        let s = b[1].split(" ")[0].replace("#", "");\n        p[s] && (v.isBlock && s === v.fn && M++, v.fn || (v.fn = s));\n        let o = "else" === b[1];\n        if (v.isBlock && v.fn && (b[1] === `/${v.fn}` || o)) {\n          if (M) !o && M--;else {\n            let e = v.startInner,\n              i = t.substr(e, b.index - e);\n            void 0 === v.body ? (v.body = i, v.startInner = b.index + b[0].length) : v.elseBody = i, v.find += i + b[0], o || (l.push(v), v = void 0);\n          }\n        } else v.isBlock || l.push(v);\n        if (i && !v?.isBlock) break;\n      }\n      return l.forEach(i => {\n        let s, o;\n        let {\n          body: r,\n          elseBody: a,\n          expression: n,\n          fn: l\n        } = i;\n        if (l) {\n          let t = [i],\n            h = n.split(" ");\n          for (o = p[l].length; o--;) t.unshift(y(h[o + 1]));\n          s = p[l].apply(e, t), i.isBlock && "boolean" == typeof s && (s = u(s ? r : a, e));\n        } else {\n          let t = n.split(":");\n          if (s = y(t.shift() || ""), t.length && "number" == typeof s) {\n            let e = t.join(":");\n            if (h.test(e)) {\n              let t = parseInt((e.match(c) || ["", "-1"])[1], 10);\n              null !== s && (s = x(s, t, f.decimalPoint, e.indexOf(",") > -1 ? f.thousandsSep : ""));\n            } else s = m.dateFormat(e, s);\n          }\n        }\n        t = t.replace(i.find, d(s, ""));\n      }), S ? u(t, e, o) : t;\n    }\n    function g(t, e, s, o) {\n      let r, a;\n      t = +t || 0, e = +e;\n      let l = i.lang,\n        h = (t.toString().split(".")[1] || "").split("e")[0].length,\n        p = t.toString().split("e"),\n        u = e;\n      -1 === e ? e = Math.min(h, 20) : n(e) ? e && p[1] && p[1] < 0 && ((a = e + +p[1]) >= 0 ? (p[0] = (+p[0]).toExponential(a).split("e")[0], e = a) : (p[0] = p[0].split(".")[0] || 0, t = e < 20 ? (p[0] * Math.pow(10, p[1])).toFixed(e) : 0, p[1] = 0)) : e = 2;\n      let g = (Math.abs(p[1] ? p[0] : t) + Math.pow(10, -Math.max(e, h) - 1)).toFixed(e),\n        f = String(c(g)),\n        m = f.length > 3 ? f.length % 3 : 0;\n      return s = d(s, l.decimalPoint), o = d(o, l.thousandsSep), r = (t < 0 ? "-" : "") + (m ? f.substr(0, m) + o : ""), 0 > +p[1] && !u ? r = "0" : r += f.substr(m).replace(/(\\d{3})(?=\\d)/g, "$1" + o), e && (r += s + g.slice(-e)), p[1] && 0 != +r && (r += "e" + p[1]), r;\n    }\n    return {\n      dateFormat: function (t, e, i) {\n        return s.dateFormat(t, e, i);\n      },\n      format: u,\n      helpers: p,\n      numberFormat: g\n    };\n  }), i(e, "Core/Renderer/RendererUtilities.js", [e["Core/Utilities.js"]], function (t) {\n    var e;\n    let {\n      clamp: i,\n      pick: s,\n      pushUnique: o,\n      stableSort: r\n    } = t;\n    return (e || (e = {})).distribute = function t(e, a, n) {\n      let l = e,\n        h = l.reducedLen || a,\n        d = (t, e) => t.target - e.target,\n        c = [],\n        p = e.length,\n        u = [],\n        g = c.push,\n        f,\n        m,\n        x,\n        y = !0,\n        b,\n        v,\n        M = 0,\n        S;\n      for (f = p; f--;) M += e[f].size;\n      if (M > h) {\n        for (r(e, (t, e) => (e.rank || 0) - (t.rank || 0)), x = (S = e[0].rank === e[e.length - 1].rank) ? p / 2 : -1, m = S ? x : p - 1; x && M > h;) b = e[f = Math.floor(m)], o(u, f) && (M -= b.size), m += x, S && m >= e.length && (x /= 2, m = x);\n        u.sort((t, e) => e - t).forEach(t => g.apply(c, e.splice(t, 1)));\n      }\n      for (r(e, d), e = e.map(t => ({\n        size: t.size,\n        targets: [t.target],\n        align: s(t.align, .5)\n      })); y;) {\n        for (f = e.length; f--;) b = e[f], v = (Math.min.apply(0, b.targets) + Math.max.apply(0, b.targets)) / 2, b.pos = i(v - b.size * b.align, 0, a - b.size);\n        for (f = e.length, y = !1; f--;) f > 0 && e[f - 1].pos + e[f - 1].size > e[f].pos && (e[f - 1].size += e[f].size, e[f - 1].targets = e[f - 1].targets.concat(e[f].targets), e[f - 1].align = .5, e[f - 1].pos + e[f - 1].size > a && (e[f - 1].pos = a - e[f - 1].size), e.splice(f, 1), y = !0);\n      }\n      return g.apply(l, c), f = 0, e.some(e => {\n        let i = 0;\n        return (e.targets || []).some(() => (l[f].pos = e.pos + i, void 0 !== n && Math.abs(l[f].pos - l[f].target) > n) ? (l.slice(0, f + 1).forEach(t => delete t.pos), l.reducedLen = (l.reducedLen || a) - .1 * a, l.reducedLen > .1 * a && t(l, a, n), !0) : (i += l[f].size, f++, !1));\n      }), r(l, d), l;\n    }, e;\n  }), i(e, "Core/Renderer/SVG/SVGElement.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e, i, s) {\n    let {\n        animate: o,\n        animObject: r,\n        stop: a\n      } = t,\n      {\n        deg2rad: n,\n        doc: l,\n        noop: h,\n        svg: d,\n        SVG_NS: c,\n        win: p\n      } = i,\n      {\n        addEvent: u,\n        attr: g,\n        createElement: f,\n        css: m,\n        defined: x,\n        erase: y,\n        extend: b,\n        fireEvent: v,\n        isArray: M,\n        isFunction: S,\n        isObject: k,\n        isString: C,\n        merge: A,\n        objectEach: w,\n        pick: T,\n        pInt: P,\n        syncTimeout: L,\n        uniqueKey: D\n      } = s;\n    class O {\n      _defaultGetter(t) {\n        let e = T(this[t + "Value"], this[t], this.element ? this.element.getAttribute(t) : null, 0);\n        return /^[\\-0-9\\.]+$/.test(e) && (e = parseFloat(e)), e;\n      }\n      _defaultSetter(t, e, i) {\n        i.setAttribute(e, t);\n      }\n      add(t) {\n        let e;\n        let i = this.renderer,\n          s = this.element;\n        return t && (this.parentGroup = t), void 0 !== this.textStr && "text" === this.element.nodeName && i.buildText(this), this.added = !0, (!t || t.handleZ || this.zIndex) && (e = this.zIndexSetter()), e || (t ? t.element : i.box).appendChild(s), this.onAdd && this.onAdd(), this;\n      }\n      addClass(t, e) {\n        let i = e ? "" : this.attr("class") || "";\n        return (t = (t || "").split(/ /g).reduce(function (t, e) {\n          return -1 === i.indexOf(e) && t.push(e), t;\n        }, i ? [i] : []).join(" ")) !== i && this.attr("class", t), this;\n      }\n      afterSetters() {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      }\n      align(t, e, i) {\n        let s, o, r, a, n;\n        let l = {},\n          h = this.renderer,\n          d = h.alignedObjects;\n        t ? (this.alignOptions = t, this.alignByTranslate = e, (!i || C(i)) && (this.alignTo = r = i || "renderer", y(d, this), d.push(this), i = void 0)) : (t = this.alignOptions, e = this.alignByTranslate, r = this.alignTo), i = T(i, h[r], "scrollablePlotBox" === r ? h.plotBox : void 0, h);\n        let c = t.align,\n          p = t.verticalAlign;\n        return s = (i.x || 0) + (t.x || 0), o = (i.y || 0) + (t.y || 0), "right" === c ? a = 1 : "center" === c && (a = 2), a && (s += (i.width - (t.width || 0)) / a), l[e ? "translateX" : "x"] = Math.round(s), "bottom" === p ? n = 1 : "middle" === p && (n = 2), n && (o += (i.height - (t.height || 0)) / n), l[e ? "translateY" : "y"] = Math.round(o), this[this.placed ? "animate" : "attr"](l), this.placed = !0, this.alignAttr = l, this;\n      }\n      alignSetter(t) {\n        let e = {\n          left: "start",\n          center: "middle",\n          right: "end"\n        };\n        e[t] && (this.alignValue = t, this.element.setAttribute("text-anchor", e[t]));\n      }\n      animate(t, e, i) {\n        let s = r(T(e, this.renderer.globalAnimation, !0)),\n          a = s.defer;\n        return l.hidden && (s.duration = 0), 0 !== s.duration ? (i && (s.complete = i), L(() => {\n          this.element && o(this, t, s);\n        }, a)) : (this.attr(t, void 0, i || s.complete), w(t, function (t, e) {\n          s.step && s.step.call(this, t, {\n            prop: e,\n            pos: 1,\n            elem: this\n          });\n        }, this)), this;\n      }\n      applyTextOutline(t) {\n        let e = this.element,\n          s = -1 !== t.indexOf("contrast");\n        s && (t = t.replace(/contrast/g, this.renderer.getContrast(e.style.fill)));\n        let o = t.split(" "),\n          r = o[o.length - 1],\n          a = o[0];\n        if (a && "none" !== a && i.svg) {\n          this.fakeTS = !0, a = a.replace(/(^[\\d\\.]+)(.*?)$/g, function (t, e, i) {\n            return 2 * Number(e) + i;\n          }), this.removeTextOutline();\n          let t = l.createElementNS(c, "tspan");\n          g(t, {\n            class: "highcharts-text-outline",\n            fill: r,\n            stroke: r,\n            "stroke-width": a,\n            "stroke-linejoin": "round"\n          });\n          let i = e.querySelector("textPath") || e;\n          [].forEach.call(i.childNodes, e => {\n            let i = e.cloneNode(!0);\n            i.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach(t => i.removeAttribute(t)), t.appendChild(i);\n          });\n          let s = 0;\n          [].forEach.call(i.querySelectorAll("text tspan"), t => {\n            s += Number(t.getAttribute("dy"));\n          });\n          let o = l.createElementNS(c, "tspan");\n          o.textContent = "‚Äã", g(o, {\n            x: Number(e.getAttribute("x")),\n            dy: -s\n          }), t.appendChild(o), i.insertBefore(t, i.firstChild);\n        }\n      }\n      attr(t, e, i, s) {\n        let o = this.element,\n          r = O.symbolCustomAttribs,\n          n,\n          l,\n          h = this,\n          d;\n        return "string" == typeof t && void 0 !== e && (n = t, (t = {})[n] = e), "string" == typeof t ? h = (this[t + "Getter"] || this._defaultGetter).call(this, t, o) : (w(t, function (e, i) {\n          d = !1, s || a(this, i), this.symbolName && -1 !== r.indexOf(i) && (l || (this.symbolAttr(t), l = !0), d = !0), this.rotation && ("x" === i || "y" === i) && (this.doTransform = !0), d || (this[i + "Setter"] || this._defaultSetter).call(this, e, i, o);\n        }, this), this.afterSetters()), i && i.call(this), h;\n      }\n      clip(t) {\n        if (t && !t.clipPath) {\n          let e = D() + "-",\n            i = this.renderer.createElement("clipPath").attr({\n              id: e\n            }).add(this.renderer.defs);\n          b(t, {\n            clipPath: i,\n            id: e,\n            count: 0\n          }), t.add(i);\n        }\n        return this.attr("clip-path", t ? `url(${this.renderer.url}#${t.id})` : "none");\n      }\n      crisp(t, e) {\n        e = e || t.strokeWidth || 0;\n        let i = Math.round(e) % 2 / 2;\n        return t.x = Math.floor(t.x || this.x || 0) + i, t.y = Math.floor(t.y || this.y || 0) + i, t.width = Math.floor((t.width || this.width || 0) - 2 * i), t.height = Math.floor((t.height || this.height || 0) - 2 * i), x(t.strokeWidth) && (t.strokeWidth = e), t;\n      }\n      complexColor(t, i, s) {\n        let o = this.renderer,\n          r,\n          a,\n          n,\n          l,\n          h,\n          d,\n          c,\n          p,\n          u,\n          g,\n          f = [],\n          m;\n        v(this.renderer, "complexColor", {\n          args: arguments\n        }, function () {\n          if (t.radialGradient ? a = "radialGradient" : t.linearGradient && (a = "linearGradient"), a) {\n            if (n = t[a], h = o.gradients, d = t.stops, u = s.radialReference, M(n) && (t[a] = n = {\n              x1: n[0],\n              y1: n[1],\n              x2: n[2],\n              y2: n[3],\n              gradientUnits: "userSpaceOnUse"\n            }), "radialGradient" === a && u && !x(n.gradientUnits) && (l = n, n = A(n, o.getRadialAttr(u, l), {\n              gradientUnits: "userSpaceOnUse"\n            })), w(n, function (t, e) {\n              "id" !== e && f.push(e, t);\n            }), w(d, function (t) {\n              f.push(t);\n            }), h[f = f.join(",")]) g = h[f].attr("id");else {\n              n.id = g = D();\n              let t = h[f] = o.createElement(a).attr(n).add(o.defs);\n              t.radAttr = l, t.stops = [], d.forEach(function (i) {\n                0 === i[1].indexOf("rgba") ? (c = (r = e.parse(i[1])).get("rgb"), p = r.get("a")) : (c = i[1], p = 1);\n                let s = o.createElement("stop").attr({\n                  offset: i[0],\n                  "stop-color": c,\n                  "stop-opacity": p\n                }).add(t);\n                t.stops.push(s);\n              });\n            }\n            m = "url(" + o.url + "#" + g + ")", s.setAttribute(i, m), s.gradient = f, t.toString = function () {\n              return m;\n            };\n          }\n        });\n      }\n      css(t) {\n        let e = this.styles,\n          i = {},\n          s = this.element,\n          o,\n          r = !e;\n        if (e && w(t, function (t, s) {\n          e && e[s] !== t && (i[s] = t, r = !0);\n        }), r) {\n          e && (t = b(e, i)), null === t.width || "auto" === t.width ? delete this.textWidth : "text" === s.nodeName.toLowerCase() && t.width && (o = this.textWidth = P(t.width)), this.styles = t, o && !d && this.renderer.forExport && delete t.width;\n          let r = A(t);\n          s.namespaceURI === this.SVG_NS && (["textOutline", "textOverflow", "width"].forEach(t => r && delete r[t]), r.color && (r.fill = r.color)), m(s, r);\n        }\n        return this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), t.textOutline && this.applyTextOutline(t.textOutline)), this;\n      }\n      dashstyleSetter(t) {\n        let e,\n          i = this["stroke-width"];\n        if ("inherit" === i && (i = 1), t = t && t.toLowerCase()) {\n          let s = t.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");\n          for (e = s.length; e--;) s[e] = "" + P(s[e]) * T(i, NaN);\n          t = s.join(",").replace(/NaN/g, "none"), this.element.setAttribute("stroke-dasharray", t);\n        }\n      }\n      destroy() {\n        let t = this,\n          e = t.element || {},\n          i = t.renderer,\n          s = e.ownerSVGElement,\n          o = "SPAN" === e.nodeName && t.parentGroup || void 0,\n          r,\n          n;\n        if (e.onclick = e.onmouseout = e.onmouseover = e.onmousemove = e.point = null, a(t), t.clipPath && s) {\n          let e = t.clipPath;\n          [].forEach.call(s.querySelectorAll("[clip-path],[CLIP-PATH]"), function (t) {\n            t.getAttribute("clip-path").indexOf(e.element.id) > -1 && t.removeAttribute("clip-path");\n          }), t.clipPath = e.destroy();\n        }\n        if (t.connector = t.connector?.destroy(), t.stops) {\n          for (n = 0; n < t.stops.length; n++) t.stops[n].destroy();\n          t.stops.length = 0, t.stops = void 0;\n        }\n        for (t.safeRemoveChild(e); o && o.div && 0 === o.div.childNodes.length;) r = o.parentGroup, t.safeRemoveChild(o.div), delete o.div, o = r;\n        t.alignTo && y(i.alignedObjects, t), w(t, function (e, i) {\n          t[i] && t[i].parentGroup === t && t[i].destroy && t[i].destroy(), delete t[i];\n        });\n      }\n      dSetter(t, e, i) {\n        M(t) && ("string" == typeof t[0] && (t = this.renderer.pathToSegments(t)), this.pathArray = t, t = t.reduce((t, e, i) => e && e.join ? (i ? t + " " : "") + e.join(" ") : (e || "").toString(), "")), /(NaN| {2}|^$)/.test(t) && (t = "M 0 0"), this[e] !== t && (i.setAttribute(e, t), this[e] = t);\n      }\n      fillSetter(t, e, i) {\n        "string" == typeof t ? i.setAttribute(e, t) : t && this.complexColor(t, e, i);\n      }\n      hrefSetter(t, e, i) {\n        i.setAttributeNS("http://www.w3.org/1999/xlink", e, t);\n      }\n      getBBox(t, e) {\n        let i, s, o, r, a;\n        let {\n            alignValue: l,\n            element: h,\n            renderer: d,\n            styles: c,\n            textStr: p\n          } = this,\n          {\n            cache: u,\n            cacheKeys: g\n          } = d,\n          f = h.namespaceURI === this.SVG_NS,\n          y = T(e, this.rotation, 0),\n          v = d.styledMode ? h && O.prototype.getStyle.call(h, "font-size") : c && c.fontSize;\n        if (x(p) && (-1 === (a = p.toString()).indexOf("<") && (a = a.replace(/[0-9]/g, "0")), a += ["", d.rootFontSize, v, y, this.textWidth, l, c && c.textOverflow, c && c.fontWeight].join(",")), a && !t && (i = u[a]), !i) {\n          if (f || d.forExport) {\n            try {\n              r = this.fakeTS && function (t) {\n                let e = h.querySelector(".highcharts-text-outline");\n                e && m(e, {\n                  display: t\n                });\n              }, S(r) && r("none"), i = h.getBBox ? b({}, h.getBBox()) : {\n                width: h.offsetWidth,\n                height: h.offsetHeight,\n                x: 0,\n                y: 0\n              }, S(r) && r("");\n            } catch (t) {}\n            (!i || i.width < 0) && (i = {\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            });\n          } else i = this.htmlGetBBox();\n          if (s = i.width, o = i.height, f && (i.height = o = {\n            "11px,17": 14,\n            "13px,20": 16\n          }[`${v || ""},${Math.round(o)}`] || o), y) {\n            let t = Number(h.getAttribute("y") || 0) - i.y,\n              e = {\n                right: 1,\n                center: .5\n              }[l || 0] || 0,\n              r = y * n,\n              a = (y - 90) * n,\n              d = s * Math.cos(r),\n              c = s * Math.sin(r),\n              p = Math.cos(a),\n              u = Math.sin(a),\n              g = i.x + e * (s - d),\n              f = i.y + t - e * c,\n              m = g + t * p,\n              x = m + d,\n              b = x - o * p,\n              v = b - d,\n              M = f + t * u,\n              S = M + c,\n              k = S - o * u,\n              C = k - c;\n            i.x = Math.min(m, x, b, v), i.y = Math.min(M, S, k, C), i.width = Math.max(m, x, b, v) - i.x, i.height = Math.max(M, S, k, C) - i.y;\n          }\n        }\n        if (a && ("" === p || i.height > 0)) {\n          for (; g.length > 250;) delete u[g.shift()];\n          u[a] || g.push(a), u[a] = i;\n        }\n        return i;\n      }\n      getStyle(t) {\n        return p.getComputedStyle(this.element || this, "").getPropertyValue(t);\n      }\n      hasClass(t) {\n        return -1 !== ("" + this.attr("class")).split(" ").indexOf(t);\n      }\n      hide() {\n        return this.attr({\n          visibility: "hidden"\n        });\n      }\n      htmlGetBBox() {\n        return {\n          height: 0,\n          width: 0,\n          x: 0,\n          y: 0\n        };\n      }\n      constructor(t, e) {\n        this.onEvents = {}, this.opacity = 1, this.SVG_NS = c, this.element = "span" === e ? f(e) : l.createElementNS(this.SVG_NS, e), this.renderer = t, v(this, "afterInit");\n      }\n      on(t, e) {\n        let {\n          onEvents: i\n        } = this;\n        return i[t] && i[t](), i[t] = u(this.element, t, e), this;\n      }\n      opacitySetter(t, e, i) {\n        let s = Number(Number(t).toFixed(3));\n        this.opacity = s, i.setAttribute(e, s);\n      }\n      removeClass(t) {\n        return this.attr("class", ("" + this.attr("class")).replace(C(t) ? RegExp(`(^| )${t}( |$)`) : t, " ").replace(/ +/g, " ").trim());\n      }\n      removeTextOutline() {\n        let t = this.element.querySelector("tspan.highcharts-text-outline");\n        t && this.safeRemoveChild(t);\n      }\n      safeRemoveChild(t) {\n        let e = t.parentNode;\n        e && e.removeChild(t);\n      }\n      setRadialReference(t) {\n        let e = this.element.gradient && this.renderer.gradients[this.element.gradient];\n        return this.element.radialReference = t, e && e.radAttr && e.animate(this.renderer.getRadialAttr(t, e.radAttr)), this;\n      }\n      setTextPath(t, e) {\n        e = A(!0, {\n          enabled: !0,\n          attributes: {\n            dy: -5,\n            startOffset: "50%",\n            textAnchor: "middle"\n          }\n        }, e);\n        let i = this.renderer.url,\n          s = this.text || this,\n          o = s.textPath,\n          {\n            attributes: r,\n            enabled: a\n          } = e;\n        if (t = t || o && o.path, o && o.undo(), t && a) {\n          let e = u(s, "afterModifyTree", e => {\n            if (t && a) {\n              let o = t.attr("id");\n              o || t.attr("id", o = D());\n              let a = {\n                x: 0,\n                y: 0\n              };\n              x(r.dx) && (a.dx = r.dx, delete r.dx), x(r.dy) && (a.dy = r.dy, delete r.dy), s.attr(a), this.attr({\n                transform: ""\n              }), this.box && (this.box = this.box.destroy());\n              let n = e.nodes.slice(0);\n              e.nodes.length = 0, e.nodes[0] = {\n                tagName: "textPath",\n                attributes: b(r, {\n                  "text-anchor": r.textAnchor,\n                  href: `${i}#${o}`\n                }),\n                children: n\n              };\n            }\n          });\n          s.textPath = {\n            path: t,\n            undo: e\n          };\n        } else s.attr({\n          dx: 0,\n          dy: 0\n        }), delete s.textPath;\n        return this.added && (s.textCache = "", this.renderer.buildText(s)), this;\n      }\n      shadow(t) {\n        let {\n            renderer: e\n          } = this,\n          i = A(this.parentGroup?.rotation === 90 ? {\n            offsetX: -1,\n            offsetY: -1\n          } : {}, k(t) ? t : {}),\n          s = e.shadowDefinition(i);\n        return this.attr({\n          filter: t ? `url(${e.url}#${s})` : "none"\n        });\n      }\n      show(t = !0) {\n        return this.attr({\n          visibility: t ? "inherit" : "visible"\n        });\n      }\n      "stroke-widthSetter"(t, e, i) {\n        this[e] = t, i.setAttribute(e, t);\n      }\n      strokeWidth() {\n        if (!this.renderer.styledMode) return this["stroke-width"] || 0;\n        let t = this.getStyle("stroke-width"),\n          e = 0,\n          i;\n        return t.indexOf("px") === t.length - 2 ? e = P(t) : "" !== t && (g(i = l.createElementNS(c, "rect"), {\n          width: t,\n          "stroke-width": 0\n        }), this.element.parentNode.appendChild(i), e = i.getBBox().width, i.parentNode.removeChild(i)), e;\n      }\n      symbolAttr(t) {\n        let e = this;\n        O.symbolCustomAttribs.forEach(function (i) {\n          e[i] = T(t[i], e[i]);\n        }), e.attr({\n          d: e.renderer.symbols[e.symbolName](e.x, e.y, e.width, e.height, e)\n        });\n      }\n      textSetter(t) {\n        t !== this.textStr && (delete this.textPxLength, this.textStr = t, this.added && this.renderer.buildText(this));\n      }\n      titleSetter(t) {\n        let e = this.element,\n          i = e.getElementsByTagName("title")[0] || l.createElementNS(this.SVG_NS, "title");\n        e.insertBefore ? e.insertBefore(i, e.firstChild) : e.appendChild(i), i.textContent = String(T(t, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");\n      }\n      toFront() {\n        let t = this.element;\n        return t.parentNode.appendChild(t), this;\n      }\n      translate(t, e) {\n        return this.attr({\n          translateX: t,\n          translateY: e\n        });\n      }\n      updateTransform(t = "transform") {\n        let {\n            element: e,\n            matrix: i,\n            rotation: s = 0,\n            scaleX: o,\n            scaleY: r,\n            translateX: a = 0,\n            translateY: n = 0\n          } = this,\n          l = ["translate(" + a + "," + n + ")"];\n        x(i) && l.push("matrix(" + i.join(",") + ")"), s && l.push("rotate(" + s + " " + T(this.rotationOriginX, e.getAttribute("x"), 0) + " " + T(this.rotationOriginY, e.getAttribute("y") || 0) + ")"), (x(o) || x(r)) && l.push("scale(" + T(o, 1) + " " + T(r, 1) + ")"), l.length && !(this.text || this).textPath && e.setAttribute(t, l.join(" "));\n      }\n      visibilitySetter(t, e, i) {\n        "inherit" === t ? i.removeAttribute(e) : this[e] !== t && i.setAttribute(e, t), this[e] = t;\n      }\n      xGetter(t) {\n        return "circle" === this.element.nodeName && ("x" === t ? t = "cx" : "y" === t && (t = "cy")), this._defaultGetter(t);\n      }\n      zIndexSetter(t, e) {\n        let i = this.renderer,\n          s = this.parentGroup,\n          o = s || i,\n          r = o.element || i.box,\n          a = this.element,\n          n = r === i.box,\n          l,\n          h,\n          d,\n          c = !1,\n          p,\n          u = this.added,\n          g;\n        if (x(t) ? (a.setAttribute("data-z-index", t), t = +t, this[e] === t && (u = !1)) : x(this[e]) && a.removeAttribute("data-z-index"), this[e] = t, u) {\n          for ((t = this.zIndex) && s && (s.handleZ = !0), g = (l = r.childNodes).length - 1; g >= 0 && !c; g--) p = !x(d = (h = l[g]).getAttribute("data-z-index")), h !== a && (t < 0 && p && !n && !g ? (r.insertBefore(a, l[g]), c = !0) : (P(d) <= t || p && (!x(t) || t >= 0)) && (r.insertBefore(a, l[g + 1]), c = !0));\n          c || (r.insertBefore(a, l[n ? 3 : 0]), c = !0);\n        }\n        return c;\n      }\n    }\n    return O.symbolCustomAttribs = ["anchorX", "anchorY", "clockwise", "end", "height", "innerR", "r", "start", "width", "x", "y"], O.prototype.strokeSetter = O.prototype.fillSetter, O.prototype.yGetter = O.prototype.xGetter, O.prototype.matrixSetter = O.prototype.rotationOriginXSetter = O.prototype.rotationOriginYSetter = O.prototype.rotationSetter = O.prototype.scaleXSetter = O.prototype.scaleYSetter = O.prototype.translateXSetter = O.prototype.translateYSetter = O.prototype.verticalAlignSetter = function (t, e) {\n      this[e] = t, this.doTransform = !0;\n    }, O;\n  }), i(e, "Core/Renderer/RendererRegistry.js", [e["Core/Globals.js"]], function (t) {\n    var e, i;\n    let s;\n    return (i = e || (e = {})).rendererTypes = {}, i.getRendererType = function (t = s) {\n      return i.rendererTypes[t] || i.rendererTypes[s];\n    }, i.registerRendererType = function (e, o, r) {\n      i.rendererTypes[e] = o, (!s || r) && (s = e, t.Renderer = o);\n    }, e;\n  }), i(e, "Core/Renderer/SVG/SVGLabel.js", [e["Core/Renderer/SVG/SVGElement.js"], e["Core/Utilities.js"]], function (t, e) {\n    let {\n      defined: i,\n      extend: s,\n      isNumber: o,\n      merge: r,\n      pick: a,\n      removeEvent: n\n    } = e;\n    class l extends t {\n      constructor(t, e, i, s, o, r, a, n, h, d) {\n        let c;\n        super(t, "g"), this.paddingLeftSetter = this.paddingSetter, this.paddingRightSetter = this.paddingSetter, this.textStr = e, this.x = i, this.y = s, this.anchorX = r, this.anchorY = a, this.baseline = h, this.className = d, this.addClass("button" === d ? "highcharts-no-tooltip" : "highcharts-label"), d && this.addClass("highcharts-" + d), this.text = t.text(void 0, 0, 0, n).attr({\n          zIndex: 1\n        }), "string" == typeof o && ((c = /^url\\((.*?)\\)$/.test(o)) || this.renderer.symbols[o]) && (this.symbolKey = o), this.bBox = l.emptyBBox, this.padding = 3, this.baselineOffset = 0, this.needsBox = t.styledMode || c, this.deferredAttr = {}, this.alignFactor = 0;\n      }\n      alignSetter(t) {\n        let e = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[t];\n        e !== this.alignFactor && (this.alignFactor = e, this.bBox && o(this.xSetting) && this.attr({\n          x: this.xSetting\n        }));\n      }\n      anchorXSetter(t, e) {\n        this.anchorX = t, this.boxAttr(e, Math.round(t) - this.getCrispAdjust() - this.xSetting);\n      }\n      anchorYSetter(t, e) {\n        this.anchorY = t, this.boxAttr(e, t - this.ySetting);\n      }\n      boxAttr(t, e) {\n        this.box ? this.box.attr(t, e) : this.deferredAttr[t] = e;\n      }\n      css(e) {\n        if (e) {\n          let t = {};\n          e = r(e), l.textProps.forEach(i => {\n            void 0 !== e[i] && (t[i] = e[i], delete e[i]);\n          }), this.text.css(t), "fontSize" in t || "fontWeight" in t ? this.updateTextPadding() : ("width" in t || "textOverflow" in t) && this.updateBoxSize();\n        }\n        return t.prototype.css.call(this, e);\n      }\n      destroy() {\n        n(this.element, "mouseenter"), n(this.element, "mouseleave"), this.text && this.text.destroy(), this.box && (this.box = this.box.destroy()), t.prototype.destroy.call(this);\n      }\n      fillSetter(t, e) {\n        t && (this.needsBox = !0), this.fill = t, this.boxAttr(e, t);\n      }\n      getBBox() {\n        this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();\n        let t = this.padding,\n          e = a(this.paddingLeft, t);\n        return {\n          width: this.width || 0,\n          height: this.height || 0,\n          x: this.bBox.x - e,\n          y: this.bBox.y - t\n        };\n      }\n      getCrispAdjust() {\n        return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;\n      }\n      heightSetter(t) {\n        this.heightSetting = t;\n      }\n      onAdd() {\n        this.text.add(this), this.attr({\n          text: a(this.textStr, ""),\n          x: this.x || 0,\n          y: this.y || 0\n        }), this.box && i(this.anchorX) && this.attr({\n          anchorX: this.anchorX,\n          anchorY: this.anchorY\n        });\n      }\n      paddingSetter(t, e) {\n        o(t) ? t !== this[e] && (this[e] = t, this.updateTextPadding()) : this[e] = void 0;\n      }\n      rSetter(t, e) {\n        this.boxAttr(e, t);\n      }\n      strokeSetter(t, e) {\n        this.stroke = t, this.boxAttr(e, t);\n      }\n      "stroke-widthSetter"(t, e) {\n        t && (this.needsBox = !0), this["stroke-width"] = t, this.boxAttr(e, t);\n      }\n      "text-alignSetter"(t) {\n        this.textAlign = t;\n      }\n      textSetter(t) {\n        void 0 !== t && this.text.attr({\n          text: t\n        }), this.updateTextPadding();\n      }\n      updateBoxSize() {\n        let t;\n        let e = this.text,\n          r = {},\n          a = this.padding,\n          n = this.bBox = (!o(this.widthSetting) || !o(this.heightSetting) || this.textAlign) && i(e.textStr) ? e.getBBox() : l.emptyBBox;\n        this.width = this.getPaddedWidth(), this.height = (this.heightSetting || n.height || 0) + 2 * a;\n        let h = this.renderer.fontMetrics(e);\n        if (this.baselineOffset = a + Math.min((this.text.firstLineMetrics || h).b, n.height || 1 / 0), this.heightSetting && (this.baselineOffset += (this.heightSetting - h.h) / 2), this.needsBox && !e.textPath) {\n          if (!this.box) {\n            let t = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();\n            t.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), t.add(this);\n          }\n          t = this.getCrispAdjust(), r.x = t, r.y = (this.baseline ? -this.baselineOffset : 0) + t, r.width = Math.round(this.width), r.height = Math.round(this.height), this.box.attr(s(r, this.deferredAttr)), this.deferredAttr = {};\n        }\n      }\n      updateTextPadding() {\n        let t = this.text;\n        if (!t.textPath) {\n          this.updateBoxSize();\n          let e = this.baseline ? 0 : this.baselineOffset,\n            s = a(this.paddingLeft, this.padding);\n          i(this.widthSetting) && this.bBox && ("center" === this.textAlign || "right" === this.textAlign) && (s += {\n            center: .5,\n            right: 1\n          }[this.textAlign] * (this.widthSetting - this.bBox.width)), (s !== t.x || e !== t.y) && (t.attr("x", s), t.hasBoxWidthChanged && (this.bBox = t.getBBox(!0)), void 0 !== e && t.attr("y", e)), t.x = s, t.y = e;\n        }\n      }\n      widthSetter(t) {\n        this.widthSetting = o(t) ? t : void 0;\n      }\n      getPaddedWidth() {\n        let t = this.padding,\n          e = a(this.paddingLeft, t),\n          i = a(this.paddingRight, t);\n        return (this.widthSetting || this.bBox.width || 0) + e + i;\n      }\n      xSetter(t) {\n        this.x = t, this.alignFactor && (t -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0), this.xSetting = Math.round(t), this.attr("translateX", this.xSetting);\n      }\n      ySetter(t) {\n        this.ySetting = this.y = Math.round(t), this.attr("translateY", this.ySetting);\n      }\n    }\n    return l.emptyBBox = {\n      width: 0,\n      height: 0,\n      x: 0,\n      y: 0\n    }, l.textProps = ["color", "direction", "fontFamily", "fontSize", "fontStyle", "fontWeight", "lineHeight", "textAlign", "textDecoration", "textOutline", "textOverflow", "whiteSpace", "width"], l;\n  }), i(e, "Core/Renderer/SVG/Symbols.js", [e["Core/Utilities.js"]], function (t) {\n    let {\n      defined: e,\n      isNumber: i,\n      pick: s\n    } = t;\n    function o(t, i, o, r, a) {\n      let n = [];\n      if (a) {\n        let l = a.start || 0,\n          h = s(a.r, o),\n          d = s(a.r, r || o),\n          c = .001 > Math.abs((a.end || 0) - l - 2 * Math.PI),\n          p = (a.end || 0) - .001,\n          u = a.innerR,\n          g = s(a.open, c),\n          f = Math.cos(l),\n          m = Math.sin(l),\n          x = Math.cos(p),\n          y = Math.sin(p),\n          b = s(a.longArc, p - l - Math.PI < .001 ? 0 : 1),\n          v = ["A", h, d, 0, b, s(a.clockwise, 1), t + h * x, i + d * y];\n        v.params = {\n          start: l,\n          end: p,\n          cx: t,\n          cy: i\n        }, n.push(["M", t + h * f, i + d * m], v), e(u) && ((v = ["A", u, u, 0, b, e(a.clockwise) ? 1 - a.clockwise : 0, t + u * f, i + u * m]).params = {\n          start: p,\n          end: l,\n          cx: t,\n          cy: i\n        }, n.push(g ? ["M", t + u * x, i + u * y] : ["L", t + u * x, i + u * y], v)), g || n.push(["Z"]);\n      }\n      return n;\n    }\n    function r(t, e, i, s, o) {\n      return o && o.r ? a(t, e, i, s, o) : [["M", t, e], ["L", t + i, e], ["L", t + i, e + s], ["L", t, e + s], ["Z"]];\n    }\n    function a(t, e, i, s, o) {\n      let r = o?.r || 0;\n      return [["M", t + r, e], ["L", t + i - r, e], ["A", r, r, 0, 0, 1, t + i, e + r], ["L", t + i, e + s - r], ["A", r, r, 0, 0, 1, t + i - r, e + s], ["L", t + r, e + s], ["A", r, r, 0, 0, 1, t, e + s - r], ["L", t, e + r], ["A", r, r, 0, 0, 1, t + r, e], ["Z"]];\n    }\n    return {\n      arc: o,\n      callout: function (t, e, s, o, r) {\n        let n = Math.min(r && r.r || 0, s, o),\n          l = n + 6,\n          h = r && r.anchorX,\n          d = r && r.anchorY || 0,\n          c = a(t, e, s, o, {\n            r: n\n          });\n        if (!i(h) || h < s && h > 0 && d < o && d > 0) return c;\n        if (t + h > s - l) {\n          if (d > e + l && d < e + o - l) c.splice(3, 1, ["L", t + s, d - 6], ["L", t + s + 6, d], ["L", t + s, d + 6], ["L", t + s, e + o - n]);else if (h < s) {\n            let i = d < e + l,\n              r = i ? e : e + o;\n            c.splice(i ? 2 : 5, 0, ["L", h, d], ["L", t + s - n, r]);\n          } else c.splice(3, 1, ["L", t + s, o / 2], ["L", h, d], ["L", t + s, o / 2], ["L", t + s, e + o - n]);\n        } else if (t + h < l) {\n          if (d > e + l && d < e + o - l) c.splice(7, 1, ["L", t, d + 6], ["L", t - 6, d], ["L", t, d - 6], ["L", t, e + n]);else if (h > 0) {\n            let i = d < e + l,\n              s = i ? e : e + o;\n            c.splice(i ? 1 : 6, 0, ["L", h, d], ["L", t + n, s]);\n          } else c.splice(7, 1, ["L", t, o / 2], ["L", h, d], ["L", t, o / 2], ["L", t, e + n]);\n        } else d > o && h < s - l ? c.splice(5, 1, ["L", h + 6, e + o], ["L", h, e + o + 6], ["L", h - 6, e + o], ["L", t + n, e + o]) : d < 0 && h > l && c.splice(1, 1, ["L", h - 6, e], ["L", h, e - 6], ["L", h + 6, e], ["L", s - n, e]);\n        return c;\n      },\n      circle: function (t, e, i, s) {\n        return o(t + i / 2, e + s / 2, i / 2, s / 2, {\n          start: .5 * Math.PI,\n          end: 2.5 * Math.PI,\n          open: !1\n        });\n      },\n      diamond: function (t, e, i, s) {\n        return [["M", t + i / 2, e], ["L", t + i, e + s / 2], ["L", t + i / 2, e + s], ["L", t, e + s / 2], ["Z"]];\n      },\n      rect: r,\n      roundedRect: a,\n      square: r,\n      triangle: function (t, e, i, s) {\n        return [["M", t + i / 2, e], ["L", t + i, e + s], ["L", t, e + s], ["Z"]];\n      },\n      "triangle-down": function (t, e, i, s) {\n        return [["M", t, e], ["L", t + i, e], ["L", t + i / 2, e + s], ["Z"]];\n      }\n    };\n  }), i(e, "Core/Renderer/SVG/TextBuilder.js", [e["Core/Renderer/HTML/AST.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e, i) {\n    let {\n        doc: s,\n        SVG_NS: o,\n        win: r\n      } = e,\n      {\n        attr: a,\n        extend: n,\n        fireEvent: l,\n        isString: h,\n        objectEach: d,\n        pick: c\n      } = i;\n    return class {\n      constructor(t) {\n        let e = t.styles;\n        this.renderer = t.renderer, this.svgElement = t, this.width = t.textWidth, this.textLineHeight = e && e.lineHeight, this.textOutline = e && e.textOutline, this.ellipsis = !!(e && "ellipsis" === e.textOverflow), this.noWrap = !!(e && "nowrap" === e.whiteSpace);\n      }\n      buildSVG() {\n        let e = this.svgElement,\n          i = e.element,\n          o = e.renderer,\n          r = c(e.textStr, "").toString(),\n          a = -1 !== r.indexOf("<"),\n          n = i.childNodes,\n          l = !e.added && o.box,\n          d = [r, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, e.getStyle("font-size"), this.width].join(",");\n        if (d !== e.textCache) {\n          e.textCache = d, delete e.actualWidth;\n          for (let t = n.length; t--;) i.removeChild(n[t]);\n          if (a || this.ellipsis || this.width || e.textPath || -1 !== r.indexOf(" ") && (!this.noWrap || /<br.*?>/g.test(r))) {\n            if ("" !== r) {\n              l && l.appendChild(i);\n              let s = new t(r);\n              this.modifyTree(s.nodes), s.addToDOM(i), this.modifyDOM(), this.ellipsis && -1 !== (i.textContent || "").indexOf("‚Ä¶") && e.attr("title", this.unescapeEntities(e.textStr || "", ["&lt;", "&gt;"])), l && l.removeChild(i);\n            }\n          } else i.appendChild(s.createTextNode(this.unescapeEntities(r)));\n          h(this.textOutline) && e.applyTextOutline && e.applyTextOutline(this.textOutline);\n        }\n      }\n      modifyDOM() {\n        let t;\n        let e = this.svgElement,\n          i = a(e.element, "x");\n        for (e.firstLineMetrics = void 0; t = e.element.firstChild;) if (/^[\\s\\u200B]*$/.test(t.textContent || " ")) e.element.removeChild(t);else break;\n        [].forEach.call(e.element.querySelectorAll("tspan.highcharts-br"), (t, s) => {\n          t.nextSibling && t.previousSibling && (0 === s && 1 === t.previousSibling.nodeType && (e.firstLineMetrics = e.renderer.fontMetrics(t.previousSibling)), a(t, {\n            dy: this.getLineHeight(t.nextSibling),\n            x: i\n          }));\n        });\n        let n = this.width || 0;\n        if (!n) return;\n        let l = (t, r) => {\n            let l = t.textContent || "",\n              h = l.replace(/([^\\^])-/g, "$1- ").split(" "),\n              d = !this.noWrap && (h.length > 1 || e.element.childNodes.length > 1),\n              c = this.getLineHeight(r),\n              p = 0,\n              u = e.actualWidth;\n            if (this.ellipsis) l && this.truncate(t, l, void 0, 0, Math.max(0, n - .8 * c), (t, e) => t.substring(0, e) + "‚Ä¶");else if (d) {\n              let l = [],\n                d = [];\n              for (; r.firstChild && r.firstChild !== t;) d.push(r.firstChild), r.removeChild(r.firstChild);\n              for (; h.length;) h.length && !this.noWrap && p > 0 && (l.push(t.textContent || ""), t.textContent = h.join(" ").replace(/- /g, "-")), this.truncate(t, void 0, h, 0 === p && u || 0, n, (t, e) => h.slice(0, e).join(" ").replace(/- /g, "-")), u = e.actualWidth, p++;\n              d.forEach(e => {\n                r.insertBefore(e, t);\n              }), l.forEach(e => {\n                r.insertBefore(s.createTextNode(e), t);\n                let n = s.createElementNS(o, "tspan");\n                n.textContent = "‚Äã", a(n, {\n                  dy: c,\n                  x: i\n                }), r.insertBefore(n, t);\n              });\n            }\n          },\n          h = t => {\n            let i = [].slice.call(t.childNodes);\n            i.forEach(i => {\n              i.nodeType === r.Node.TEXT_NODE ? l(i, t) : (-1 !== i.className.baseVal.indexOf("highcharts-br") && (e.actualWidth = 0), h(i));\n            });\n          };\n        h(e.element);\n      }\n      getLineHeight(t) {\n        let e = t.nodeType === r.Node.TEXT_NODE ? t.parentElement : t;\n        return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(e || this.svgElement.element).h;\n      }\n      modifyTree(t) {\n        let e = (i, s) => {\n          let {\n              attributes: o = {},\n              children: r,\n              style: a = {},\n              tagName: l\n            } = i,\n            h = this.renderer.styledMode;\n          if ("b" === l || "strong" === l ? h ? o.class = "highcharts-strong" : a.fontWeight = "bold" : ("i" === l || "em" === l) && (h ? o.class = "highcharts-emphasized" : a.fontStyle = "italic"), a && a.color && (a.fill = a.color), "br" === l) {\n            o.class = "highcharts-br", i.textContent = "‚Äã";\n            let e = t[s + 1];\n            e && e.textContent && (e.textContent = e.textContent.replace(/^ +/gm, ""));\n          } else "a" === l && r && r.some(t => "#text" === t.tagName) && (i.children = [{\n            children: r,\n            tagName: "tspan"\n          }]);\n          "#text" !== l && "a" !== l && (i.tagName = "tspan"), n(i, {\n            attributes: o,\n            style: a\n          }), r && r.filter(t => "#text" !== t.tagName).forEach(e);\n        };\n        t.forEach(e), l(this.svgElement, "afterModifyTree", {\n          nodes: t\n        });\n      }\n      truncate(t, e, i, s, o, r) {\n        let a, n;\n        let l = this.svgElement,\n          {\n            renderer: h,\n            rotation: d\n          } = l,\n          c = [],\n          p = i ? 1 : 0,\n          u = (e || i || "").length,\n          g = u,\n          f = function (e, o) {\n            let r = o || e,\n              a = t.parentNode;\n            if (a && void 0 === c[r] && a.getSubStringLength) try {\n              c[r] = s + a.getSubStringLength(0, i ? r + 1 : r);\n            } catch (t) {}\n            return c[r];\n          };\n        if (l.rotation = 0, s + (n = f(t.textContent.length)) > o) {\n          for (; p <= u;) g = Math.ceil((p + u) / 2), i && (a = r(i, g)), n = f(g, a && a.length - 1), p === u ? p = u + 1 : n > o ? u = g - 1 : p = g;\n          0 === u ? t.textContent = "" : e && u === e.length - 1 || (t.textContent = a || r(e || i, g));\n        }\n        i && i.splice(0, g), l.actualWidth = n, l.rotation = d;\n      }\n      unescapeEntities(t, e) {\n        return d(this.renderer.escapes, function (i, s) {\n          e && -1 !== e.indexOf(i) || (t = t.toString().replace(RegExp(i, "g"), s));\n        }), t;\n      }\n    };\n  }), i(e, "Core/Renderer/SVG/SVGRenderer.js", [e["Core/Renderer/HTML/AST.js"], e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Renderer/SVG/SVGLabel.js"], e["Core/Renderer/SVG/Symbols.js"], e["Core/Renderer/SVG/TextBuilder.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, r, a, n, l) {\n    let h;\n    let {\n        charts: d,\n        deg2rad: c,\n        doc: p,\n        isFirefox: u,\n        isMS: g,\n        isWebKit: f,\n        noop: m,\n        SVG_NS: x,\n        symbolSizes: y,\n        win: b\n      } = i,\n      {\n        addEvent: v,\n        attr: M,\n        createElement: S,\n        css: k,\n        defined: C,\n        destroyObjectProperties: A,\n        extend: w,\n        isArray: T,\n        isNumber: P,\n        isObject: L,\n        isString: D,\n        merge: O,\n        pick: E,\n        pInt: B,\n        uniqueKey: j\n      } = l;\n    class I {\n      constructor(t, e, i, s, o, r, a) {\n        let n, l;\n        let h = this.createElement("svg").attr({\n            version: "1.1",\n            class: "highcharts-root"\n          }),\n          d = h.element;\n        a || h.css(this.getStyle(s || {})), t.appendChild(d), M(t, "dir", "ltr"), -1 === t.innerHTML.indexOf("xmlns") && M(d, "xmlns", this.SVG_NS), this.box = d, this.boxWrapper = h, this.alignedObjects = [], this.url = this.getReferenceURL();\n        let c = this.createElement("desc").add();\n        c.element.appendChild(p.createTextNode("Created with Highcharts 11.3.0")), this.defs = this.createElement("defs").add(), this.allowHTML = r, this.forExport = o, this.styledMode = a, this.gradients = {}, this.cache = {}, this.cacheKeys = [], this.imgCount = 0, this.rootFontSize = h.getStyle("font-size"), this.setSize(e, i, !1), u && t.getBoundingClientRect && ((n = function () {\n          k(t, {\n            left: 0,\n            top: 0\n          }), l = t.getBoundingClientRect(), k(t, {\n            left: Math.ceil(l.left) - l.left + "px",\n            top: Math.ceil(l.top) - l.top + "px"\n          });\n        })(), this.unSubPixelFix = v(b, "resize", n));\n      }\n      definition(e) {\n        let i = new t([e]);\n        return i.addToDOM(this.defs.element);\n      }\n      getReferenceURL() {\n        if ((u || f) && p.getElementsByTagName("base").length) {\n          if (!C(h)) {\n            let e = j(),\n              i = new t([{\n                tagName: "svg",\n                attributes: {\n                  width: 8,\n                  height: 8\n                },\n                children: [{\n                  tagName: "defs",\n                  children: [{\n                    tagName: "clipPath",\n                    attributes: {\n                      id: e\n                    },\n                    children: [{\n                      tagName: "rect",\n                      attributes: {\n                        width: 4,\n                        height: 4\n                      }\n                    }]\n                  }]\n                }, {\n                  tagName: "rect",\n                  attributes: {\n                    id: "hitme",\n                    width: 8,\n                    height: 8,\n                    "clip-path": `url(#${e})`,\n                    fill: "rgba(0,0,0,0.001)"\n                  }\n                }]\n              }]),\n              s = i.addToDOM(p.body);\n            k(s, {\n              position: "fixed",\n              top: 0,\n              left: 0,\n              zIndex: 9e5\n            });\n            let o = p.elementFromPoint(6, 6);\n            h = "hitme" === (o && o.id), p.body.removeChild(s);\n          }\n          if (h) return b.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\\(\'\\)])/g, "\\\\$1").replace(/ /g, "%20");\n        }\n        return "";\n      }\n      getStyle(t) {\n        return this.style = w({\n          fontFamily: "Helvetica, Arial, sans-serif",\n          fontSize: "1rem"\n        }, t), this.style;\n      }\n      setStyle(t) {\n        this.boxWrapper.css(this.getStyle(t));\n      }\n      isHidden() {\n        return !this.boxWrapper.getBBox().width;\n      }\n      destroy() {\n        let t = this.defs;\n        return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), A(this.gradients || {}), this.gradients = null, this.defs = t.destroy(), this.unSubPixelFix && this.unSubPixelFix(), this.alignedObjects = null, null;\n      }\n      createElement(t) {\n        return new this.Element(this, t);\n      }\n      getRadialAttr(t, e) {\n        return {\n          cx: t[0] - t[2] / 2 + (e.cx || 0) * t[2],\n          cy: t[1] - t[2] / 2 + (e.cy || 0) * t[2],\n          r: (e.r || 0) * t[2]\n        };\n      }\n      shadowDefinition(t) {\n        let e = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(t).map(e => `${e}-${t[e]}`)].join("-").toLowerCase().replace(/[^a-z0-9\\-]/g, ""),\n          i = O({\n            color: "#000000",\n            offsetX: 1,\n            offsetY: 1,\n            opacity: .15,\n            width: 5\n          }, t);\n        return this.defs.element.querySelector(`#${e}`) || this.definition({\n          tagName: "filter",\n          attributes: {\n            id: e,\n            filterUnits: i.filterUnits\n          },\n          children: [{\n            tagName: "feDropShadow",\n            attributes: {\n              dx: i.offsetX,\n              dy: i.offsetY,\n              "flood-color": i.color,\n              "flood-opacity": Math.min(5 * i.opacity, 1),\n              stdDeviation: i.width / 2\n            }\n          }]\n        }), e;\n      }\n      buildText(t) {\n        new n(t).buildSVG();\n      }\n      getContrast(t) {\n        let i = e.parse(t).rgba.map(t => {\n            let e = t / 255;\n            return e <= .03928 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4);\n          }),\n          s = .2126 * i[0] + .7152 * i[1] + .0722 * i[2];\n        return 1.05 / (s + .05) > (s + .05) / .05 ? "#FFFFFF" : "#000000";\n      }\n      button(e, i, s, o, r = {}, a, n, l, h, d) {\n        let c, p, u;\n        let f = this.label(e, i, s, h, void 0, void 0, d, void 0, "button"),\n          m = this.styledMode,\n          x = r.states || {},\n          y = 0;\n        r = O(r), delete r.states;\n        let b = O({\n          color: "#333333",\n          cursor: "pointer",\n          fontSize: "0.8em",\n          fontWeight: "normal"\n        }, r.style);\n        delete r.style;\n        let M = t.filterUserAttributes(r);\n        return f.attr(O({\n          padding: 8,\n          r: 2\n        }, M)), m || (M = O({\n          fill: "#f7f7f7",\n          stroke: "#cccccc",\n          "stroke-width": 1\n        }, M), c = (a = O(M, {\n          fill: "#e6e6e6"\n        }, t.filterUserAttributes(a || x.hover || {}))).style, delete a.style, p = (n = O(M, {\n          fill: "#e6e9ff",\n          style: {\n            color: "#000000",\n            fontWeight: "bold"\n          }\n        }, t.filterUserAttributes(n || x.select || {}))).style, delete n.style, u = (l = O(M, {\n          style: {\n            color: "#cccccc"\n          }\n        }, t.filterUserAttributes(l || x.disabled || {}))).style, delete l.style), v(f.element, g ? "mouseover" : "mouseenter", function () {\n          3 !== y && f.setState(1);\n        }), v(f.element, g ? "mouseout" : "mouseleave", function () {\n          3 !== y && f.setState(y);\n        }), f.setState = function (t) {\n          if (1 !== t && (f.state = y = t), f.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][t || 0]), !m) {\n            f.attr([M, a, n, l][t || 0]);\n            let e = [b, c, p, u][t || 0];\n            L(e) && f.css(e);\n          }\n        }, !m && (f.attr(M).css(w({\n          cursor: "default"\n        }, b)), d && f.text.css({\n          pointerEvents: "none"\n        })), f.on("touchstart", t => t.stopPropagation()).on("click", function (t) {\n          3 !== y && o.call(f, t);\n        });\n      }\n      crispLine(t, e, i = "round") {\n        let s = t[0],\n          o = t[1];\n        return C(s[1]) && s[1] === o[1] && (s[1] = o[1] = Math[i](s[1]) - e % 2 / 2), C(s[2]) && s[2] === o[2] && (s[2] = o[2] = Math[i](s[2]) + e % 2 / 2), t;\n      }\n      path(t) {\n        let e = this.styledMode ? {} : {\n          fill: "none"\n        };\n        return T(t) ? e.d = t : L(t) && w(e, t), this.createElement("path").attr(e);\n      }\n      circle(t, e, i) {\n        let s = L(t) ? t : void 0 === t ? {} : {\n            x: t,\n            y: e,\n            r: i\n          },\n          o = this.createElement("circle");\n        return o.xSetter = o.ySetter = function (t, e, i) {\n          i.setAttribute("c" + e, t);\n        }, o.attr(s);\n      }\n      arc(t, e, i, s, o, r) {\n        let a;\n        L(t) ? (e = (a = t).y, i = a.r, s = a.innerR, o = a.start, r = a.end, t = a.x) : a = {\n          innerR: s,\n          start: o,\n          end: r\n        };\n        let n = this.symbol("arc", t, e, i, i, a);\n        return n.r = i, n;\n      }\n      rect(t, e, i, s, o, r) {\n        let a = L(t) ? t : void 0 === t ? {} : {\n            x: t,\n            y: e,\n            r: o,\n            width: Math.max(i || 0, 0),\n            height: Math.max(s || 0, 0)\n          },\n          n = this.createElement("rect");\n        return this.styledMode || (void 0 !== r && (a["stroke-width"] = r, w(a, n.crisp(a))), a.fill = "none"), n.rSetter = function (t, e, i) {\n          n.r = t, M(i, {\n            rx: t,\n            ry: t\n          });\n        }, n.rGetter = function () {\n          return n.r || 0;\n        }, n.attr(a);\n      }\n      roundedRect(t) {\n        return this.symbol("roundedRect").attr(t);\n      }\n      setSize(t, e, i) {\n        this.width = t, this.height = e, this.boxWrapper.animate({\n          width: t,\n          height: e\n        }, {\n          step: function () {\n            this.attr({\n              viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")\n            });\n          },\n          duration: E(i, !0) ? void 0 : 0\n        }), this.alignElements();\n      }\n      g(t) {\n        let e = this.createElement("g");\n        return t ? e.attr({\n          class: "highcharts-" + t\n        }) : e;\n      }\n      image(t, e, i, s, o, r) {\n        let a = {\n          preserveAspectRatio: "none"\n        };\n        P(e) && (a.x = e), P(i) && (a.y = i), P(s) && (a.width = s), P(o) && (a.height = o);\n        let n = this.createElement("image").attr(a),\n          l = function (e) {\n            n.attr({\n              href: t\n            }), r.call(n, e);\n          };\n        if (r) {\n          n.attr({\n            href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="\n          });\n          let e = new b.Image();\n          v(e, "load", l), e.src = t, e.complete && l({});\n        } else n.attr({\n          href: t\n        });\n        return n;\n      }\n      symbol(t, e, i, s, o, r) {\n        let a, n, l, h;\n        let c = this,\n          u = /^url\\((.*?)\\)$/,\n          g = u.test(t),\n          f = !g && (this.symbols[t] ? t : "circle"),\n          m = f && this.symbols[f];\n        if (m) "number" == typeof e && (n = m.call(this.symbols, Math.round(e || 0), Math.round(i || 0), s || 0, o || 0, r)), a = this.path(n), c.styledMode || a.attr("fill", "none"), w(a, {\n          symbolName: f || void 0,\n          x: e,\n          y: i,\n          width: s,\n          height: o\n        }), r && w(a, r);else if (g) {\n          l = t.match(u)[1];\n          let s = a = this.image(l);\n          s.imgwidth = E(r && r.width, y[l] && y[l].width), s.imgheight = E(r && r.height, y[l] && y[l].height), h = t => t.attr({\n            width: t.width,\n            height: t.height\n          }), ["width", "height"].forEach(t => {\n            s[`${t}Setter`] = function (t, e) {\n              this[e] = t;\n              let {\n                  alignByTranslate: i,\n                  element: s,\n                  width: o,\n                  height: a,\n                  imgwidth: n,\n                  imgheight: l\n                } = this,\n                h = "width" === e ? n : l,\n                d = 1;\n              r && "within" === r.backgroundSize && o && a && n && l ? (d = Math.min(o / n, a / l), M(s, {\n                width: Math.round(n * d),\n                height: Math.round(l * d)\n              })) : s && h && s.setAttribute(e, h), !i && n && l && this.translate(((o || 0) - n * d) / 2, ((a || 0) - l * d) / 2);\n            };\n          }), C(e) && s.attr({\n            x: e,\n            y: i\n          }), s.isImg = !0, C(s.imgwidth) && C(s.imgheight) ? h(s) : (s.attr({\n            width: 0,\n            height: 0\n          }), S("img", {\n            onload: function () {\n              let t = d[c.chartIndex];\n              0 === this.width && (k(this, {\n                position: "absolute",\n                top: "-999em"\n              }), p.body.appendChild(this)), y[l] = {\n                width: this.width,\n                height: this.height\n              }, s.imgwidth = this.width, s.imgheight = this.height, s.element && h(s), this.parentNode && this.parentNode.removeChild(this), c.imgCount--, c.imgCount || !t || t.hasLoaded || t.onload();\n            },\n            src: l\n          }), this.imgCount++);\n        }\n        return a;\n      }\n      clipRect(t, e, i, s) {\n        return this.rect(t, e, i, s, 0);\n      }\n      text(t, e, i, s) {\n        let o = {};\n        if (s && (this.allowHTML || !this.forExport)) return this.html(t, e, i);\n        o.x = Math.round(e || 0), i && (o.y = Math.round(i)), C(t) && (o.text = t);\n        let r = this.createElement("text").attr(o);\n        return s && (!this.forExport || this.allowHTML) || (r.xSetter = function (t, e, i) {\n          let s = i.getElementsByTagName("tspan"),\n            o = i.getAttribute(e);\n          for (let i = 0, r; i < s.length; i++) (r = s[i]).getAttribute(e) === o && r.setAttribute(e, t);\n          i.setAttribute(e, t);\n        }), r;\n      }\n      fontMetrics(t) {\n        let e = B(o.prototype.getStyle.call(t, "font-size") || 0),\n          i = e < 24 ? e + 3 : Math.round(1.2 * e),\n          s = Math.round(.8 * i);\n        return {\n          h: i,\n          b: s,\n          f: e\n        };\n      }\n      rotCorr(t, e, i) {\n        let s = t;\n        return e && i && (s = Math.max(s * Math.cos(e * c), 4)), {\n          x: -t / 3 * Math.sin(e * c),\n          y: s\n        };\n      }\n      pathToSegments(t) {\n        let e = [],\n          i = [],\n          s = {\n            A: 8,\n            C: 7,\n            H: 2,\n            L: 3,\n            M: 3,\n            Q: 5,\n            S: 5,\n            T: 3,\n            V: 2\n          };\n        for (let o = 0; o < t.length; o++) D(i[0]) && P(t[o]) && i.length === s[i[0].toUpperCase()] && t.splice(o, 0, i[0].replace("M", "L").replace("m", "l")), "string" == typeof t[o] && (i.length && e.push(i.slice(0)), i.length = 0), i.push(t[o]);\n        return e.push(i.slice(0)), e;\n      }\n      label(t, e, i, s, o, a, n, l, h) {\n        return new r(this, t, e, i, s, o, a, n, l, h);\n      }\n      alignElements() {\n        this.alignedObjects.forEach(t => t.align());\n      }\n    }\n    return w(I.prototype, {\n      Element: o,\n      SVG_NS: x,\n      escapes: {\n        "&": "&amp;",\n        "<": "&lt;",\n        ">": "&gt;",\n        "\'": "&#39;",\n        \'"\': "&quot;"\n      },\n      symbols: a,\n      draw: m\n    }), s.registerRendererType("svg", I, !0), I;\n  }), i(e, "Core/Renderer/HTML/HTMLElement.js", [e["Core/Globals.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Utilities.js"]], function (t, e, i) {\n    let {\n        composed: s\n      } = t,\n      {\n        css: o,\n        defined: r,\n        extend: a,\n        pushUnique: n,\n        pInt: l\n      } = i;\n    class h extends e {\n      static compose(t) {\n        if (n(s, this.compose)) {\n          let e = h.prototype,\n            i = t.prototype;\n          i.getSpanCorrection = e.getSpanCorrection, i.htmlCss = e.htmlCss, i.htmlGetBBox = e.htmlGetBBox, i.htmlUpdateTransform = e.htmlUpdateTransform, i.setSpanRotation = e.setSpanRotation;\n        }\n        return t;\n      }\n      getSpanCorrection(t, e, i) {\n        this.xCorr = -t * i, this.yCorr = -e;\n      }\n      htmlCss(t) {\n        let e;\n        let {\n            element: i\n          } = this,\n          s = "SPAN" === i.tagName && t && "width" in t,\n          r = s && t.width;\n        return s && (delete t.width, this.textWidth = l(r) || void 0, e = !0), t?.textOverflow === "ellipsis" && (t.whiteSpace = "nowrap", t.overflow = "hidden"), a(this.styles, t), o(i, t), e && this.htmlUpdateTransform(), this;\n      }\n      htmlGetBBox() {\n        let {\n          element: t\n        } = this;\n        return {\n          x: t.offsetLeft,\n          y: t.offsetTop,\n          width: t.offsetWidth,\n          height: t.offsetHeight\n        };\n      }\n      htmlUpdateTransform() {\n        if (!this.added) {\n          this.alignOnAdd = !0;\n          return;\n        }\n        let {\n            element: t,\n            renderer: e,\n            rotation: i,\n            styles: s,\n            textAlign: a = "left",\n            textWidth: n,\n            translateX: l = 0,\n            translateY: h = 0,\n            x: d = 0,\n            y: c = 0\n          } = this,\n          p = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[a],\n          u = s?.whiteSpace;\n        if (o(t, {\n          marginLeft: `${l}px`,\n          marginTop: `${h}px`\n        }), "SPAN" === t.tagName) {\n          let s = [i, a, t.innerHTML, n, this.textAlign].join(","),\n            l,\n            h = !1;\n          if (n !== this.oldTextWidth) {\n            let e = this.textPxLength ? this.textPxLength : (o(t, {\n                width: "",\n                whiteSpace: u || "nowrap"\n              }), t.offsetWidth),\n              s = n || 0;\n            (s > this.oldTextWidth || e > s) && (/[ \\-]/.test(t.textContent || t.innerText) || "ellipsis" === t.style.textOverflow) && (o(t, {\n              width: e > s || i ? n + "px" : "auto",\n              display: "block",\n              whiteSpace: u || "normal"\n            }), this.oldTextWidth = n, h = !0);\n          }\n          this.hasBoxWidthChanged = h, s !== this.cTT && (l = e.fontMetrics(t).b, r(i) && (i !== (this.oldRotation || 0) || a !== this.oldAlign) && this.setSpanRotation(i, p, l), this.getSpanCorrection(!r(i) && this.textPxLength || t.offsetWidth, l, p)), o(t, {\n            left: d + (this.xCorr || 0) + "px",\n            top: c + (this.yCorr || 0) + "px"\n          }), this.cTT = s, this.oldRotation = i, this.oldAlign = a;\n        }\n      }\n      setSpanRotation(t, e, i) {\n        o(this.element, {\n          transform: `rotate(${t}deg)`,\n          transformOrigin: `${100 * e}% ${i}px`\n        });\n      }\n    }\n    return h;\n  }), i(e, "Core/Renderer/HTML/HTMLRenderer.js", [e["Core/Renderer/HTML/AST.js"], e["Core/Globals.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Renderer/SVG/SVGRenderer.js"], e["Core/Utilities.js"]], function (t, e, i, s, o) {\n    let {\n        composed: r\n      } = e,\n      {\n        attr: a,\n        createElement: n,\n        extend: l,\n        pick: h,\n        pushUnique: d\n      } = o;\n    class c extends s {\n      static compose(t) {\n        if (d(r, this.compose)) {\n          let e = c.prototype,\n            i = t.prototype;\n          i.html = e.html;\n        }\n        return t;\n      }\n      html(e, s, o) {\n        let r = this.createElement("span"),\n          d = r.element,\n          c = r.renderer,\n          p = function (t, e) {\n            ["opacity", "visibility"].forEach(function (s) {\n              t[s + "Setter"] = function (o, r, a) {\n                let n = t.div ? t.div.style : e;\n                i.prototype[s + "Setter"].call(this, o, r, a), n && (n[r] = o);\n              };\n            }), t.addedSetters = !0;\n          };\n        return r.textSetter = function (e) {\n          e !== this.textStr && (delete this.bBox, delete this.oldTextWidth, t.setElementHTML(this.element, h(e, "")), this.textStr = e, r.doTransform = !0);\n        }, p(r, r.element.style), r.xSetter = r.ySetter = r.alignSetter = r.rotationSetter = function (t, e) {\n          "align" === e ? r.alignValue = r.textAlign = t : r[e] = t, r.doTransform = !0;\n        }, r.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        }, r.attr({\n          text: e,\n          x: Math.round(s),\n          y: Math.round(o)\n        }).css({\n          position: "absolute"\n        }), c.styledMode || r.css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize\n        }), d.style.whiteSpace = "nowrap", r.css = r.htmlCss, r.add = function (t) {\n          let e, i;\n          let s = c.box.parentNode,\n            o = [];\n          if (this.parentGroup = t, t) {\n            if (!(e = t.div)) {\n              for (i = t; i;) o.push(i), i = i.parentGroup;\n              o.reverse().forEach(function (t) {\n                var i;\n                let h = a(t.element, "class"),\n                  d = t.css;\n                function c(e, i) {\n                  t[i] = e, "translateX" === i ? g.left = e + "px" : g.top = e + "px", t.doTransform = !0;\n                }\n                let u = t.styles || {};\n                e = t.div = t.div || n("div", h ? {\n                  className: h\n                } : void 0, {\n                  position: "absolute",\n                  left: (t.translateX || 0) + "px",\n                  top: (t.translateY || 0) + "px",\n                  display: t.display,\n                  opacity: t.opacity,\n                  visibility: t.visibility\n                }, e || s);\n                let g = e.style;\n                l(t, {\n                  classSetter: (i = e, function (t) {\n                    this.element.setAttribute("class", t), i.className = t;\n                  }),\n                  css: function (e) {\n                    return d.call(t, e), ["cursor", "pointerEvents"].forEach(t => {\n                      e[t] && (g[t] = e[t]);\n                    }), t;\n                  },\n                  on: function () {\n                    return o[0].div && r.on.apply({\n                      element: o[0].div,\n                      onEvents: t.onEvents\n                    }, arguments), t;\n                  },\n                  translateXSetter: c,\n                  translateYSetter: c\n                }), t.addedSetters || p(t), t.css(u);\n              });\n            }\n          } else e = s;\n          return e.appendChild(d), r.added = !0, r.alignOnAdd && r.htmlUpdateTransform(), r;\n        }, r;\n      }\n    }\n    return c;\n  }), i(e, "Core/Axis/AxisDefaults.js", [], function () {\n    var t, e;\n    return (e = t || (t = {})).xAxis = {\n      alignTicks: !0,\n      allowDecimals: void 0,\n      panningEnabled: !0,\n      zIndex: 2,\n      zoomEnabled: !0,\n      dateTimeLabelFormats: {\n        millisecond: {\n          main: "%H:%M:%S.%L",\n          range: !1\n        },\n        second: {\n          main: "%H:%M:%S",\n          range: !1\n        },\n        minute: {\n          main: "%H:%M",\n          range: !1\n        },\n        hour: {\n          main: "%H:%M",\n          range: !1\n        },\n        day: {\n          main: "%e %b"\n        },\n        week: {\n          main: "%e %b"\n        },\n        month: {\n          main: "%b \'%y"\n        },\n        year: {\n          main: "%Y"\n        }\n      },\n      endOnTick: !1,\n      gridLineDashStyle: "Solid",\n      gridZIndex: 1,\n      labels: {\n        autoRotationLimit: 80,\n        distance: 15,\n        enabled: !0,\n        indentation: 10,\n        overflow: "justify",\n        padding: 5,\n        reserveSpace: void 0,\n        rotation: void 0,\n        staggerLines: 0,\n        step: 0,\n        useHTML: !1,\n        zIndex: 7,\n        style: {\n          color: "#333333",\n          cursor: "default",\n          fontSize: "0.8em"\n        }\n      },\n      maxPadding: .01,\n      minorGridLineDashStyle: "Solid",\n      minorTickLength: 2,\n      minorTickPosition: "outside",\n      minorTicksPerMajor: 5,\n      minPadding: .01,\n      offset: void 0,\n      reversed: void 0,\n      reversedStacks: !1,\n      showEmpty: !0,\n      showFirstLabel: !0,\n      showLastLabel: !0,\n      startOfWeek: 1,\n      startOnTick: !1,\n      tickLength: 10,\n      tickPixelInterval: 100,\n      tickmarkPlacement: "between",\n      tickPosition: "outside",\n      title: {\n        align: "middle",\n        useHTML: !1,\n        x: 0,\n        y: 0,\n        style: {\n          color: "#666666",\n          fontSize: "0.8em"\n        }\n      },\n      type: "linear",\n      uniqueNames: !0,\n      visible: !0,\n      minorGridLineColor: "#f2f2f2",\n      minorGridLineWidth: 1,\n      minorTickColor: "#999999",\n      lineColor: "#333333",\n      lineWidth: 1,\n      gridLineColor: "#e6e6e6",\n      gridLineWidth: void 0,\n      tickColor: "#333333"\n    }, e.yAxis = {\n      reversedStacks: !0,\n      endOnTick: !0,\n      maxPadding: .05,\n      minPadding: .05,\n      tickPixelInterval: 72,\n      showLastLabel: !0,\n      labels: {\n        x: void 0\n      },\n      startOnTick: !0,\n      title: {\n        text: "Values"\n      },\n      stackLabels: {\n        animation: {},\n        allowOverlap: !1,\n        enabled: !1,\n        crop: !0,\n        overflow: "justify",\n        formatter: function () {\n          let {\n            numberFormatter: t\n          } = this.axis.chart;\n          return t(this.total || 0, -1);\n        },\n        style: {\n          color: "#000000",\n          fontSize: "0.7em",\n          fontWeight: "bold",\n          textOutline: "1px contrast"\n        }\n      },\n      gridLineWidth: 1,\n      lineWidth: 0\n    }, t;\n  }), i(e, "Core/Foundation.js", [e["Core/Utilities.js"]], function (t) {\n    var e;\n    let {\n      addEvent: i,\n      isFunction: s,\n      objectEach: o,\n      removeEvent: r\n    } = t;\n    return (e || (e = {})).registerEventOptions = function (t, e) {\n      t.eventOptions = t.eventOptions || {}, o(e.events, function (e, o) {\n        t.eventOptions[o] !== e && (t.eventOptions[o] && (r(t, o, t.eventOptions[o]), delete t.eventOptions[o]), s(e) && (t.eventOptions[o] = e, i(t, o, e, {\n          order: 0\n        })));\n      });\n    }, e;\n  }), i(e, "Core/Axis/Tick.js", [e["Core/Templating.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e, i) {\n    let {\n        deg2rad: s\n      } = e,\n      {\n        clamp: o,\n        correctFloat: r,\n        defined: a,\n        destroyObjectProperties: n,\n        extend: l,\n        fireEvent: h,\n        isNumber: d,\n        merge: c,\n        objectEach: p,\n        pick: u\n      } = i;\n    return class {\n      constructor(t, e, i, s, o) {\n        this.isNew = !0, this.isNewLabel = !0, this.axis = t, this.pos = e, this.type = i || "", this.parameters = o || {}, this.tickmarkOffset = this.parameters.tickmarkOffset, this.options = this.parameters.options, h(this, "init"), i || s || this.addLabel();\n      }\n      addLabel() {\n        let e = this,\n          i = e.axis,\n          s = i.options,\n          o = i.chart,\n          n = i.categories,\n          c = i.logarithmic,\n          p = i.names,\n          g = e.pos,\n          f = u(e.options && e.options.labels, s.labels),\n          m = i.tickPositions,\n          x = g === m[0],\n          y = g === m[m.length - 1],\n          b = (!f.step || 1 === f.step) && 1 === i.tickInterval,\n          v = m.info,\n          M = e.label,\n          S,\n          k,\n          C,\n          A = this.parameters.category || (n ? u(n[g], p[g], g) : g);\n        c && d(A) && (A = r(c.lin2log(A))), i.dateTime && (v ? S = (k = o.time.resolveDTLFormat(s.dateTimeLabelFormats[!s.grid && v.higherRanks[g] || v.unitName])).main : d(A) && (S = i.dateTime.getXDateFormat(A, s.dateTimeLabelFormats || {}))), e.isFirst = x, e.isLast = y;\n        let w = {\n          axis: i,\n          chart: o,\n          dateTimeLabelFormat: S,\n          isFirst: x,\n          isLast: y,\n          pos: g,\n          tick: e,\n          tickPositionInfo: v,\n          value: A\n        };\n        h(this, "labelFormat", w);\n        let T = e => f.formatter ? f.formatter.call(e, e) : f.format ? (e.text = i.defaultLabelFormatter.call(e, e), t.format(f.format, e, o)) : i.defaultLabelFormatter.call(e, e),\n          P = T.call(w, w),\n          L = k && k.list;\n        L ? e.shortenLabel = function () {\n          for (C = 0; C < L.length; C++) if (l(w, {\n            dateTimeLabelFormat: L[C]\n          }), M.attr({\n            text: T.call(w, w)\n          }), M.getBBox().width < i.getSlotWidth(e) - 2 * f.padding) return;\n          M.attr({\n            text: ""\n          });\n        } : e.shortenLabel = void 0, b && i._addedPlotLB && e.moveLabel(P, f), a(M) || e.movedLabel ? M && M.textStr !== P && !b && (!M.textWidth || f.style.width || M.styles.width || M.css({\n          width: null\n        }), M.attr({\n          text: P\n        }), M.textPxLength = M.getBBox().width) : (e.label = M = e.createLabel(P, f), e.rotation = 0);\n      }\n      createLabel(t, e, i) {\n        let s = this.axis,\n          o = s.chart,\n          r = a(t) && e.enabled ? o.renderer.text(t, i?.x, i?.y, e.useHTML).add(s.labelGroup) : void 0;\n        return r && (o.styledMode || r.css(c(e.style)), r.textPxLength = r.getBBox().width), r;\n      }\n      destroy() {\n        n(this, this.axis);\n      }\n      getPosition(t, e, i, s) {\n        let a = this.axis,\n          n = a.chart,\n          l = s && n.oldChartHeight || n.chartHeight,\n          d = {\n            x: t ? r(a.translate(e + i, void 0, void 0, s) + a.transB) : a.left + a.offset + (a.opposite ? (s && n.oldChartWidth || n.chartWidth) - a.right - a.left : 0),\n            y: t ? l - a.bottom + a.offset - (a.opposite ? a.height : 0) : r(l - a.translate(e + i, void 0, void 0, s) - a.transB)\n          };\n        return d.y = o(d.y, -1e5, 1e5), h(this, "afterGetPosition", {\n          pos: d\n        }), d;\n      }\n      getLabelPosition(t, e, i, o, r, n, l, d) {\n        let c, p;\n        let g = this.axis,\n          f = g.transA,\n          m = g.isLinked && g.linkedParent ? g.linkedParent.reversed : g.reversed,\n          x = g.staggerLines,\n          y = g.tickRotCorr || {\n            x: 0,\n            y: 0\n          },\n          b = o || g.reserveSpaceDefault ? 0 : -g.labelOffset * ("center" === g.labelAlign ? .5 : 1),\n          v = r.distance,\n          M = {};\n        return c = 0 === g.side ? i.rotation ? -v : -i.getBBox().height : 2 === g.side ? y.y + v : Math.cos(i.rotation * s) * (y.y - i.getBBox(!1, 0).height / 2), a(r.y) && (c = 0 === g.side && g.horiz ? r.y + c : r.y), t = t + u(r.x, [0, 1, 0, -1][g.side] * v) + b + y.x - (n && o ? n * f * (m ? -1 : 1) : 0), e = e + c - (n && !o ? n * f * (m ? 1 : -1) : 0), x && (p = l / (d || 1) % x, g.opposite && (p = x - p - 1), e += p * (g.labelOffset / x)), M.x = t, M.y = Math.round(e), h(this, "afterGetLabelPosition", {\n          pos: M,\n          tickmarkOffset: n,\n          index: l\n        }), M;\n      }\n      getLabelSize() {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;\n      }\n      getMarkPath(t, e, i, s, o, r) {\n        return r.crispLine([["M", t, e], ["L", t + (o ? 0 : -i), e + (o ? i : 0)]], s);\n      }\n      handleOverflow(t) {\n        let e = this.axis,\n          i = e.options.labels,\n          o = t.x,\n          r = e.chart.chartWidth,\n          a = e.chart.spacing,\n          n = u(e.labelLeft, Math.min(e.pos, a[3])),\n          l = u(e.labelRight, Math.max(e.isRadial ? 0 : e.pos + e.len, r - a[1])),\n          h = this.label,\n          d = this.rotation,\n          c = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[e.labelAlign || h.attr("align")],\n          p = h.getBBox().width,\n          g = e.getSlotWidth(this),\n          f = {},\n          m = g,\n          x = 1,\n          y;\n        d || "justify" !== i.overflow ? d < 0 && o - c * p < n ? y = Math.round(o / Math.cos(d * s) - n) : d > 0 && o + c * p > l && (y = Math.round((r - o) / Math.cos(d * s))) : (o - c * p < n ? m = t.x + m * (1 - c) - n : o + (1 - c) * p > l && (m = l - t.x + m * c, x = -1), (m = Math.min(g, m)) < g && "center" === e.labelAlign && (t.x += x * (g - m - c * (g - Math.min(p, m)))), (p > m || e.autoRotation && (h.styles || {}).width) && (y = m)), y && (this.shortenLabel ? this.shortenLabel() : (f.width = Math.floor(y) + "px", (i.style || {}).textOverflow || (f.textOverflow = "ellipsis"), h.css(f)));\n      }\n      moveLabel(t, e) {\n        let i = this,\n          s = i.label,\n          o = i.axis,\n          r = !1,\n          a;\n        s && s.textStr === t ? (i.movedLabel = s, r = !0, delete i.label) : p(o.ticks, function (e) {\n          r || e.isNew || e === i || !e.label || e.label.textStr !== t || (i.movedLabel = e.label, r = !0, e.labelPos = i.movedLabel.xy, delete e.label);\n        }), !r && (i.labelPos || s) && (a = i.labelPos || s.xy, i.movedLabel = i.createLabel(t, e, a), i.movedLabel && i.movedLabel.attr({\n          opacity: 0\n        }));\n      }\n      render(t, e, i) {\n        let s = this.axis,\n          o = s.horiz,\n          r = this.pos,\n          a = u(this.tickmarkOffset, s.tickmarkOffset),\n          n = this.getPosition(o, r, a, e),\n          l = n.x,\n          d = n.y,\n          c = o && l === s.pos + s.len || !o && d === s.pos ? -1 : 1,\n          p = u(i, this.label && this.label.newOpacity, 1);\n        i = u(i, 1), this.isActive = !0, this.renderGridLine(e, i, c), this.renderMark(n, i, c), this.renderLabel(n, e, p, t), this.isNew = !1, h(this, "afterRender");\n      }\n      renderGridLine(t, e, i) {\n        let s = this.axis,\n          o = s.options,\n          r = {},\n          a = this.pos,\n          n = this.type,\n          l = u(this.tickmarkOffset, s.tickmarkOffset),\n          h = s.chart.renderer,\n          d = this.gridLine,\n          c,\n          p = o.gridLineWidth,\n          g = o.gridLineColor,\n          f = o.gridLineDashStyle;\n        "minor" === this.type && (p = o.minorGridLineWidth, g = o.minorGridLineColor, f = o.minorGridLineDashStyle), d || (s.chart.styledMode || (r.stroke = g, r["stroke-width"] = p || 0, r.dashstyle = f), n || (r.zIndex = 1), t && (e = 0), this.gridLine = d = h.path().attr(r).addClass("highcharts-" + (n ? n + "-" : "") + "grid-line").add(s.gridGroup)), d && (c = s.getPlotLinePath({\n          value: a + l,\n          lineWidth: d.strokeWidth() * i,\n          force: "pass",\n          old: t,\n          acrossPanes: !1\n        })) && d[t || this.isNew ? "attr" : "animate"]({\n          d: c,\n          opacity: e\n        });\n      }\n      renderMark(t, e, i) {\n        let s = this.axis,\n          o = s.options,\n          r = s.chart.renderer,\n          a = this.type,\n          n = s.tickSize(a ? a + "Tick" : "tick"),\n          l = t.x,\n          h = t.y,\n          d = u(o["minor" !== a ? "tickWidth" : "minorTickWidth"], !a && s.isXAxis ? 1 : 0),\n          c = o["minor" !== a ? "tickColor" : "minorTickColor"],\n          p = this.mark,\n          g = !p;\n        n && (s.opposite && (n[0] = -n[0]), p || (this.mark = p = r.path().addClass("highcharts-" + (a ? a + "-" : "") + "tick").add(s.axisGroup), s.chart.styledMode || p.attr({\n          stroke: c,\n          "stroke-width": d\n        })), p[g ? "attr" : "animate"]({\n          d: this.getMarkPath(l, h, n[0], p.strokeWidth() * i, s.horiz, r),\n          opacity: e\n        }));\n      }\n      renderLabel(t, e, i, s) {\n        let o = this.axis,\n          r = o.horiz,\n          a = o.options,\n          n = this.label,\n          l = a.labels,\n          h = l.step,\n          c = u(this.tickmarkOffset, o.tickmarkOffset),\n          p = t.x,\n          g = t.y,\n          f = !0;\n        n && d(p) && (n.xy = t = this.getLabelPosition(p, g, n, r, l, c, s, h), (!this.isFirst || this.isLast || a.showFirstLabel) && (!this.isLast || this.isFirst || a.showLastLabel) ? !r || l.step || l.rotation || e || 0 === i || this.handleOverflow(t) : f = !1, h && s % h && (f = !1), f && d(t.y) ? (t.opacity = i, n[this.isNewLabel ? "attr" : "animate"](t).show(!0), this.isNewLabel = !1) : (n.hide(), this.isNewLabel = !0));\n      }\n      replaceMovedLabel() {\n        let t = this.label,\n          e = this.axis;\n        t && !this.isNew && (t.animate({\n          opacity: 0\n        }, void 0, t.destroy), delete this.label), e.isDirty = !0, this.label = this.movedLabel, delete this.movedLabel;\n      }\n    };\n  }), i(e, "Core/Axis/Axis.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Axis/AxisDefaults.js"], e["Core/Color/Color.js"], e["Core/Defaults.js"], e["Core/Foundation.js"], e["Core/Globals.js"], e["Core/Axis/Tick.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, r, a, n) {\n    let {\n        animObject: l\n      } = t,\n      {\n        xAxis: h,\n        yAxis: d\n      } = e,\n      {\n        defaultOptions: c\n      } = s,\n      {\n        registerEventOptions: p\n      } = o,\n      {\n        deg2rad: u\n      } = r,\n      {\n        arrayMax: g,\n        arrayMin: f,\n        clamp: m,\n        correctFloat: x,\n        defined: y,\n        destroyObjectProperties: b,\n        erase: v,\n        error: M,\n        extend: S,\n        fireEvent: k,\n        getClosestDistance: C,\n        insertItem: A,\n        isArray: w,\n        isNumber: T,\n        isString: P,\n        merge: L,\n        normalizeTickInterval: D,\n        objectEach: O,\n        pick: E,\n        relativeLength: B,\n        removeEvent: j,\n        splat: I,\n        syncTimeout: R\n      } = n,\n      z = (t, e) => D(e, void 0, void 0, E(t.options.allowDecimals, e < .5 || void 0 !== t.tickAmount), !!t.tickAmount);\n    S(c, {\n      xAxis: h,\n      yAxis: L(h, d)\n    });\n    class G {\n      constructor(t, e, i) {\n        this.init(t, e, i);\n      }\n      init(t, e, i = this.coll) {\n        let s = "xAxis" === i,\n          o = this.isZAxis || (t.inverted ? !s : s);\n        this.chart = t, this.horiz = o, this.isXAxis = s, this.coll = i, k(this, "init", {\n          userOptions: e\n        }), this.opposite = E(e.opposite, this.opposite), this.side = E(e.side, this.side, o ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3), this.setOptions(e);\n        let r = this.options,\n          a = r.labels,\n          n = r.type;\n        this.userOptions = e, this.minPixelPadding = 0, this.reversed = E(r.reversed, this.reversed), this.visible = r.visible, this.zoomEnabled = r.zoomEnabled, this.hasNames = "category" === n || !0 === r.categories, this.categories = w(r.categories) && r.categories || (this.hasNames ? [] : void 0), this.names || (this.names = [], this.names.keys = {}), this.plotLinesAndBandsGroups = {}, this.positiveValuesOnly = !!this.logarithmic, this.isLinked = y(r.linkedTo), this.ticks = {}, this.labelEdge = [], this.minorTicks = {}, this.plotLinesAndBands = [], this.alternateBands = {}, this.len = 0, this.minRange = this.userMinRange = r.minRange || r.maxZoom, this.range = r.range, this.offset = r.offset || 0, this.max = void 0, this.min = void 0;\n        let l = E(r.crosshair, I(t.options.tooltip.crosshairs)[s ? 0 : 1]);\n        this.crosshair = !0 === l ? {} : l, -1 === t.axes.indexOf(this) && (s ? t.axes.splice(t.xAxis.length, 0, this) : t.axes.push(this), A(this, t[this.coll])), t.orderItems(this.coll), this.series = this.series || [], t.inverted && !this.isZAxis && s && !y(this.reversed) && (this.reversed = !0), this.labelRotation = T(a.rotation) ? a.rotation : void 0, p(this, r), k(this, "afterInit");\n      }\n      setOptions(t) {\n        let e = this.horiz ? {\n          labels: {\n            autoRotation: [-45]\n          },\n          margin: 15\n        } : {\n          title: {\n            rotation: 90 * this.side\n          }\n        };\n        this.options = L(e, c[this.coll], t), k(this, "afterSetOptions", {\n          userOptions: t\n        });\n      }\n      defaultLabelFormatter(t) {\n        let e = this.axis,\n          i = this.chart,\n          {\n            numberFormatter: s\n          } = i,\n          o = T(this.value) ? this.value : NaN,\n          r = e.chart.time,\n          a = e.categories,\n          n = this.dateTimeLabelFormat,\n          l = c.lang,\n          h = l.numericSymbols,\n          d = l.numericSymbolMagnitude || 1e3,\n          p = e.logarithmic ? Math.abs(o) : e.tickInterval,\n          u = h && h.length,\n          g,\n          f;\n        if (a) f = `${this.value}`;else if (n) f = r.dateFormat(n, o);else if (u && h && p >= 1e3) for (; u-- && void 0 === f;) p >= (g = Math.pow(d, u + 1)) && 10 * o % g == 0 && null !== h[u] && 0 !== o && (f = s(o / g, -1) + h[u]);\n        return void 0 === f && (f = Math.abs(o) >= 1e4 ? s(o, -1) : s(o, -1, void 0, "")), f;\n      }\n      getSeriesExtremes() {\n        let t;\n        let e = this;\n        k(this, "getSeriesExtremes", null, function () {\n          e.hasVisibleSeries = !1, e.dataMin = e.dataMax = e.threshold = void 0, e.softThreshold = !e.isXAxis, e.series.forEach(i => {\n            if (i.reserveSpace()) {\n              let s = i.options,\n                o,\n                r = s.threshold,\n                a,\n                n;\n              if (e.hasVisibleSeries = !0, e.positiveValuesOnly && 0 >= (r || 0) && (r = void 0), e.isXAxis) (o = i.xData) && o.length && (o = e.logarithmic ? o.filter(t => t > 0) : o, a = (t = i.getXExtremes(o)).min, n = t.max, T(a) || a instanceof Date || (o = o.filter(T), a = (t = i.getXExtremes(o)).min, n = t.max), o.length && (e.dataMin = Math.min(E(e.dataMin, a), a), e.dataMax = Math.max(E(e.dataMax, n), n)));else {\n                let t = i.applyExtremes();\n                T(t.dataMin) && (a = t.dataMin, e.dataMin = Math.min(E(e.dataMin, a), a)), T(t.dataMax) && (n = t.dataMax, e.dataMax = Math.max(E(e.dataMax, n), n)), y(r) && (e.threshold = r), (!s.softThreshold || e.positiveValuesOnly) && (e.softThreshold = !1);\n              }\n            }\n          });\n        }), k(this, "afterGetSeriesExtremes");\n      }\n      translate(t, e, i, s, o, r) {\n        let a = this.linkedParent || this,\n          n = s && a.old ? a.old.min : a.min;\n        if (!T(n)) return NaN;\n        let l = a.minPixelPadding,\n          h = (a.isOrdinal || a.brokenAxis?.hasBreaks || a.logarithmic && o) && a.lin2val,\n          d = 1,\n          c = 0,\n          p = s && a.old ? a.old.transA : a.transA,\n          u = 0;\n        if (p || (p = a.transA), i && (d *= -1, c = a.len), a.reversed && (d *= -1, c -= d * (a.sector || a.len)), e) u = (t = t * d + c - l) / p + n, h && (u = a.lin2val(u));else {\n          h && (t = a.val2lin(t));\n          let e = d * (t - n) * p;\n          u = (a.isRadial ? e : x(e)) + c + d * l + (T(r) ? p * r : 0);\n        }\n        return u;\n      }\n      toPixels(t, e) {\n        return this.translate(t, !1, !this.horiz, void 0, !0) + (e ? 0 : this.pos);\n      }\n      toValue(t, e) {\n        return this.translate(t - (e ? 0 : this.pos), !0, !this.horiz, void 0, !0);\n      }\n      getPlotLinePath(t) {\n        let e = this,\n          i = e.chart,\n          s = e.left,\n          o = e.top,\n          r = t.old,\n          a = t.value,\n          n = t.lineWidth,\n          l = r && i.oldChartHeight || i.chartHeight,\n          h = r && i.oldChartWidth || i.chartWidth,\n          d = e.transB,\n          c = t.translatedValue,\n          p = t.force,\n          u,\n          g,\n          f,\n          x,\n          y;\n        function b(t, e, i) {\n          return "pass" !== p && (t < e || t > i) && (p ? t = m(t, e, i) : y = !0), t;\n        }\n        let v = {\n          value: a,\n          lineWidth: n,\n          old: r,\n          force: p,\n          acrossPanes: t.acrossPanes,\n          translatedValue: c\n        };\n        return k(this, "getPlotLinePath", v, function (t) {\n          u = f = Math.round((c = m(c = E(c, e.translate(a, void 0, void 0, r)), -1e5, 1e5)) + d), g = x = Math.round(l - c - d), T(c) ? e.horiz ? (g = o, x = l - e.bottom, u = f = b(u, s, s + e.width)) : (u = s, f = h - e.right, g = x = b(g, o, o + e.height)) : (y = !0, p = !1), t.path = y && !p ? void 0 : i.renderer.crispLine([["M", u, g], ["L", f, x]], n || 1);\n        }), v.path;\n      }\n      getLinearTickPositions(t, e, i) {\n        let s, o, r;\n        let a = x(Math.floor(e / t) * t),\n          n = x(Math.ceil(i / t) * t),\n          l = [];\n        if (x(a + t) === a && (r = 20), this.single) return [e];\n        for (s = a; s <= n && (l.push(s), (s = x(s + t, r)) !== o);) o = s;\n        return l;\n      }\n      getMinorTickInterval() {\n        let {\n          minorTicks: t,\n          minorTickInterval: e\n        } = this.options;\n        return !0 === t ? E(e, "auto") : !1 !== t ? e : void 0;\n      }\n      getMinorTickPositions() {\n        let t = this.options,\n          e = this.tickPositions,\n          i = this.minorTickInterval,\n          s = this.pointRangePadding || 0,\n          o = (this.min || 0) - s,\n          r = (this.max || 0) + s,\n          a = r - o,\n          n = [],\n          l;\n        if (a && a / i < this.len / 3) {\n          let s = this.logarithmic;\n          if (s) this.paddedTicks.forEach(function (t, e, o) {\n            e && n.push.apply(n, s.getLogTickPositions(i, o[e - 1], o[e], !0));\n          });else if (this.dateTime && "auto" === this.getMinorTickInterval()) n = n.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(i), o, r, t.startOfWeek));else for (l = o + (e[0] - o) % i; l <= r && l !== n[0]; l += i) n.push(l);\n        }\n        return 0 !== n.length && this.trimTicks(n), n;\n      }\n      adjustForMinRange() {\n        let t = this.options,\n          e = this.logarithmic,\n          {\n            max: i,\n            min: s,\n            minRange: o\n          } = this,\n          r,\n          a,\n          n,\n          l;\n        this.isXAxis && void 0 === o && !e && (o = y(t.min) || y(t.max) || y(t.floor) || y(t.ceiling) ? null : Math.min(5 * (C(this.series.map(t => (t.xIncrement ? t.xData?.slice(0, 2) : t.xData) || [])) || 0), this.dataMax - this.dataMin)), T(i) && T(s) && T(o) && i - s < o && (a = this.dataMax - this.dataMin >= o, r = (o - i + s) / 2, n = [s - r, E(t.min, s - r)], a && (n[2] = e ? e.log2lin(this.dataMin) : this.dataMin), l = [(s = g(n)) + o, E(t.max, s + o)], a && (l[2] = e ? e.log2lin(this.dataMax) : this.dataMax), (i = f(l)) - s < o && (n[0] = i - o, n[1] = E(t.min, i - o), s = g(n))), this.minRange = o, this.min = s, this.max = i;\n      }\n      getClosest() {\n        let t, e;\n        if (this.categories) e = 1;else {\n          let i = [];\n          this.series.forEach(function (t) {\n            let s = t.closestPointRange;\n            t.xData?.length === 1 ? i.push(t.xData[0]) : !t.noSharedTooltip && y(s) && t.reserveSpace() && (e = y(e) ? Math.min(e, s) : s);\n          }), i.length && (i.sort((t, e) => t - e), t = C([i]));\n        }\n        return t && e ? Math.min(t, e) : t || e;\n      }\n      nameToX(t) {\n        let e = w(this.options.categories),\n          i = e ? this.categories : this.names,\n          s = t.options.x,\n          o;\n        return t.series.requireSorting = !1, y(s) || (s = this.options.uniqueNames && i ? e ? i.indexOf(t.name) : E(i.keys[t.name], -1) : t.series.autoIncrement()), -1 === s ? !e && i && (o = i.length) : o = s, void 0 !== o ? (this.names[o] = t.name, this.names.keys[t.name] = o) : t.x && (o = t.x), o;\n      }\n      updateNames() {\n        let t = this,\n          e = this.names,\n          i = e.length;\n        i > 0 && (Object.keys(e.keys).forEach(function (t) {\n          delete e.keys[t];\n        }), e.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(e => {\n          e.xIncrement = null, (!e.points || e.isDirtyData) && (t.max = Math.max(t.max, e.xData.length - 1), e.processData(), e.generatePoints()), e.data.forEach(function (i, s) {\n            let o;\n            i?.options && void 0 !== i.name && void 0 !== (o = t.nameToX(i)) && o !== i.x && (i.x = o, e.xData[s] = o);\n          });\n        }));\n      }\n      setAxisTranslation() {\n        let t = this,\n          e = t.max - t.min,\n          i = t.linkedParent,\n          s = !!t.categories,\n          o = t.isXAxis,\n          r = t.axisPointRange || 0,\n          a,\n          n = 0,\n          l = 0,\n          h,\n          d = t.transA;\n        (o || s || r) && (a = t.getClosest(), i ? (n = i.minPointOffset, l = i.pointRangePadding) : t.series.forEach(function (e) {\n          let i = s ? 1 : o ? E(e.options.pointRange, a, 0) : t.axisPointRange || 0,\n            h = e.options.pointPlacement;\n          if (r = Math.max(r, i), !t.single || s) {\n            let t = e.is("xrange") ? !o : o;\n            n = Math.max(n, t && P(h) ? 0 : i / 2), l = Math.max(l, t && "on" === h ? 0 : i);\n          }\n        }), h = t.ordinal && t.ordinal.slope && a ? t.ordinal.slope / a : 1, t.minPointOffset = n *= h, t.pointRangePadding = l *= h, t.pointRange = Math.min(r, t.single && s ? 1 : e), o && a && (t.closestPointRange = a)), t.translationSlope = t.transA = d = t.staticScale || t.len / (e + l || 1), t.transB = t.horiz ? t.left : t.bottom, t.minPixelPadding = d * n, k(this, "afterSetAxisTranslation");\n      }\n      minFromRange() {\n        let {\n          max: t,\n          min: e\n        } = this;\n        return T(t) && T(e) && t - e || void 0;\n      }\n      setTickInterval(t) {\n        let {\n            categories: e,\n            chart: i,\n            dataMax: s,\n            dataMin: o,\n            dateTime: r,\n            isXAxis: a,\n            logarithmic: n,\n            options: l,\n            softThreshold: h\n          } = this,\n          d = T(this.threshold) ? this.threshold : void 0,\n          c = this.minRange || 0,\n          {\n            ceiling: p,\n            floor: u,\n            linkedTo: g,\n            softMax: f,\n            softMin: m\n          } = l,\n          b = T(g) && i[this.coll]?.[g],\n          v = l.tickPixelInterval,\n          S = l.maxPadding,\n          C = l.minPadding,\n          A = 0,\n          w,\n          P = T(l.tickInterval) && l.tickInterval >= 0 ? l.tickInterval : void 0,\n          L,\n          D,\n          O,\n          B;\n        if (r || e || b || this.getTickAmount(), O = E(this.userMin, l.min), B = E(this.userMax, l.max), b ? (this.linkedParent = b, w = b.getExtremes(), this.min = E(w.min, w.dataMin), this.max = E(w.max, w.dataMax), l.type !== b.options.type && M(11, !0, i)) : (h && y(d) && T(s) && T(o) && (o >= d ? (L = d, C = 0) : s <= d && (D = d, S = 0)), this.min = E(O, L, o), this.max = E(B, D, s)), T(this.max) && T(this.min) && (n && (this.positiveValuesOnly && !t && 0 >= Math.min(this.min, E(o, this.min)) && M(10, !0, i), this.min = x(n.log2lin(this.min), 16), this.max = x(n.log2lin(this.max), 16)), this.range && T(o) && (this.userMin = this.min = O = Math.max(o, this.minFromRange() || 0), this.userMax = B = this.max, this.range = void 0)), k(this, "foundExtremes"), this.adjustForMinRange(), T(this.min) && T(this.max)) {\n          if (!T(this.userMin) && T(m) && m < this.min && (this.min = O = m), !T(this.userMax) && T(f) && f > this.max && (this.max = B = f), e || this.axisPointRange || this.stacking?.usePercentage || b || !(A = this.max - this.min) || (!y(O) && C && (this.min -= A * C), y(B) || !S || (this.max += A * S)), !T(this.userMin) && T(u) && (this.min = Math.max(this.min, u)), !T(this.userMax) && T(p) && (this.max = Math.min(this.max, p)), h && T(o) && T(s)) {\n            let t = d || 0;\n            !y(O) && this.min < t && o >= t ? this.min = l.minRange ? Math.min(t, this.max - c) : t : !y(B) && this.max > t && s <= t && (this.max = l.minRange ? Math.max(t, this.min + c) : t);\n          }\n          !i.polar && this.min > this.max && (y(l.min) ? this.max = this.min : y(l.max) && (this.min = this.max)), A = this.max - this.min;\n        }\n        if (this.min !== this.max && T(this.min) && T(this.max) ? b && !P && v === b.options.tickPixelInterval ? this.tickInterval = P = b.tickInterval : this.tickInterval = E(P, this.tickAmount ? A / Math.max(this.tickAmount - 1, 1) : void 0, e ? 1 : A * v / Math.max(this.len, v)) : this.tickInterval = 1, a && !t) {\n          let t = this.min !== this.old?.min || this.max !== this.old?.max;\n          this.series.forEach(function (e) {\n            e.forceCrop = e.forceCropping?.(), e.processData(t);\n          }), k(this, "postProcessData", {\n            hasExtremesChanged: t\n          });\n        }\n        this.setAxisTranslation(), k(this, "initialAxisTranslation"), this.pointRange && !P && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));\n        let j = E(l.minTickInterval, r && !this.series.some(t => t.noSharedTooltip) ? this.closestPointRange : 0);\n        !P && this.tickInterval < j && (this.tickInterval = j), r || n || P || (this.tickInterval = z(this, this.tickInterval)), this.tickAmount || (this.tickInterval = this.unsquish()), this.setTickPositions();\n      }\n      setTickPositions() {\n        let t = this.options,\n          e = t.tickPositions,\n          i = t.tickPositioner,\n          s = this.getMinorTickInterval(),\n          o = this.hasVerticalPanning(),\n          r = "colorAxis" === this.coll,\n          a = (r || !o) && t.startOnTick,\n          n = (r || !o) && t.endOnTick,\n          l = [],\n          h;\n        if (this.tickmarkOffset = this.categories && "between" === t.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0, this.minorTickInterval = "auto" === s && this.tickInterval ? this.tickInterval / t.minorTicksPerMajor : s, this.single = this.min === this.max && y(this.min) && !this.tickAmount && (this.min % 1 == 0 || !1 !== t.allowDecimals), e) l = e.slice();else if (T(this.min) && T(this.max)) {\n          if (!this.ordinal?.positions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) l = [this.min, this.max], M(19, !1, this.chart);else if (this.dateTime) l = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, t.units), this.min, this.max, t.startOfWeek, this.ordinal?.positions, this.closestPointRange, !0);else if (this.logarithmic) l = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);else {\n            let t = this.tickInterval,\n              e = t;\n            for (; e <= 2 * t;) if (l = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && l.length > this.tickAmount) this.tickInterval = z(this, e *= 1.1);else break;\n          }\n          l.length > this.len && (l = [l[0], l[l.length - 1]])[0] === l[1] && (l.length = 1), i && (this.tickPositions = l, (h = i.apply(this, [this.min, this.max])) && (l = h));\n        }\n        this.tickPositions = l, this.paddedTicks = l.slice(0), this.trimTicks(l, a, n), !this.isLinked && T(this.min) && T(this.max) && (this.single && l.length < 2 && !this.categories && !this.series.some(t => t.is("heatmap") && "between" === t.options.pointPlacement) && (this.min -= .5, this.max += .5), e || h || this.adjustTickAmount()), k(this, "afterSetTickPositions");\n      }\n      trimTicks(t, e, i) {\n        let s = t[0],\n          o = t[t.length - 1],\n          r = !this.isOrdinal && this.minPointOffset || 0;\n        if (k(this, "trimTicks"), !this.isLinked) {\n          if (e && s !== -1 / 0) this.min = s;else for (; this.min - r > t[0];) t.shift();\n          if (i) this.max = o;else for (; this.max + r < t[t.length - 1];) t.pop();\n          0 === t.length && y(s) && !this.options.tickPositions && t.push((o + s) / 2);\n        }\n      }\n      alignToOthers() {\n        let t;\n        let e = this,\n          i = [this],\n          s = e.options,\n          o = this.chart.options.chart,\n          r = "yAxis" === this.coll && o.alignThresholds,\n          a = [];\n        if (e.thresholdAlignment = void 0, (!1 !== o.alignTicks && s.alignTicks || r) && !1 !== s.startOnTick && !1 !== s.endOnTick && !e.logarithmic) {\n          let s = t => {\n              let {\n                horiz: e,\n                options: i\n              } = t;\n              return [e ? i.left : i.top, i.width, i.height, i.pane].join(",");\n            },\n            o = s(this);\n          this.chart[this.coll].forEach(function (r) {\n            let {\n              series: a\n            } = r;\n            a.length && a.some(t => t.visible) && r !== e && s(r) === o && (t = !0, i.push(r));\n          });\n        }\n        if (t && r) {\n          i.forEach(t => {\n            let i = t.getThresholdAlignment(e);\n            T(i) && a.push(i);\n          });\n          let t = a.length > 1 ? a.reduce((t, e) => t += e, 0) / a.length : void 0;\n          i.forEach(e => {\n            e.thresholdAlignment = t;\n          });\n        }\n        return t;\n      }\n      getThresholdAlignment(t) {\n        if ((!T(this.dataMin) || this !== t && this.series.some(t => t.isDirty || t.isDirtyData)) && this.getSeriesExtremes(), T(this.threshold)) {\n          let t = m((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1);\n          return this.options.reversed && (t = 1 - t), t;\n        }\n      }\n      getTickAmount() {\n        let t = this.options,\n          e = t.tickPixelInterval,\n          i = t.tickAmount;\n        y(t.tickInterval) || i || !(this.len < e) || this.isRadial || this.logarithmic || !t.startOnTick || !t.endOnTick || (i = 2), !i && this.alignToOthers() && (i = Math.ceil(this.len / e) + 1), i < 4 && (this.finalTickAmt = i, i = 5), this.tickAmount = i;\n      }\n      adjustTickAmount() {\n        let t = this,\n          {\n            finalTickAmt: e,\n            max: i,\n            min: s,\n            options: o,\n            tickPositions: r,\n            tickAmount: a,\n            thresholdAlignment: n\n          } = t,\n          l = r?.length,\n          h = E(t.threshold, t.softThreshold ? 0 : null),\n          d,\n          c,\n          p = t.tickInterval,\n          u,\n          g = () => r.push(x(r[r.length - 1] + p)),\n          f = () => r.unshift(x(r[0] - p));\n        if (T(n) && (u = n < .5 ? Math.ceil(n * (a - 1)) : Math.floor(n * (a - 1)), o.reversed && (u = a - 1 - u)), t.hasData() && T(s) && T(i)) {\n          let n = () => {\n            t.transA *= (l - 1) / (a - 1), t.min = o.startOnTick ? r[0] : Math.min(s, r[0]), t.max = o.endOnTick ? r[r.length - 1] : Math.max(i, r[r.length - 1]);\n          };\n          if (T(u) && T(t.threshold)) {\n            for (; r[u] !== h || r.length !== a || r[0] > s || r[r.length - 1] < i;) {\n              for (r.length = 0, r.push(t.threshold); r.length < a;) void 0 === r[u] || r[u] > t.threshold ? f() : g();\n              if (p > 8 * t.tickInterval) break;\n              p *= 2;\n            }\n            n();\n          } else if (l < a) {\n            for (; r.length < a;) r.length % 2 || s === h ? g() : f();\n            n();\n          }\n          if (y(e)) {\n            for (c = d = r.length; c--;) (3 === e && c % 2 == 1 || e <= 2 && c > 0 && c < d - 1) && r.splice(c, 1);\n            t.finalTickAmt = void 0;\n          }\n        }\n      }\n      setScale() {\n        let {\n            coll: t,\n            stacking: e\n          } = this,\n          i = !1,\n          s = !1;\n        this.series.forEach(t => {\n          i = i || t.isDirtyData || t.isDirty, s = s || t.xAxis && t.xAxis.isDirty || !1;\n        }), this.setAxisSize();\n        let o = this.len !== (this.old && this.old.len);\n        o || i || s || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (e && "yAxis" === t && e.buildStacks(), this.forceRedraw = !1, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), e && "xAxis" === t && e.buildStacks(), this.isDirty || (this.isDirty = o || this.min !== this.old?.min || this.max !== this.old?.max)) : e && e.cleanStacks(), i && this.panningState && (this.panningState.isDirty = !0), k(this, "afterSetScale");\n      }\n      setExtremes(t, e, i = !0, s, o) {\n        let r = this,\n          a = r.chart;\n        r.series.forEach(t => {\n          delete t.kdTree;\n        }), k(r, "setExtremes", o = S(o, {\n          min: t,\n          max: e\n        }), () => {\n          r.userMin = t, r.userMax = e, r.eventArgs = o, i && a.redraw(s);\n        });\n      }\n      zoom(t, e) {\n        let i = this,\n          s = this.dataMin,\n          o = this.dataMax,\n          r = this.options,\n          a = Math.min(s, E(r.min, s)),\n          n = Math.max(o, E(r.max, o)),\n          l = {\n            newMin: t,\n            newMax: e\n          };\n        return k(this, "zoom", l, function (t) {\n          let e = t.newMin,\n            r = t.newMax;\n          (e !== i.min || r !== i.max) && (!i.allowZoomOutside && (y(s) && (e < a && (e = a), e > n && (e = n)), y(o) && (r < a && (r = a), r > n && (r = n))), i.displayBtn = void 0 !== e || void 0 !== r, i.setExtremes(e, r, !1, void 0, {\n            trigger: "zoom"\n          })), t.zoomed = !0;\n        }), l.zoomed;\n      }\n      setAxisSize() {\n        let t = this.chart,\n          e = this.options,\n          i = e.offsets || [0, 0, 0, 0],\n          s = this.horiz,\n          o = this.width = Math.round(B(E(e.width, t.plotWidth - i[3] + i[1]), t.plotWidth)),\n          r = this.height = Math.round(B(E(e.height, t.plotHeight - i[0] + i[2]), t.plotHeight)),\n          a = this.top = Math.round(B(E(e.top, t.plotTop + i[0]), t.plotHeight, t.plotTop)),\n          n = this.left = Math.round(B(E(e.left, t.plotLeft + i[3]), t.plotWidth, t.plotLeft));\n        this.bottom = t.chartHeight - r - a, this.right = t.chartWidth - o - n, this.len = Math.max(s ? o : r, 0), this.pos = s ? n : a;\n      }\n      getExtremes() {\n        let t = this.logarithmic;\n        return {\n          min: t ? x(t.lin2log(this.min)) : this.min,\n          max: t ? x(t.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      }\n      getThreshold(t) {\n        let e = this.logarithmic,\n          i = e ? e.lin2log(this.min) : this.min,\n          s = e ? e.lin2log(this.max) : this.max;\n        return null === t || t === -1 / 0 ? t = i : t === 1 / 0 ? t = s : i > t ? t = i : s < t && (t = s), this.translate(t, 0, 1, 0, 1);\n      }\n      autoLabelAlign(t) {\n        let e = (E(t, 0) - 90 * this.side + 720) % 360,\n          i = {\n            align: "center"\n          };\n        return k(this, "autoLabelAlign", i, function (t) {\n          e > 15 && e < 165 ? t.align = "right" : e > 195 && e < 345 && (t.align = "left");\n        }), i.align;\n      }\n      tickSize(t) {\n        let e = this.options,\n          i = E(e["tick" === t ? "tickWidth" : "minorTickWidth"], "tick" === t && this.isXAxis && !this.categories ? 1 : 0),\n          s = e["tick" === t ? "tickLength" : "minorTickLength"],\n          o;\n        i && s && ("inside" === e[t + "Position"] && (s = -s), o = [s, i]);\n        let r = {\n          tickSize: o\n        };\n        return k(this, "afterTickSize", r), r.tickSize;\n      }\n      labelMetrics() {\n        let t = this.chart.renderer,\n          e = this.ticks,\n          i = e[Object.keys(e)[0]] || {};\n        return this.chart.renderer.fontMetrics(i.label || i.movedLabel || t.box);\n      }\n      unsquish() {\n        let t = this.options.labels,\n          e = this.horiz,\n          i = this.tickInterval,\n          s = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / i),\n          o = t.rotation,\n          r = this.labelMetrics().h,\n          a = Math.max(this.max - this.min, 0),\n          n = function (t) {\n            let e = t / (s || 1);\n            return (e = e > 1 ? Math.ceil(e) : 1) * i > a && t !== 1 / 0 && s !== 1 / 0 && a && (e = Math.ceil(a / i)), x(e * i);\n          },\n          l = i,\n          h,\n          d = Number.MAX_VALUE,\n          c;\n        if (e) {\n          if (!t.staggerLines && (T(o) ? c = [o] : s < t.autoRotationLimit && (c = t.autoRotation)), c) {\n            let t, e;\n            for (let i of c) (i === o || i && i >= -90 && i <= 90) && (e = (t = n(Math.abs(r / Math.sin(u * i)))) + Math.abs(i / 360)) < d && (d = e, h = i, l = t);\n          }\n        } else l = n(.75 * r);\n        return this.autoRotation = c, this.labelRotation = E(h, T(o) ? o : 0), t.step ? i : l;\n      }\n      getSlotWidth(t) {\n        let e = this.chart,\n          i = this.horiz,\n          s = this.options.labels,\n          o = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n          r = e.margin[3];\n        if (t && T(t.slotWidth)) return t.slotWidth;\n        if (i && s.step < 2) return s.rotation ? 0 : (this.staggerLines || 1) * this.len / o;\n        if (!i) {\n          let t = s.style.width;\n          if (void 0 !== t) return parseInt(String(t), 10);\n          if (r) return r - e.spacing[3];\n        }\n        return .33 * e.chartWidth;\n      }\n      renderUnsquish() {\n        let t = this.chart,\n          e = t.renderer,\n          i = this.tickPositions,\n          s = this.ticks,\n          o = this.options.labels,\n          r = o.style,\n          a = this.horiz,\n          n = this.getSlotWidth(),\n          l = Math.max(1, Math.round(n - 2 * o.padding)),\n          h = {},\n          d = this.labelMetrics(),\n          c = r.textOverflow,\n          p,\n          u,\n          g = 0,\n          f,\n          m;\n        if (P(o.rotation) || (h.rotation = o.rotation || 0), i.forEach(function (t) {\n          let e = s[t];\n          e.movedLabel && e.replaceMovedLabel(), e && e.label && e.label.textPxLength > g && (g = e.label.textPxLength);\n        }), this.maxLabelLength = g, this.autoRotation) g > l && g > d.h ? h.rotation = this.labelRotation : this.labelRotation = 0;else if (n && (p = l, !c)) for (u = "clip", m = i.length; !a && m--;) (f = s[i[m]].label) && (f.styles && "ellipsis" === f.styles.textOverflow ? f.css({\n          textOverflow: "clip"\n        }) : f.textPxLength > n && f.css({\n          width: n + "px"\n        }), f.getBBox().height > this.len / i.length - (d.h - d.f) && (f.specificTextOverflow = "ellipsis"));\n        h.rotation && (p = g > .5 * t.chartHeight ? .33 * t.chartHeight : g, c || (u = "ellipsis")), this.labelAlign = o.align || this.autoLabelAlign(this.labelRotation), this.labelAlign && (h.align = this.labelAlign), i.forEach(function (t) {\n          let e = s[t],\n            i = e && e.label,\n            o = r.width,\n            a = {};\n          i && (i.attr(h), e.shortenLabel ? e.shortenLabel() : p && !o && "nowrap" !== r.whiteSpace && (p < i.textPxLength || "SPAN" === i.element.tagName) ? (a.width = p + "px", c || (a.textOverflow = i.specificTextOverflow || u), i.css(a)) : i.styles && i.styles.width && !a.width && !o && i.css({\n            width: null\n          }), delete i.specificTextOverflow, e.rotation = h.rotation);\n        }, this), this.tickRotCorr = e.rotCorr(d.b, this.labelRotation || 0, 0 !== this.side);\n      }\n      hasData() {\n        return this.series.some(function (t) {\n          return t.hasData();\n        }) || this.options.showEmpty && y(this.min) && y(this.max);\n      }\n      addTitle(t) {\n        let e;\n        let i = this.chart.renderer,\n          s = this.horiz,\n          o = this.opposite,\n          r = this.options,\n          a = r.title,\n          n = this.chart.styledMode;\n        this.axisTitle || ((e = a.textAlign) || (e = (s ? {\n          low: "left",\n          middle: "center",\n          high: "right"\n        } : {\n          low: o ? "right" : "left",\n          middle: "center",\n          high: o ? "left" : "right"\n        })[a.align]), this.axisTitle = i.text(a.text || "", 0, 0, a.useHTML).attr({\n          zIndex: 7,\n          rotation: a.rotation || 0,\n          align: e\n        }).addClass("highcharts-axis-title"), n || this.axisTitle.css(L(a.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0), n || a.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len + "px"\n        }), this.axisTitle[t ? "show" : "hide"](t);\n      }\n      generateTick(t) {\n        let e = this.ticks;\n        e[t] ? e[t].addLabel() : e[t] = new a(this, t);\n      }\n      createGroups() {\n        let {\n            axisParent: t,\n            chart: e,\n            coll: i,\n            options: s\n          } = this,\n          o = e.renderer,\n          r = (e, r, a) => o.g(e).attr({\n            zIndex: a\n          }).addClass(`highcharts-${i.toLowerCase()}${r} ` + (this.isRadial ? `highcharts-radial-axis${r} ` : "") + (s.className || "")).add(t);\n        this.axisGroup || (this.gridGroup = r("grid", "-grid", s.gridZIndex), this.axisGroup = r("axis", "", s.zIndex), this.labelGroup = r("axis-labels", "-labels", s.labels.zIndex));\n      }\n      getOffset() {\n        let t = this,\n          {\n            chart: e,\n            horiz: i,\n            options: s,\n            side: o,\n            ticks: r,\n            tickPositions: a,\n            coll: n\n          } = t,\n          l = e.inverted && !t.isZAxis ? [1, 0, 3, 2][o] : o,\n          h = t.hasData(),\n          d = s.title,\n          c = s.labels,\n          p = T(s.crossing),\n          u = e.axisOffset,\n          g = e.clipOffset,\n          f = [-1, 1, 1, -1][o],\n          m,\n          x = 0,\n          b,\n          v = 0,\n          M = 0,\n          S,\n          C;\n        if (t.showAxis = m = h || s.showEmpty, t.staggerLines = t.horiz && c.staggerLines || void 0, t.createGroups(), h || t.isLinked ? (a.forEach(function (e) {\n          t.generateTick(e);\n        }), t.renderUnsquish(), t.reserveSpaceDefault = 0 === o || 2 === o || {\n          1: "left",\n          3: "right"\n        }[o] === t.labelAlign, E(c.reserveSpace, !p && null, "center" === t.labelAlign || null, t.reserveSpaceDefault) && a.forEach(function (t) {\n          M = Math.max(r[t].getLabelSize(), M);\n        }), t.staggerLines && (M *= t.staggerLines), t.labelOffset = M * (t.opposite ? -1 : 1)) : O(r, function (t, e) {\n          t.destroy(), delete r[e];\n        }), d?.text && !1 !== d.enabled && (t.addTitle(m), m && !p && !1 !== d.reserveSpace && (t.titleOffset = x = t.axisTitle.getBBox()[i ? "height" : "width"], v = y(b = d.offset) ? 0 : E(d.margin, i ? 5 : 10))), t.renderLine(), t.offset = f * E(s.offset, u[o] ? u[o] + (s.margin || 0) : 0), t.tickRotCorr = t.tickRotCorr || {\n          x: 0,\n          y: 0\n        }, C = 0 === o ? -t.labelMetrics().h : 2 === o ? t.tickRotCorr.y : 0, S = Math.abs(M) + v, M && (S -= C, S += f * (i ? E(c.y, t.tickRotCorr.y + f * c.distance) : E(c.x, f * c.distance))), t.axisTitleMargin = E(b, S), t.getMaxLabelDimensions && (t.maxLabelDimensions = t.getMaxLabelDimensions(r, a)), "colorAxis" !== n) {\n          let e = this.tickSize("tick");\n          u[o] = Math.max(u[o], (t.axisTitleMargin || 0) + x + f * t.offset, S, a && a.length && e ? e[0] + f * t.offset : 0);\n          let i = !t.axisLine || s.offset ? 0 : 2 * Math.floor(t.axisLine.strokeWidth() / 2);\n          g[l] = Math.max(g[l], i);\n        }\n        k(this, "afterGetOffset");\n      }\n      getLinePath(t) {\n        let e = this.chart,\n          i = this.opposite,\n          s = this.offset,\n          o = this.horiz,\n          r = this.left + (i ? this.width : 0) + s,\n          a = e.chartHeight - this.bottom - (i ? this.height : 0) + s;\n        return i && (t *= -1), e.renderer.crispLine([["M", o ? this.left : r, o ? a : this.top], ["L", o ? e.chartWidth - this.right : r, o ? a : e.chartHeight - this.bottom]], t);\n      }\n      renderLine() {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n          stroke: this.options.lineColor,\n          "stroke-width": this.options.lineWidth,\n          zIndex: 7\n        }));\n      }\n      getTitlePosition(t) {\n        let e = this.horiz,\n          i = this.left,\n          s = this.top,\n          o = this.len,\n          r = this.options.title,\n          a = e ? i : s,\n          n = this.opposite,\n          l = this.offset,\n          h = r.x,\n          d = r.y,\n          c = this.chart.renderer.fontMetrics(t),\n          p = t ? Math.max(t.getBBox(!1, 0).height - c.h - 1, 0) : 0,\n          u = {\n            low: a + (e ? 0 : o),\n            middle: a + o / 2,\n            high: a + (e ? o : 0)\n          }[r.align],\n          g = (e ? s + this.height : i) + (e ? 1 : -1) * (n ? -1 : 1) * (this.axisTitleMargin || 0) + [-p, p, c.f, -p][this.side],\n          f = {\n            x: e ? u + h : g + (n ? this.width : 0) + l + h,\n            y: e ? g + d - (n ? this.height : 0) + l : u + d\n          };\n        return k(this, "afterGetTitlePosition", {\n          titlePosition: f\n        }), f;\n      }\n      renderMinorTick(t, e) {\n        let i = this.minorTicks;\n        i[t] || (i[t] = new a(this, t, "minor")), e && i[t].isNew && i[t].render(null, !0), i[t].render(null, !1, 1);\n      }\n      renderTick(t, e, i) {\n        let s = this.isLinked,\n          o = this.ticks;\n        (!s || t >= this.min && t <= this.max || this.grid && this.grid.isColumn) && (o[t] || (o[t] = new a(this, t)), i && o[t].isNew && o[t].render(e, !0, -1), o[t].render(e));\n      }\n      render() {\n        let t, e;\n        let i = this,\n          s = i.chart,\n          o = i.logarithmic,\n          n = s.renderer,\n          h = i.options,\n          d = i.isLinked,\n          c = i.tickPositions,\n          p = i.axisTitle,\n          u = i.ticks,\n          g = i.minorTicks,\n          f = i.alternateBands,\n          m = h.stackLabels,\n          x = h.alternateGridColor,\n          y = h.crossing,\n          b = i.tickmarkOffset,\n          v = i.axisLine,\n          M = i.showAxis,\n          S = l(n.globalAnimation);\n        if (i.labelEdge.length = 0, i.overlap = !1, [u, g, f].forEach(function (t) {\n          O(t, function (t) {\n            t.isActive = !1;\n          });\n        }), T(y)) {\n          let t = this.isXAxis ? s.yAxis[0] : s.xAxis[0],\n            e = [1, -1, -1, 1][this.side];\n          if (t) {\n            let s = t.toPixels(y, !0);\n            i.horiz && (s = t.len - s), i.offset = e * s;\n          }\n        }\n        if (i.hasData() || d) {\n          let n = i.chart.hasRendered && i.old && T(i.old.min);\n          i.minorTickInterval && !i.categories && i.getMinorTickPositions().forEach(function (t) {\n            i.renderMinorTick(t, n);\n          }), c.length && (c.forEach(function (t, e) {\n            i.renderTick(t, e, n);\n          }), b && (0 === i.min || i.single) && (u[-1] || (u[-1] = new a(i, -1, null, !0)), u[-1].render(-1))), x && c.forEach(function (a, n) {\n            e = void 0 !== c[n + 1] ? c[n + 1] + b : i.max - b, n % 2 == 0 && a < i.max && e <= i.max + (s.polar ? -b : b) && (f[a] || (f[a] = new r.PlotLineOrBand(i, {})), t = a + b, f[a].options = {\n              from: o ? o.lin2log(t) : t,\n              to: o ? o.lin2log(e) : e,\n              color: x,\n              className: "highcharts-alternate-grid"\n            }, f[a].render(), f[a].isActive = !0);\n          }), i._addedPlotLB || (i._addedPlotLB = !0, (h.plotLines || []).concat(h.plotBands || []).forEach(function (t) {\n            i.addPlotBandOrLine(t);\n          }));\n        }\n        [u, g, f].forEach(function (t) {\n          let e = [],\n            i = S.duration;\n          O(t, function (t, i) {\n            t.isActive || (t.render(i, !1, 0), t.isActive = !1, e.push(i));\n          }), R(function () {\n            let i = e.length;\n            for (; i--;) t[e[i]] && !t[e[i]].isActive && (t[e[i]].destroy(), delete t[e[i]]);\n          }, t !== f && s.hasRendered && i ? i : 0);\n        }), v && (v[v.isPlaced ? "animate" : "attr"]({\n          d: this.getLinePath(v.strokeWidth())\n        }), v.isPlaced = !0, v[M ? "show" : "hide"](M)), p && M && (p[p.isNew ? "attr" : "animate"](i.getTitlePosition(p)), p.isNew = !1), m && m.enabled && i.stacking && i.stacking.renderStackTotals(), i.old = {\n          len: i.len,\n          max: i.max,\n          min: i.min,\n          transA: i.transA,\n          userMax: i.userMax,\n          userMin: i.userMin\n        }, i.isDirty = !1, k(this, "afterRender");\n      }\n      redraw() {\n        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (t) {\n          t.render();\n        })), this.series.forEach(function (t) {\n          t.isDirty = !0;\n        });\n      }\n      getKeepProps() {\n        return this.keepProps || G.keepProps;\n      }\n      destroy(t) {\n        let e = this,\n          i = e.plotLinesAndBands,\n          s = this.eventOptions;\n        if (k(this, "destroy", {\n          keepEvents: t\n        }), t || j(e), [e.ticks, e.minorTicks, e.alternateBands].forEach(function (t) {\n          b(t);\n        }), i) {\n          let t = i.length;\n          for (; t--;) i[t].destroy();\n        }\n        for (let t in ["axisLine", "axisTitle", "axisGroup", "gridGroup", "labelGroup", "cross", "scrollbar"].forEach(function (t) {\n          e[t] && (e[t] = e[t].destroy());\n        }), e.plotLinesAndBandsGroups) e.plotLinesAndBandsGroups[t] = e.plotLinesAndBandsGroups[t].destroy();\n        O(e, function (t, i) {\n          -1 === e.getKeepProps().indexOf(i) && delete e[i];\n        }), this.eventOptions = s;\n      }\n      drawCrosshair(t, e) {\n        let s = this.crosshair,\n          o = E(s && s.snap, !0),\n          r = this.chart,\n          a,\n          n,\n          l,\n          h = this.cross,\n          d;\n        if (k(this, "drawCrosshair", {\n          e: t,\n          point: e\n        }), t || (t = this.cross && this.cross.e), s && !1 !== (y(e) || !o)) {\n          if (o ? y(e) && (n = E("colorAxis" !== this.coll ? e.crosshairPos : null, this.isXAxis ? e.plotX : this.len - e.plotY)) : n = t && (this.horiz ? t.chartX - this.pos : this.len - t.chartY + this.pos), y(n) && (d = {\n            value: e && (this.isXAxis ? e.x : E(e.stackY, e.y)),\n            translatedValue: n\n          }, r.polar && S(d, {\n            isCrosshair: !0,\n            chartX: t && t.chartX,\n            chartY: t && t.chartY,\n            point: e\n          }), a = this.getPlotLinePath(d) || null), !y(a)) {\n            this.hideCrosshair();\n            return;\n          }\n          l = this.categories && !this.isRadial, h || (this.cross = h = r.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (l ? "category " : "thin ") + (s.className || "")).attr({\n            zIndex: E(s.zIndex, 2)\n          }).add(), !r.styledMode && (h.attr({\n            stroke: s.color || (l ? i.parse("#ccd3ff").setOpacity(.25).get() : "#cccccc"),\n            "stroke-width": E(s.width, 1)\n          }).css({\n            "pointer-events": "none"\n          }), s.dashStyle && h.attr({\n            dashstyle: s.dashStyle\n          }))), h.show().attr({\n            d: a\n          }), l && !s.width && h.attr({\n            "stroke-width": this.transA\n          }), this.cross.e = t;\n        } else this.hideCrosshair();\n        k(this, "afterDrawCrosshair", {\n          e: t,\n          point: e\n        });\n      }\n      hideCrosshair() {\n        this.cross && this.cross.hide(), k(this, "afterHideCrosshair");\n      }\n      hasVerticalPanning() {\n        let t = this.chart.options.chart.panning;\n        return !!(t && t.enabled && /y/.test(t.type));\n      }\n      update(t, e) {\n        let i = this.chart;\n        t = L(this.userOptions, t), this.destroy(!0), this.init(i, t), i.isDirtyBox = !0, E(e, !0) && i.redraw();\n      }\n      remove(t) {\n        let e = this.chart,\n          i = this.coll,\n          s = this.series,\n          o = s.length;\n        for (; o--;) s[o] && s[o].remove(!1);\n        v(e.axes, this), v(e[i] || [], this), e.orderItems(i), this.destroy(), e.isDirtyBox = !0, E(t, !0) && e.redraw();\n      }\n      setTitle(t, e) {\n        this.update({\n          title: t\n        }, e);\n      }\n      setCategories(t, e) {\n        this.update({\n          categories: t\n        }, e);\n      }\n    }\n    return G.keepProps = ["coll", "extKey", "hcEvents", "names", "series", "userMax", "userMin"], G;\n  }), i(e, "Core/Axis/DateTimeAxis.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e) {\n    var i;\n    let {\n        composed: s\n      } = t,\n      {\n        addEvent: o,\n        getMagnitude: r,\n        normalizeTickInterval: a,\n        pushUnique: n,\n        timeUnits: l\n      } = e;\n    return function (t) {\n      function e() {\n        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n      }\n      function i() {\n        if ("datetime" !== this.options.type) {\n          this.dateTime = void 0;\n          return;\n        }\n        this.dateTime || (this.dateTime = new h(this));\n      }\n      t.compose = function t(r) {\n        if (n(s, t)) {\n          r.keepProps.push("dateTime");\n          let t = r.prototype;\n          t.getTimeTicks = e, o(r, "afterSetOptions", i);\n        }\n        return r;\n      };\n      class h {\n        constructor(t) {\n          this.axis = t;\n        }\n        normalizeTimeTickInterval(t, e) {\n          let i = e || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]],\n            s = i[i.length - 1],\n            o = l[s[0]],\n            n = s[1],\n            h;\n          for (h = 0; h < i.length; h++) if (o = l[(s = i[h])[0]], n = s[1], i[h + 1]) {\n            let e = (o * n[n.length - 1] + l[i[h + 1][0]]) / 2;\n            if (t <= e) break;\n          }\n          o === l.year && t < 5 * o && (n = [1, 2, 5]);\n          let d = a(t / o, n, "year" === s[0] ? Math.max(r(t / o), 1) : 1);\n          return {\n            unitRange: o,\n            count: d,\n            unitName: s[0]\n          };\n        }\n        getXDateFormat(t, e) {\n          let {\n              axis: i\n            } = this,\n            s = i.chart.time;\n          return i.closestPointRange ? s.getDateFormat(i.closestPointRange, t, i.options.startOfWeek, e) || s.resolveDTLFormat(e.year).main : s.resolveDTLFormat(e.day).main;\n        }\n      }\n      t.Additions = h;\n    }(i || (i = {})), i;\n  }), i(e, "Core/Axis/LogarithmicAxis.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e) {\n    var i;\n    let {\n        composed: s\n      } = t,\n      {\n        addEvent: o,\n        normalizeTickInterval: r,\n        pick: a,\n        pushUnique: n\n      } = e;\n    return function (t) {\n      function e(t) {\n        let e = t.userOptions,\n          i = this.logarithmic;\n        "logarithmic" !== e.type ? this.logarithmic = void 0 : i || (i = this.logarithmic = new l(this));\n      }\n      function i() {\n        let t = this.logarithmic;\n        t && (this.lin2val = function (e) {\n          return t.lin2log(e);\n        }, this.val2lin = function (e) {\n          return t.log2lin(e);\n        });\n      }\n      t.compose = function t(r) {\n        return n(s, t) && (r.keepProps.push("logarithmic"), o(r, "init", e), o(r, "afterInit", i)), r;\n      };\n      class l {\n        constructor(t) {\n          this.axis = t;\n        }\n        getLogTickPositions(t, e, i, s) {\n          let o = this.axis,\n            n = o.len,\n            l = o.options,\n            h = [];\n          if (s || (this.minorAutoInterval = void 0), t >= .5) t = Math.round(t), h = o.getLinearTickPositions(t, e, i);else if (t >= .08) {\n            let o, r, a, n, l, d, c;\n            let p = Math.floor(e);\n            for (o = t > .3 ? [1, 2, 4] : t > .15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9], r = p; r < i + 1 && !c; r++) for (a = 0, n = o.length; a < n && !c; a++) (l = this.log2lin(this.lin2log(r) * o[a])) > e && (!s || d <= i) && void 0 !== d && h.push(d), d > i && (c = !0), d = l;\n          } else {\n            let d = this.lin2log(e),\n              c = this.lin2log(i),\n              p = s ? o.getMinorTickInterval() : l.tickInterval,\n              u = "auto" === p ? null : p,\n              g = l.tickPixelInterval / (s ? 5 : 1),\n              f = s ? n / o.tickPositions.length : n;\n            t = r(t = a(u, this.minorAutoInterval, (c - d) * g / (f || 1))), h = o.getLinearTickPositions(t, d, c).map(this.log2lin), s || (this.minorAutoInterval = t / 5);\n          }\n          return s || (o.tickInterval = t), h;\n        }\n        lin2log(t) {\n          return Math.pow(10, t);\n        }\n        log2lin(t) {\n          return Math.log(t) / Math.LN10;\n        }\n      }\n      t.Additions = l;\n    }(i || (i = {})), i;\n  }), i(e, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e) {\n    var i;\n    let {\n        composed: s\n      } = t,\n      {\n        erase: o,\n        extend: r,\n        isNumber: a,\n        pushUnique: n\n      } = e;\n    return function (t) {\n      let e;\n      function i(t) {\n        return this.addPlotBandOrLine(t, "plotBands");\n      }\n      function l(t, i) {\n        let s = this.userOptions,\n          o = new e(this, t);\n        if (this.visible && (o = o.render()), o) {\n          if (this._addedPlotLB || (this._addedPlotLB = !0, (s.plotLines || []).concat(s.plotBands || []).forEach(t => {\n            this.addPlotBandOrLine(t);\n          })), i) {\n            let e = s[i] || [];\n            e.push(t), s[i] = e;\n          }\n          this.plotLinesAndBands.push(o);\n        }\n        return o;\n      }\n      function h(t) {\n        return this.addPlotBandOrLine(t, "plotLines");\n      }\n      function d(t, e, i) {\n        i = i || this.options;\n        let s = this.getPlotLinePath({\n            value: e,\n            force: !0,\n            acrossPanes: i.acrossPanes\n          }),\n          o = [],\n          r = this.horiz,\n          n = !a(this.min) || !a(this.max) || t < this.min && e < this.min || t > this.max && e > this.max,\n          l = this.getPlotLinePath({\n            value: t,\n            force: !0,\n            acrossPanes: i.acrossPanes\n          }),\n          h,\n          d = 1,\n          c;\n        if (l && s) for (n && (c = l.toString() === s.toString(), d = 0), h = 0; h < l.length; h += 2) {\n          let t = l[h],\n            e = l[h + 1],\n            i = s[h],\n            a = s[h + 1];\n          ("M" === t[0] || "L" === t[0]) && ("M" === e[0] || "L" === e[0]) && ("M" === i[0] || "L" === i[0]) && ("M" === a[0] || "L" === a[0]) && (r && i[1] === t[1] ? (i[1] += d, a[1] += d) : r || i[2] !== t[2] || (i[2] += d, a[2] += d), o.push(["M", t[1], t[2]], ["L", e[1], e[2]], ["L", a[1], a[2]], ["L", i[1], i[2]], ["Z"])), o.isFlat = c;\n        }\n        return o;\n      }\n      function c(t) {\n        this.removePlotBandOrLine(t);\n      }\n      function p(t) {\n        let e = this.plotLinesAndBands,\n          i = this.options,\n          s = this.userOptions;\n        if (e) {\n          let r = e.length;\n          for (; r--;) e[r].id === t && e[r].destroy();\n          [i.plotLines || [], s.plotLines || [], i.plotBands || [], s.plotBands || []].forEach(function (e) {\n            for (r = e.length; r--;) (e[r] || {}).id === t && o(e, e[r]);\n          });\n        }\n      }\n      function u(t) {\n        this.removePlotBandOrLine(t);\n      }\n      t.compose = function t(o, a) {\n        return n(s, t) && (e = o, r(a.prototype, {\n          addPlotBand: i,\n          addPlotLine: h,\n          addPlotBandOrLine: l,\n          getPlotBandPath: d,\n          removePlotBand: c,\n          removePlotLine: u,\n          removePlotBandOrLine: p\n        })), a;\n      };\n    }(i || (i = {})), i;\n  }), i(e, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [e["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], e["Core/Utilities.js"]], function (t, e) {\n    let {\n      arrayMax: i,\n      arrayMin: s,\n      defined: o,\n      destroyObjectProperties: r,\n      erase: a,\n      fireEvent: n,\n      merge: l,\n      objectEach: h,\n      pick: d\n    } = e;\n    class c {\n      static compose(e) {\n        return t.compose(c, e);\n      }\n      constructor(t, e) {\n        this.axis = t, this.options = e, this.id = e.id;\n      }\n      render() {\n        n(this, "render");\n        let {\n            axis: t,\n            options: e\n          } = this,\n          {\n            horiz: i,\n            logarithmic: s\n          } = t,\n          {\n            color: r,\n            events: a,\n            zIndex: c = 0\n          } = e,\n          p = {},\n          u = t.chart.renderer,\n          g = e.to,\n          f = e.from,\n          m = e.value,\n          x = e.borderWidth,\n          y = e.label,\n          {\n            label: b,\n            svgElem: v\n          } = this,\n          M = [],\n          S,\n          k = o(f) && o(g),\n          C = o(m),\n          A = !v,\n          w = {\n            class: "highcharts-plot-" + (k ? "band " : "line ") + (e.className || "")\n          },\n          T = k ? "bands" : "lines";\n        if (!t.chart.styledMode && (C ? (w.stroke = r || "#999999", w["stroke-width"] = d(e.width, 1), e.dashStyle && (w.dashstyle = e.dashStyle)) : k && (w.fill = r || "#e6e9ff", x && (w.stroke = e.borderColor, w["stroke-width"] = x))), p.zIndex = c, T += "-" + c, (S = t.plotLinesAndBandsGroups[T]) || (t.plotLinesAndBandsGroups[T] = S = u.g("plot-" + T).attr(p).add()), v || (this.svgElem = v = u.path().attr(w).add(S)), o(m)) M = t.getPlotLinePath({\n          value: s?.log2lin(m) ?? m,\n          lineWidth: v.strokeWidth(),\n          acrossPanes: e.acrossPanes\n        });else {\n          if (!(o(f) && o(g))) return;\n          M = t.getPlotBandPath(s?.log2lin(f) ?? f, s?.log2lin(g) ?? g, e);\n        }\n        return !this.eventsAdded && a && (h(a, (t, e) => {\n          v?.on(e, function (t) {\n            a[e].apply(this, [t]);\n          });\n        }), this.eventsAdded = !0), (A || !v.d) && M?.length ? v.attr({\n          d: M\n        }) : v && (M ? (v.show(), v.animate({\n          d: M\n        })) : v.d && (v.hide(), b && (this.label = b = b.destroy()))), y && (o(y.text) || o(y.formatter)) && M?.length && t.width > 0 && t.height > 0 && !M.isFlat ? (y = l({\n          align: i && k && "center",\n          x: i ? !k && 4 : 10,\n          verticalAlign: !i && k && "middle",\n          y: i ? k ? 16 : 10 : k ? 6 : -4,\n          rotation: i && !k && 90\n        }, y), this.renderLabel(y, M, k, c)) : b && b.hide(), this;\n      }\n      renderLabel(t, e, o, r) {\n        let a = this.axis,\n          n = a.chart.renderer,\n          h = this.label;\n        h || (this.label = h = n.text(this.getLabelText(t), 0, 0, t.useHTML).attr({\n          align: t.textAlign || t.align,\n          rotation: t.rotation,\n          class: "highcharts-plot-" + (o ? "band" : "line") + "-label" + (t.className || ""),\n          zIndex: r\n        }), a.chart.styledMode || h.css(l({\n          fontSize: "0.8em",\n          textOverflow: "ellipsis"\n        }, t.style)), h.add());\n        let d = e.xBounds || [e[0][1], e[1][1], o ? e[2][1] : e[0][1]],\n          c = e.yBounds || [e[0][2], e[1][2], o ? e[2][2] : e[0][2]],\n          p = s(d),\n          u = s(c);\n        if (h.align(t, !1, {\n          x: p,\n          y: u,\n          width: i(d) - p,\n          height: i(c) - u\n        }), !h.alignValue || "left" === h.alignValue) {\n          let e = t.clip ? a.width : a.chart.chartWidth;\n          h.css({\n            width: (90 === h.rotation ? a.height - (h.alignAttr.y - a.top) : e - (h.alignAttr.x - a.left)) + "px"\n          });\n        }\n        h.show(!0);\n      }\n      getLabelText(t) {\n        return o(t.formatter) ? t.formatter.call(this) : t.text;\n      }\n      destroy() {\n        a(this.axis.plotLinesAndBands, this), delete this.axis, r(this);\n      }\n    }\n    return c;\n  }), i(e, "Core/Tooltip.js", [e["Core/Templating.js"], e["Core/Globals.js"], e["Core/Renderer/RendererUtilities.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s, o) {\n    var r;\n    let {\n        format: a\n      } = t,\n      {\n        composed: n,\n        doc: l,\n        isSafari: h\n      } = e,\n      {\n        distribute: d\n      } = i,\n      {\n        addEvent: c,\n        clamp: p,\n        css: u,\n        discardElement: g,\n        extend: f,\n        fireEvent: m,\n        isArray: x,\n        isNumber: y,\n        isString: b,\n        merge: v,\n        pick: M,\n        pushUnique: S,\n        splat: k,\n        syncTimeout: C\n      } = o;\n    class A {\n      constructor(t, e) {\n        this.allowShared = !0, this.crosshairs = [], this.distance = 0, this.isHidden = !0, this.isSticky = !1, this.now = {}, this.options = {}, this.outside = !1, this.chart = t, this.init(t, e);\n      }\n      bodyFormatter(t) {\n        return t.map(function (t) {\n          let e = t.series.tooltipOptions;\n          return (e[(t.point.formatPrefix || "point") + "Formatter"] || t.point.tooltipFormatter).call(t.point, e[(t.point.formatPrefix || "point") + "Format"] || "");\n        });\n      }\n      cleanSplit(t) {\n        this.chart.series.forEach(function (e) {\n          let i = e && e.tt;\n          i && (!i.isActive || t ? e.tt = i.destroy() : i.isActive = !1);\n        });\n      }\n      defaultFormatter(t) {\n        let e;\n        let i = this.points || k(this);\n        return (e = (e = [t.tooltipFooterHeaderFormatter(i[0])]).concat(t.bodyFormatter(i))).push(t.tooltipFooterHeaderFormatter(i[0], !0)), e;\n      }\n      destroy() {\n        this.label && (this.label = this.label.destroy()), this.split && (this.cleanSplit(!0), this.tt && (this.tt = this.tt.destroy())), this.renderer && (this.renderer = this.renderer.destroy(), g(this.container)), o.clearTimeout(this.hideTimer), o.clearTimeout(this.tooltipTimeout);\n      }\n      getAnchor(t, e) {\n        let i;\n        let s = this.chart,\n          o = s.pointer,\n          r = s.inverted,\n          a = s.plotTop,\n          n = s.plotLeft;\n        if ((t = k(t))[0].series && t[0].series.yAxis && !t[0].series.yAxis.options.reversedStacks && (t = t.slice().reverse()), this.followPointer && e) void 0 === e.chartX && (e = o.normalize(e)), i = [e.chartX - n, e.chartY - a];else if (t[0].tooltipPos) i = t[0].tooltipPos;else {\n          let s = 0,\n            o = 0;\n          t.forEach(function (t) {\n            let e = t.pos(!0);\n            e && (s += e[0], o += e[1]);\n          }), s /= t.length, o /= t.length, this.shared && t.length > 1 && e && (r ? s = e.chartX : o = e.chartY), i = [s - n, o - a];\n        }\n        return i.map(Math.round);\n      }\n      getClassName(t, e, i) {\n        let s = this.options,\n          o = t.series,\n          r = o.options;\n        return [s.className, "highcharts-label", i && "highcharts-tooltip-header", e ? "highcharts-tooltip-box" : "highcharts-tooltip", !i && "highcharts-color-" + M(t.colorIndex, o.colorIndex), r && r.className].filter(b).join(" ");\n      }\n      getLabel() {\n        let t = this,\n          i = this.chart.styledMode,\n          o = this.options,\n          r = this.split && this.allowShared,\n          a = this.container,\n          n = this.chart.renderer;\n        if (this.label) {\n          let t = !this.label.hasClass("highcharts-label");\n          (!r && t || r && !t) && this.destroy();\n        }\n        if (!this.label) {\n          if (this.outside) {\n            let t = this.chart.options.chart.style,\n              i = s.getRendererType();\n            this.container = a = e.doc.createElement("div"), a.className = "highcharts-tooltip-container", u(a, {\n              position: "absolute",\n              top: "1px",\n              pointerEvents: "none",\n              zIndex: Math.max(this.options.style.zIndex || 0, (t && t.zIndex || 0) + 3)\n            }), this.renderer = n = new i(a, 0, 0, t, void 0, void 0, n.styledMode);\n          }\n          if (r ? this.label = n.g("tooltip") : (this.label = n.label("", 0, 0, o.shape, void 0, void 0, o.useHTML, void 0, "tooltip").attr({\n            padding: o.padding,\n            r: o.borderRadius\n          }), i || this.label.attr({\n            fill: o.backgroundColor,\n            "stroke-width": o.borderWidth || 0\n          }).css(o.style).css({\n            pointerEvents: o.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none")\n          })), t.outside) {\n            let e = this.label,\n              {\n                xSetter: i,\n                ySetter: s\n              } = e;\n            e.xSetter = function (s) {\n              i.call(e, t.distance), a && (a.style.left = s + "px");\n            }, e.ySetter = function (i) {\n              s.call(e, t.distance), a && (a.style.top = i + "px");\n            };\n          }\n          this.label.attr({\n            zIndex: 8\n          }).shadow(o.shadow).add();\n        }\n        return a && !a.parentElement && e.doc.body.appendChild(a), this.label;\n      }\n      getPlayingField() {\n        let {\n            body: t,\n            documentElement: e\n          } = l,\n          {\n            chart: i,\n            distance: s,\n            outside: o\n          } = this;\n        return {\n          width: o ? Math.max(t.scrollWidth, e.scrollWidth, t.offsetWidth, e.offsetWidth, e.clientWidth) - 2 * s : i.chartWidth,\n          height: o ? Math.max(t.scrollHeight, e.scrollHeight, t.offsetHeight, e.offsetHeight, e.clientHeight) : i.chartHeight\n        };\n      }\n      getPosition(t, e, i) {\n        let {\n            distance: s,\n            chart: o,\n            outside: r\n          } = this,\n          {\n            inverted: a,\n            plotLeft: n,\n            plotTop: l,\n            polar: h\n          } = o,\n          {\n            plotX: d = 0,\n            plotY: c = 0\n          } = i,\n          p = {},\n          u = a && i.h || 0,\n          {\n            height: g,\n            width: f\n          } = this.getPlayingField(),\n          m = o.pointer.getChartPosition(),\n          x = t => t * m.scaleX,\n          y = t => t * m.scaleY,\n          b = i => {\n            let a = "x" === i;\n            return [i, a ? f : g, a ? t : e].concat(r ? [a ? x(t) : y(e), a ? m.left - s + x(d + n) : m.top - s + y(c + l), 0, a ? f : g] : [a ? t : e, a ? d + n : c + l, a ? n : l, a ? n + o.plotWidth : l + o.plotHeight]);\n          },\n          v = b("y"),\n          S = b("x"),\n          k,\n          C = !!i.negative;\n        !h && o.hoverSeries?.yAxis?.reversed && (C = !C);\n        let A = !this.followPointer && M(i.ttBelow, !h && !a === C),\n          w = function (t, e, i, o, a, n, l) {\n            let h = r ? "y" === t ? y(s) : x(s) : s,\n              d = (i - o) / 2,\n              c = o < a - s,\n              g = a + s + o < e,\n              f = a - h - i + d,\n              m = a + h - d;\n            if (A && g) p[t] = m;else if (!A && c) p[t] = f;else if (c) p[t] = Math.min(l - o, f - u < 0 ? f : f - u);else {\n              if (!g) return !1;\n              p[t] = Math.max(n, m + u + i > e ? m : m + u);\n            }\n          },\n          T = function (t, e, i, o, r) {\n            if (r < s || r > e - s) return !1;\n            r < i / 2 ? p[t] = 1 : r > e - o / 2 ? p[t] = e - o - 2 : p[t] = r - i / 2;\n          },\n          P = function (t) {\n            [v, S] = [S, v], k = t;\n          },\n          L = () => {\n            !1 !== w.apply(0, v) ? !1 !== T.apply(0, S) || k || (P(!0), L()) : k ? p.x = p.y = 0 : (P(!0), L());\n          };\n        return (a && !h || this.len > 1) && P(), L(), p;\n      }\n      hide(t) {\n        let e = this;\n        o.clearTimeout(this.hideTimer), t = M(t, this.options.hideDelay), this.isHidden || (this.hideTimer = C(function () {\n          let i = e.getLabel();\n          e.getLabel().animate({\n            opacity: 0\n          }, {\n            duration: t ? 150 : t,\n            complete: () => {\n              i.hide(), e.container && e.container.remove();\n            }\n          }), e.isHidden = !0;\n        }, t));\n      }\n      init(t, e) {\n        this.chart = t, this.options = e, this.crosshairs = [], this.now = {\n          x: 0,\n          y: 0\n        }, this.isHidden = !0, this.split = e.split && !t.inverted && !t.polar, this.shared = e.shared || this.split, this.outside = M(e.outside, !!(t.scrollablePixelsX || t.scrollablePixelsY));\n      }\n      shouldStickOnContact(t) {\n        return !!(!this.followPointer && this.options.stickOnContact && (!t || this.chart.pointer.inClass(t.target, "highcharts-tooltip")));\n      }\n      move(t, e, i, s) {\n        let r = this,\n          a = r.now,\n          n = !1 !== r.options.animation && !r.isHidden && (Math.abs(t - a.x) > 1 || Math.abs(e - a.y) > 1),\n          l = r.followPointer || r.len > 1;\n        f(a, {\n          x: n ? (2 * a.x + t) / 3 : t,\n          y: n ? (a.y + e) / 2 : e,\n          anchorX: l ? void 0 : n ? (2 * a.anchorX + i) / 3 : i,\n          anchorY: l ? void 0 : n ? (a.anchorY + s) / 2 : s\n        }), r.getLabel().attr(a), r.drawTracker(), n && (o.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          r && r.move(t, e, i, s);\n        }, 32));\n      }\n      refresh(t, e) {\n        let i = this.chart,\n          s = this.options,\n          r = i.pointer,\n          n = k(t),\n          l = n[0],\n          h = [],\n          d = s.format,\n          c = s.formatter || this.defaultFormatter,\n          p = this.shared,\n          u = i.styledMode,\n          g = {};\n        if (!s.enabled || !l.series) return;\n        o.clearTimeout(this.hideTimer), this.allowShared = !(!x(t) && t.series && t.series.noSharedTooltip), this.followPointer = !this.split && l.series.tooltipOptions.followPointer;\n        let f = this.getAnchor(t, e),\n          y = f[0],\n          v = f[1];\n        p && this.allowShared ? (r.applyInactiveState(n), n.forEach(function (t) {\n          t.setState("hover"), h.push(t.getLabelConfig());\n        }), (g = l.getLabelConfig()).points = h) : g = l.getLabelConfig(), this.len = h.length;\n        let S = b(d) ? a(d, g, i) : c.call(g, this),\n          C = l.series;\n        if (this.distance = M(C.tooltipOptions.distance, 16), !1 === S) this.hide();else {\n          if (this.split && this.allowShared) this.renderSplit(S, n);else {\n            let t = y,\n              o = v;\n            if (e && r.isDirectTouch && (t = e.chartX - i.plotLeft, o = e.chartY - i.plotTop), i.polar || !1 === C.options.clip || n.some(e => r.isDirectTouch || e.series.shouldShowTooltip(t, o))) {\n              let t = this.getLabel();\n              (!s.style.width || u) && t.css({\n                width: (this.outside ? this.getPlayingField() : i.spacingBox).width + "px"\n              }), t.attr({\n                text: S && S.join ? S.join("") : S\n              }), t.addClass(this.getClassName(l), !0), u || t.attr({\n                stroke: s.borderColor || l.color || C.color || "#666666"\n              }), this.updatePosition({\n                plotX: y,\n                plotY: v,\n                negative: l.negative,\n                ttBelow: l.ttBelow,\n                h: f[2] || 0\n              });\n            } else {\n              this.hide();\n              return;\n            }\n          }\n          this.isHidden && this.label && this.label.attr({\n            opacity: 1\n          }).show(), this.isHidden = !1;\n        }\n        m(this, "refresh");\n      }\n      renderSplit(t, e) {\n        let i = this,\n          {\n            chart: s,\n            chart: {\n              chartWidth: o,\n              chartHeight: r,\n              plotHeight: a,\n              plotLeft: n,\n              plotTop: c,\n              pointer: u,\n              scrollablePixelsY: g = 0,\n              scrollablePixelsX: m,\n              scrollingContainer: {\n                scrollLeft: x,\n                scrollTop: y\n              } = {\n                scrollLeft: 0,\n                scrollTop: 0\n              },\n              styledMode: v\n            },\n            distance: S,\n            options: k,\n            options: {\n              positioner: C\n            }\n          } = i,\n          A = i.outside && "number" != typeof m ? l.documentElement.getBoundingClientRect() : {\n            left: x,\n            right: x + o,\n            top: y,\n            bottom: y + r\n          },\n          w = i.getLabel(),\n          T = this.renderer || s.renderer,\n          P = !!(s.xAxis[0] && s.xAxis[0].opposite),\n          {\n            left: L,\n            top: D\n          } = u.getChartPosition(),\n          O = c + y,\n          E = 0,\n          B = a - g;\n        function j(t, e, s, o, r = !0) {\n          let a, n;\n          return s ? (a = P ? 0 : B, n = p(t - o / 2, A.left, A.right - o - (i.outside ? L : 0))) : (a = e - O, n = p(n = r ? t - o - S : t + S, r ? n : A.left, A.right)), {\n            x: n,\n            y: a\n          };\n        }\n        b(t) && (t = [!1, t]);\n        let I = t.slice(0, e.length + 1).reduce(function (t, s, o) {\n          if (!1 !== s && "" !== s) {\n            let r = e[o - 1] || {\n                isHeader: !0,\n                plotX: e[0].plotX,\n                plotY: a,\n                series: {}\n              },\n              l = r.isHeader,\n              h = l ? i : r.series,\n              d = h.tt = function (t, e, s) {\n                let o = t,\n                  {\n                    isHeader: r,\n                    series: a\n                  } = e;\n                if (!o) {\n                  let t = {\n                    padding: k.padding,\n                    r: k.borderRadius\n                  };\n                  v || (t.fill = k.backgroundColor, t["stroke-width"] = k.borderWidth ?? 1), o = T.label("", 0, 0, k[r ? "headerShape" : "shape"], void 0, void 0, k.useHTML).addClass(i.getClassName(e, !0, r)).attr(t).add(w);\n                }\n                return o.isActive = !0, o.attr({\n                  text: s\n                }), v || o.css(k.style).attr({\n                  stroke: k.borderColor || e.color || a.color || "#333333"\n                }), o;\n              }(h.tt, r, s.toString()),\n              u = d.getBBox(),\n              g = u.width + d.strokeWidth();\n            l && (E = u.height, B += E, P && (O -= E));\n            let {\n              anchorX: f,\n              anchorY: m\n            } = function (t) {\n              let e, i;\n              let {\n                isHeader: s,\n                plotX: o = 0,\n                plotY: r = 0,\n                series: l\n              } = t;\n              if (s) e = Math.max(n + o, n), i = c + a / 2;else {\n                let {\n                  xAxis: t,\n                  yAxis: s\n                } = l;\n                e = t.pos + p(o, -S, t.len + S), l.shouldShowTooltip(0, s.pos - c + r, {\n                  ignoreX: !0\n                }) && (i = s.pos + r);\n              }\n              return {\n                anchorX: e = p(e, A.left - S, A.right + S),\n                anchorY: i\n              };\n            }(r);\n            if ("number" == typeof m) {\n              let e = u.height + 1,\n                s = C ? C.call(i, g, e, r) : j(f, m, l, g);\n              t.push({\n                align: C ? 0 : void 0,\n                anchorX: f,\n                anchorY: m,\n                boxWidth: g,\n                point: r,\n                rank: M(s.rank, l ? 1 : 0),\n                size: e,\n                target: s.y,\n                tt: d,\n                x: s.x\n              });\n            } else d.isActive = !1;\n          }\n          return t;\n        }, []);\n        !C && I.some(t => {\n          let {\n              outside: e\n            } = i,\n            s = (e ? L : 0) + t.anchorX;\n          return s < A.left && s + t.boxWidth < A.right || s < L - A.left + t.boxWidth && A.right - s > s;\n        }) && (I = I.map(t => {\n          let {\n            x: e,\n            y: i\n          } = j(t.anchorX, t.anchorY, t.point.isHeader, t.boxWidth, !1);\n          return f(t, {\n            target: i,\n            x: e\n          });\n        })), i.cleanSplit(), d(I, B);\n        let R = {\n          left: L,\n          right: L\n        };\n        I.forEach(function (t) {\n          let {\n            x: e,\n            boxWidth: s,\n            isHeader: o\n          } = t;\n          !o && (i.outside && L + e < R.left && (R.left = L + e), !o && i.outside && R.left + s > R.right && (R.right = L + e));\n        }), I.forEach(function (t) {\n          let {\n              x: e,\n              anchorX: s,\n              anchorY: o,\n              pos: r,\n              point: {\n                isHeader: a\n              }\n            } = t,\n            n = {\n              visibility: void 0 === r ? "hidden" : "inherit",\n              x: e,\n              y: (r || 0) + O,\n              anchorX: s,\n              anchorY: o\n            };\n          if (i.outside && e < s) {\n            let t = L - R.left;\n            t > 0 && (a || (n.x = e + t, n.anchorX = s + t), a && (n.x = (R.right - R.left) / 2, n.anchorX = s + t));\n          }\n          t.tt.attr(n);\n        });\n        let {\n          container: z,\n          outside: G,\n          renderer: W\n        } = i;\n        if (G && z && W) {\n          let {\n            width: t,\n            height: e,\n            x: i,\n            y: s\n          } = w.getBBox();\n          W.setSize(t + i, e + s, !1), z.style.left = R.left + "px", z.style.top = D + "px";\n        }\n        h && w.attr({\n          opacity: 1 === w.opacity ? .999 : 1\n        });\n      }\n      drawTracker() {\n        if (!this.shouldStickOnContact()) {\n          this.tracker && (this.tracker = this.tracker.destroy());\n          return;\n        }\n        let t = this.chart,\n          e = this.label,\n          i = this.shared ? t.hoverPoints : t.hoverPoint;\n        if (!e || !i) return;\n        let s = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n          },\n          o = this.getAnchor(i),\n          r = e.getBBox();\n        o[0] += t.plotLeft - (e.translateX || 0), o[1] += t.plotTop - (e.translateY || 0), s.x = Math.min(0, o[0]), s.y = Math.min(0, o[1]), s.width = o[0] < 0 ? Math.max(Math.abs(o[0]), r.width - o[0]) : Math.max(Math.abs(o[0]), r.width), s.height = o[1] < 0 ? Math.max(Math.abs(o[1]), r.height - Math.abs(o[1])) : Math.max(Math.abs(o[1]), r.height), this.tracker ? this.tracker.attr(s) : (this.tracker = e.renderer.rect(s).addClass("highcharts-tracker").add(e), t.styledMode || this.tracker.attr({\n          fill: "rgba(0,0,0,0)"\n        }));\n      }\n      styledModeFormat(t) {\n        return t.replace(\'style="font-size: 0.8em"\', \'class="highcharts-header"\').replace(/style="color:{(point|series)\\.color}"/g, \'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"\');\n      }\n      tooltipFooterHeaderFormatter(t, e) {\n        let i = t.series,\n          s = i.tooltipOptions,\n          o = i.xAxis,\n          r = o && o.dateTime,\n          n = {\n            isFooter: e,\n            labelConfig: t\n          },\n          l = s.xDateFormat,\n          h = s[e ? "footerFormat" : "headerFormat"];\n        return m(this, "headerFormatter", n, function (e) {\n          r && !l && y(t.key) && (l = r.getXDateFormat(t.key, s.dateTimeLabelFormats)), r && l && (t.point && t.point.tooltipDateKeys || ["key"]).forEach(function (t) {\n            h = h.replace("{point." + t + "}", "{point." + t + ":" + l + "}");\n          }), i.chart.styledMode && (h = this.styledModeFormat(h)), e.text = a(h, {\n            point: t,\n            series: i\n          }, this.chart);\n        }), n.text;\n      }\n      update(t) {\n        this.destroy(), this.init(this.chart, v(!0, this.options, t));\n      }\n      updatePosition(t) {\n        let {\n            chart: e,\n            container: i,\n            distance: s,\n            options: o,\n            renderer: r\n          } = this,\n          {\n            height: a = 0,\n            width: n = 0\n          } = this.getLabel(),\n          l = e.pointer,\n          {\n            left: h,\n            top: d,\n            scaleX: c,\n            scaleY: p\n          } = l.getChartPosition(),\n          g = (o.positioner || this.getPosition).call(this, n, a, t),\n          f = (t.plotX || 0) + e.plotLeft,\n          m = (t.plotY || 0) + e.plotTop,\n          x;\n        r && i && (o.positioner && (g.x += h - s, g.y += d - s), x = (o.borderWidth || 0) + 2 * s + 2, r.setSize(n + x, a + x, !1), (1 !== c || 1 !== p) && (u(i, {\n          transform: `scale(${c}, ${p})`\n        }), f *= c, m *= p), f += h - g.x, m += d - g.y), this.move(Math.round(g.x), Math.round(g.y || 0), f, m);\n      }\n    }\n    return (r = A || (A = {})).compose = function t(e) {\n      S(n, t) && c(e, "afterInit", function () {\n        let t = this.chart;\n        t.options.tooltip && (t.tooltip = new r(t, t.options.tooltip));\n      });\n    }, A;\n  }), i(e, "Core/Series/Point.js", [e["Core/Renderer/HTML/AST.js"], e["Core/Animation/AnimationUtilities.js"], e["Core/Defaults.js"], e["Core/Templating.js"], e["Core/Utilities.js"]], function (t, e, i, s, o) {\n    let {\n        animObject: r\n      } = e,\n      {\n        defaultOptions: a\n      } = i,\n      {\n        format: n\n      } = s,\n      {\n        addEvent: l,\n        defined: h,\n        erase: d,\n        extend: c,\n        fireEvent: p,\n        getNestedProperty: u,\n        isArray: g,\n        isFunction: f,\n        isNumber: m,\n        isObject: x,\n        merge: y,\n        objectEach: b,\n        pick: v,\n        syncTimeout: M,\n        removeEvent: S,\n        uniqueKey: k\n      } = o;\n    class C {\n      animateBeforeDestroy() {\n        let t = this,\n          e = {\n            x: t.startXPos,\n            opacity: 0\n          },\n          i = t.getGraphicalProps();\n        i.singular.forEach(function (i) {\n          t[i] = t[i].animate("dataLabel" === i ? {\n            x: t[i].startXPos,\n            y: t[i].startYPos,\n            opacity: 0\n          } : e);\n        }), i.plural.forEach(function (e) {\n          t[e].forEach(function (e) {\n            e.element && e.animate(c({\n              x: t.startXPos\n            }, e.startYPos ? {\n              x: e.startXPos,\n              y: e.startYPos\n            } : {}));\n          });\n        });\n      }\n      applyOptions(t, e) {\n        let i = this.series,\n          s = i.options.pointValKey || i.pointValKey;\n        return c(this, t = C.prototype.optionsToObject.call(this, t)), this.options = this.options ? c(this.options, t) : t, t.group && delete this.group, t.dataLabels && delete this.dataLabels, s && (this.y = C.prototype.getNestedProperty.call(this, s)), this.selected && (this.state = "select"), "name" in this && void 0 === e && i.xAxis && i.xAxis.hasNames && (this.x = i.xAxis.nameToX(this)), void 0 === this.x && i ? void 0 === e ? this.x = i.autoIncrement() : this.x = e : m(t.x) && i.options.relativeXValue && (this.x = i.autoIncrement(t.x)), this.isNull = this.isValid && !this.isValid(), this.formatPrefix = this.isNull ? "null" : "point", this;\n      }\n      destroy() {\n        if (!this.destroyed) {\n          let t = this,\n            e = t.series,\n            i = e.chart,\n            s = e.options.dataSorting,\n            o = i.hoverPoints,\n            a = t.series.chart.renderer.globalAnimation,\n            n = r(a),\n            l = () => {\n              for (let e in (t.graphic || t.graphics || t.dataLabel || t.dataLabels) && (S(t), t.destroyElements()), t) delete t[e];\n            };\n          t.legendItem && i.legend.destroyItem(t), o && (t.setState(), d(o, t), o.length || (i.hoverPoints = null)), t === i.hoverPoint && t.onMouseOut(), s && s.enabled ? (this.animateBeforeDestroy(), M(l, n.duration)) : l(), i.pointCount--;\n        }\n        this.destroyed = !0;\n      }\n      destroyElements(t) {\n        let e = this,\n          i = e.getGraphicalProps(t);\n        i.singular.forEach(function (t) {\n          e[t] = e[t].destroy();\n        }), i.plural.forEach(function (t) {\n          e[t].forEach(function (t) {\n            t && t.element && t.destroy();\n          }), delete e[t];\n        });\n      }\n      firePointEvent(t, e, i) {\n        let s = this,\n          o = this.series,\n          r = o.options;\n        (r.point.events[t] || s.options && s.options.events && s.options.events[t]) && s.importEvents(), "click" === t && r.allowPointSelect && (i = function (t) {\n          !s.destroyed && s.select && s.select(null, t.ctrlKey || t.metaKey || t.shiftKey);\n        }), p(s, t, e, i);\n      }\n      getClassName() {\n        return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (void 0 !== this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");\n      }\n      getGraphicalProps(t) {\n        let e, i;\n        let s = this,\n          o = [],\n          r = {\n            singular: [],\n            plural: []\n          };\n        for ((t = t || {\n          graphic: 1,\n          dataLabel: 1\n        }).graphic && o.push("graphic", "connector"), t.dataLabel && o.push("dataLabel", "dataLabelPath", "dataLabelUpper"), i = o.length; i--;) s[e = o[i]] && r.singular.push(e);\n        return ["graphic", "dataLabel"].forEach(function (e) {\n          let i = e + "s";\n          t[e] && s[i] && r.plural.push(i);\n        }), r;\n      }\n      getLabelConfig() {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      }\n      getNestedProperty(t) {\n        return t ? 0 === t.indexOf("custom.") ? u(t, this.options) : this[t] : void 0;\n      }\n      getZone() {\n        let t = this.series,\n          e = t.zones,\n          i = t.zoneAxis || "y",\n          s,\n          o = 0;\n        for (s = e[0]; this[i] >= s.value;) s = e[++o];\n        return this.nonZonedColor || (this.nonZonedColor = this.color), s && s.color && !this.options.color ? this.color = s.color : this.color = this.nonZonedColor, s;\n      }\n      hasNewShapeType() {\n        let t = this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName);\n        return t !== this.shapeType;\n      }\n      constructor(t, e, i) {\n        this.formatPrefix = "point", this.visible = !0, this.series = t, this.applyOptions(e, i), this.id ?? (this.id = k()), this.resolveColor(), t.chart.pointCount++, p(this, "afterInit");\n      }\n      isValid() {\n        return (m(this.x) || this.x instanceof Date) && m(this.y);\n      }\n      optionsToObject(t) {\n        let e = this.series,\n          i = e.options.keys,\n          s = i || e.pointArrayMap || ["y"],\n          o = s.length,\n          r = {},\n          a,\n          n = 0,\n          l = 0;\n        if (m(t) || null === t) r[s[0]] = t;else if (g(t)) for (!i && t.length > o && ("string" == (a = typeof t[0]) ? r.name = t[0] : "number" === a && (r.x = t[0]), n++); l < o;) i && void 0 === t[n] || (s[l].indexOf(".") > 0 ? C.prototype.setNestedProperty(r, t[n], s[l]) : r[s[l]] = t[n]), n++, l++;else "object" == typeof t && (r = t, t.dataLabels && (e.hasDataLabels = () => !0), t.marker && (e._hasPointMarkers = !0));\n        return r;\n      }\n      pos(t, e = this.plotY) {\n        if (!this.destroyed) {\n          let {\n              plotX: i,\n              series: s\n            } = this,\n            {\n              chart: o,\n              xAxis: r,\n              yAxis: a\n            } = s,\n            n = 0,\n            l = 0;\n          if (m(i) && m(e)) return t && (n = r ? r.pos : o.plotLeft, l = a ? a.pos : o.plotTop), o.inverted && r && a ? [a.len - e + l, r.len - i + n] : [i + n, e + l];\n        }\n      }\n      resolveColor() {\n        let t = this.series,\n          e = t.chart.options.chart,\n          i = t.chart.styledMode,\n          s,\n          o,\n          r = e.colorCount,\n          a;\n        delete this.nonZonedColor, t.options.colorByPoint ? (i || (s = (o = t.options.colors || t.chart.options.colors)[t.colorCounter], r = o.length), a = t.colorCounter, t.colorCounter++, t.colorCounter === r && (t.colorCounter = 0)) : (i || (s = t.color), a = t.colorIndex), this.colorIndex = v(this.options.colorIndex, a), this.color = v(this.options.color, s);\n      }\n      setNestedProperty(t, e, i) {\n        let s = i.split(".");\n        return s.reduce(function (t, i, s, o) {\n          let r = o.length - 1 === s;\n          return t[i] = r ? e : x(t[i], !0) ? t[i] : {}, t[i];\n        }, t), t;\n      }\n      shouldDraw() {\n        return !this.isNull;\n      }\n      tooltipFormatter(t) {\n        let e = this.series,\n          i = e.tooltipOptions,\n          s = v(i.valueDecimals, ""),\n          o = i.valuePrefix || "",\n          r = i.valueSuffix || "";\n        return e.chart.styledMode && (t = e.chart.tooltip.styledModeFormat(t)), (e.pointArrayMap || ["y"]).forEach(function (e) {\n          e = "{point." + e, (o || r) && (t = t.replace(RegExp(e + "}", "g"), o + e + "}" + r)), t = t.replace(RegExp(e + "}", "g"), e + ":,." + s + "f}");\n        }), n(t, {\n          point: this,\n          series: this.series\n        }, e.chart);\n      }\n      update(t, e, i, s) {\n        let o;\n        let r = this,\n          a = r.series,\n          n = r.graphic,\n          l = a.chart,\n          h = a.options;\n        function d() {\n          r.applyOptions(t);\n          let s = n && r.hasMockGraphic,\n            d = null === r.y ? !s : s;\n          n && d && (r.graphic = n.destroy(), delete r.hasMockGraphic), x(t, !0) && (n && n.element && t && t.marker && void 0 !== t.marker.symbol && (r.graphic = n.destroy()), t?.dataLabels && r.dataLabel && (r.dataLabel = r.dataLabel.destroy())), o = r.index, a.updateParallelArrays(r, o), h.data[o] = x(h.data[o], !0) || x(t, !0) ? r.options : v(t, h.data[o]), a.isDirty = a.isDirtyData = !0, !a.fixedBox && a.hasCartesianSeries && (l.isDirtyBox = !0), "point" === h.legendType && (l.isDirtyLegend = !0), e && l.redraw(i);\n        }\n        e = v(e, !0), !1 === s ? d() : r.firePointEvent("update", {\n          options: t\n        }, d);\n      }\n      remove(t, e) {\n        this.series.removePoint(this.series.data.indexOf(this), t, e);\n      }\n      select(t, e) {\n        let i = this,\n          s = i.series,\n          o = s.chart;\n        t = v(t, !i.selected), this.selectedStaging = t, i.firePointEvent(t ? "select" : "unselect", {\n          accumulate: e\n        }, function () {\n          i.selected = i.options.selected = t, s.options.data[s.data.indexOf(i)] = i.options, i.setState(t && "select"), e || o.getSelectedPoints().forEach(function (t) {\n            let e = t.series;\n            t.selected && t !== i && (t.selected = t.options.selected = !1, e.options.data[e.data.indexOf(t)] = t.options, t.setState(o.hoverPoints && e.options.inactiveOtherPoints ? "inactive" : ""), t.firePointEvent("unselect"));\n          });\n        }), delete this.selectedStaging;\n      }\n      onMouseOver(t) {\n        let e = this.series,\n          i = e.chart,\n          s = i.pointer;\n        t = t ? s.normalize(t) : s.getChartCoordinatesFromPoint(this, i.inverted), s.runPointActions(t, this);\n      }\n      onMouseOut() {\n        let t = this.series.chart;\n        this.firePointEvent("mouseOut"), this.series.options.inactiveOtherPoints || (t.hoverPoints || []).forEach(function (t) {\n          t.setState();\n        }), t.hoverPoints = t.hoverPoint = null;\n      }\n      importEvents() {\n        if (!this.hasImportedEvents) {\n          let t = this,\n            e = y(t.series.options.point, t.options),\n            i = e.events;\n          t.events = i, b(i, function (e, i) {\n            f(e) && l(t, i, e);\n          }), this.hasImportedEvents = !0;\n        }\n      }\n      setState(e, i) {\n        let s = this.series,\n          o = this.state,\n          r = s.options.states[e || "normal"] || {},\n          n = a.plotOptions[s.type].marker && s.options.marker,\n          l = n && !1 === n.enabled,\n          h = n && n.states && n.states[e || "normal"] || {},\n          d = !1 === h.enabled,\n          u = this.marker || {},\n          g = s.chart,\n          f = n && s.markerAttribs,\n          x = s.halo,\n          y,\n          b,\n          M,\n          S = s.stateMarkerGraphic,\n          k;\n        if ((e = e || "") === this.state && !i || this.selected && "select" !== e || !1 === r.enabled || e && (d || l && !1 === h.enabled) || e && u.states && u.states[e] && !1 === u.states[e].enabled) return;\n        if (this.state = e, f && (y = s.markerAttribs(this, e)), this.graphic && !this.hasMockGraphic) {\n          if (o && this.graphic.removeClass("highcharts-point-" + o), e && this.graphic.addClass("highcharts-point-" + e), !g.styledMode) {\n            b = s.pointAttribs(this, e), M = v(g.options.chart.animation, r.animation);\n            let t = b.opacity;\n            s.options.inactiveOtherPoints && m(t) && (this.dataLabels || []).forEach(function (e) {\n              e && !e.hasClass("highcharts-data-label-hidden") && (e.animate({\n                opacity: t\n              }, M), e.connector && e.connector.animate({\n                opacity: t\n              }, M));\n            }), this.graphic.animate(b, M);\n          }\n          y && this.graphic.animate(y, v(g.options.chart.animation, h.animation, n.animation)), S && S.hide();\n        } else e && h && (k = u.symbol || s.symbol, S && S.currentSymbol !== k && (S = S.destroy()), y && (S ? S[i ? "animate" : "attr"]({\n          x: y.x,\n          y: y.y\n        }) : k && (s.stateMarkerGraphic = S = g.renderer.symbol(k, y.x, y.y, y.width, y.height).add(s.markerGroup), S.currentSymbol = k)), !g.styledMode && S && "inactive" !== this.state && S.attr(s.pointAttribs(this, e))), S && (S[e && this.isInside ? "show" : "hide"](), S.element.point = this, S.addClass(this.getClassName(), !0));\n        let C = r.halo,\n          A = this.graphic || S,\n          w = A && A.visibility || "inherit";\n        C && C.size && A && "hidden" !== w && !this.isCluster ? (x || (s.halo = x = g.renderer.path().add(A.parentGroup)), x.show()[i ? "animate" : "attr"]({\n          d: this.haloPath(C.size)\n        }), x.attr({\n          class: "highcharts-halo highcharts-color-" + v(this.colorIndex, s.colorIndex) + (this.className ? " " + this.className : ""),\n          visibility: w,\n          zIndex: -1\n        }), x.point = this, g.styledMode || x.attr(c({\n          fill: this.color || s.color,\n          "fill-opacity": C.opacity\n        }, t.filterUserAttributes(C.attributes || {})))) : x && x.point && x.point.haloPath && x.animate({\n          d: x.point.haloPath(0)\n        }, null, x.hide), p(this, "afterSetState", {\n          state: e\n        });\n      }\n      haloPath(t) {\n        let e = this.pos();\n        return e ? this.series.chart.renderer.symbols.circle(Math.floor(e[0]) - t, e[1] - t, 2 * t, 2 * t) : [];\n      }\n    }\n    return C;\n  }), i(e, "Core/Pointer.js", [e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e, i) {\n    var s;\n    let {\n        parse: o\n      } = t,\n      {\n        charts: r,\n        composed: a,\n        noop: n\n      } = e,\n      {\n        addEvent: l,\n        attr: h,\n        css: d,\n        defined: c,\n        extend: p,\n        find: u,\n        fireEvent: g,\n        isNumber: f,\n        isObject: m,\n        objectEach: x,\n        offset: y,\n        pick: b,\n        pushUnique: v,\n        splat: M\n      } = i;\n    class S {\n      applyInactiveState(t) {\n        let e = [],\n          i;\n        (t || []).forEach(function (t) {\n          i = t.series, e.push(i), i.linkedParent && e.push(i.linkedParent), i.linkedSeries && (e = e.concat(i.linkedSeries)), i.navigatorSeries && e.push(i.navigatorSeries);\n        }), this.chart.series.forEach(function (t) {\n          -1 === e.indexOf(t) ? t.setState("inactive", !0) : t.options.inactiveOtherPoints && t.setAllPointsToState("inactive");\n        });\n      }\n      destroy() {\n        let t = this;\n        this.eventsToUnbind.forEach(t => t()), this.eventsToUnbind = [], !e.chartCount && (S.unbindDocumentMouseUp && (S.unbindDocumentMouseUp = S.unbindDocumentMouseUp()), S.unbindDocumentTouchEnd && (S.unbindDocumentTouchEnd = S.unbindDocumentTouchEnd())), clearInterval(t.tooltipTimeout), x(t, function (e, i) {\n          t[i] = void 0;\n        });\n      }\n      getSelectionMarkerAttrs(t, e) {\n        let i = {\n          args: {\n            chartX: t,\n            chartY: e\n          },\n          attrs: {},\n          shapeType: "rect"\n        };\n        return g(this, "getSelectionMarkerAttrs", i, i => {\n          let s;\n          let {\n              chart: o,\n              mouseDownX: r = 0,\n              mouseDownY: a = 0,\n              zoomHor: n,\n              zoomVert: l\n            } = this,\n            h = i.attrs;\n          h.x = o.plotLeft, h.y = o.plotTop, h.width = n ? 1 : o.plotWidth, h.height = l ? 1 : o.plotHeight, n && (s = t - r, h.width = Math.abs(s), h.x = (s > 0 ? 0 : s) + r), l && (s = e - a, h.height = Math.abs(s), h.y = (s > 0 ? 0 : s) + a);\n        }), i;\n      }\n      drag(t) {\n        let e = this.chart,\n          i = e.options.chart,\n          s = e.plotLeft,\n          r = e.plotTop,\n          a = e.plotWidth,\n          n = e.plotHeight,\n          l = this.mouseDownX || 0,\n          h = this.mouseDownY || 0,\n          d = m(i.panning) ? i.panning && i.panning.enabled : i.panning,\n          c = i.panKey && t[i.panKey + "Key"],\n          p = t.chartX,\n          u = t.chartY,\n          g,\n          f = this.selectionMarker;\n        if ((!f || !f.touch) && (p < s ? p = s : p > s + a && (p = s + a), u < r ? u = r : u > r + n && (u = r + n), this.hasDragged = Math.sqrt(Math.pow(l - p, 2) + Math.pow(h - u, 2)), this.hasDragged > 10)) {\n          g = e.isInsidePlot(l - s, h - r, {\n            visiblePlotOnly: !0\n          });\n          let {\n            shapeType: a,\n            attrs: n\n          } = this.getSelectionMarkerAttrs(p, u);\n          (e.hasCartesianSeries || e.mapView) && (this.zoomX || this.zoomY) && g && !c && !f && (this.selectionMarker = f = e.renderer[a](), f.attr({\n            class: "highcharts-selection-marker",\n            zIndex: 7\n          }).add(), e.styledMode || f.attr({\n            fill: i.selectionMarkerFill || o("#334eff").setOpacity(.25).get()\n          })), f && f.attr(n), g && !f && d && e.pan(t, i.panning);\n        }\n      }\n      dragStart(t) {\n        let e = this.chart;\n        e.mouseIsDown = t.type, e.cancelClick = !1, e.mouseDownX = this.mouseDownX = t.chartX, e.mouseDownY = this.mouseDownY = t.chartY;\n      }\n      getSelectionBox(t) {\n        let e = {\n          args: {\n            marker: t\n          },\n          result: {}\n        };\n        return g(this, "getSelectionBox", e, e => {\n          e.result = {\n            x: t.attr ? +t.attr("x") : t.x,\n            y: t.attr ? +t.attr("y") : t.y,\n            width: t.attr ? t.attr("width") : t.width,\n            height: t.attr ? t.attr("height") : t.height\n          };\n        }), e.result;\n      }\n      drop(t) {\n        let e = this,\n          i = this.chart,\n          s = this.hasPinched;\n        if (this.selectionMarker) {\n          let {\n              x: o,\n              y: r,\n              width: a,\n              height: n\n            } = this.getSelectionBox(this.selectionMarker),\n            l = {\n              originalEvent: t,\n              xAxis: [],\n              yAxis: [],\n              x: o,\n              y: r,\n              width: a,\n              height: n\n            },\n            h = !!i.mapView;\n          (this.hasDragged || s) && (i.axes.forEach(function (i) {\n            if (i.zoomEnabled && c(i.min) && (s || e[{\n              xAxis: "zoomX",\n              yAxis: "zoomY"\n            }[i.coll]]) && f(o) && f(r) && f(a) && f(n)) {\n              let e = i.horiz,\n                s = "touchend" === t.type ? i.minPixelPadding : 0,\n                d = i.toValue((e ? o : r) + s),\n                c = i.toValue((e ? o + a : r + n) - s);\n              l[i.coll].push({\n                axis: i,\n                min: Math.min(d, c),\n                max: Math.max(d, c)\n              }), h = !0;\n            }\n          }), h && g(i, "selection", l, function (t) {\n            i.zoom(p(t, s ? {\n              animation: !1\n            } : null));\n          })), f(i.index) && (this.selectionMarker = this.selectionMarker.destroy()), s && this.scaleGroups();\n        }\n        i && f(i.index) && (d(i.container, {\n          cursor: i._cursor\n        }), i.cancelClick = +this.hasDragged > 10, i.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      }\n      findNearestKDPoint(t, e, i) {\n        let s;\n        return t.forEach(function (t) {\n          let o = t.noSharedTooltip && e,\n            r = !o && 0 > t.options.findNearestPointBy.indexOf("y"),\n            a = t.searchPoint(i, r);\n          m(a, !0) && a.series && (!m(s, !0) || function (t, i) {\n            let s = t.distX - i.distX,\n              o = t.dist - i.dist,\n              r = (i.series.group && i.series.group.zIndex) - (t.series.group && t.series.group.zIndex);\n            return 0 !== s && e ? s : 0 !== o ? o : 0 !== r ? r : t.series.index > i.series.index ? -1 : 1;\n          }(s, a) > 0) && (s = a);\n        }), s;\n      }\n      getChartCoordinatesFromPoint(t, e) {\n        let i = t.series,\n          s = i.xAxis,\n          o = i.yAxis,\n          r = t.shapeArgs;\n        if (s && o) {\n          let i = b(t.clientX, t.plotX),\n            a = t.plotY || 0;\n          return t.isNode && r && f(r.x) && f(r.y) && (i = r.x, a = r.y), e ? {\n            chartX: o.len + o.pos - a,\n            chartY: s.len + s.pos - i\n          } : {\n            chartX: i + s.pos,\n            chartY: a + o.pos\n          };\n        }\n        if (r && r.x && r.y) return {\n          chartX: r.x,\n          chartY: r.y\n        };\n      }\n      getChartPosition() {\n        if (this.chartPosition) return this.chartPosition;\n        let {\n            container: t\n          } = this.chart,\n          e = y(t);\n        this.chartPosition = {\n          left: e.left,\n          top: e.top,\n          scaleX: 1,\n          scaleY: 1\n        };\n        let i = t.offsetWidth,\n          s = t.offsetHeight;\n        return i > 2 && s > 2 && (this.chartPosition.scaleX = e.width / i, this.chartPosition.scaleY = e.height / s), this.chartPosition;\n      }\n      getCoordinates(t) {\n        let e = {\n          xAxis: [],\n          yAxis: []\n        };\n        return this.chart.axes.forEach(function (i) {\n          e[i.isXAxis ? "xAxis" : "yAxis"].push({\n            axis: i,\n            value: i.toValue(t[i.horiz ? "chartX" : "chartY"])\n          });\n        }), e;\n      }\n      getHoverData(t, e, i, s, o, r) {\n        let a = [],\n          n = function (t) {\n            return t.visible && !(!o && t.directTouch) && b(t.options.enableMouseTracking, !0);\n          },\n          l = e,\n          h,\n          d = {\n            chartX: r ? r.chartX : void 0,\n            chartY: r ? r.chartY : void 0,\n            shared: o\n          };\n        g(this, "beforeGetHoverData", d);\n        let c = l && !l.stickyTracking;\n        h = c ? [l] : i.filter(t => t.stickyTracking && (d.filter || n)(t));\n        let p = s && t || !r ? t : this.findNearestKDPoint(h, o, r);\n        return l = p && p.series, p && (o && !l.noSharedTooltip ? (h = i.filter(function (t) {\n          return d.filter ? d.filter(t) : n(t) && !t.noSharedTooltip;\n        })).forEach(function (t) {\n          let e = u(t.points, function (t) {\n            return t.x === p.x && !t.isNull;\n          });\n          m(e) && (t.boosted && t.boost && (e = t.boost.getPoint(e)), a.push(e));\n        }) : a.push(p)), g(this, "afterGetHoverData", d = {\n          hoverPoint: p\n        }), {\n          hoverPoint: d.hoverPoint,\n          hoverSeries: l,\n          hoverPoints: a\n        };\n      }\n      getPointFromEvent(t) {\n        let e = t.target,\n          i;\n        for (; e && !i;) i = e.point, e = e.parentNode;\n        return i;\n      }\n      onTrackerMouseOut(t) {\n        let e = this.chart,\n          i = t.relatedTarget,\n          s = e.hoverSeries;\n        this.isDirectTouch = !1, !s || !i || s.stickyTracking || this.inClass(i, "highcharts-tooltip") || this.inClass(i, "highcharts-series-" + s.index) && this.inClass(i, "highcharts-tracker") || s.onMouseOut();\n      }\n      inClass(t, e) {\n        let i = t,\n          s;\n        for (; i;) {\n          if (s = h(i, "class")) {\n            if (-1 !== s.indexOf(e)) return !0;\n            if (-1 !== s.indexOf("highcharts-container")) return !1;\n          }\n          i = i.parentElement;\n        }\n      }\n      constructor(t, e) {\n        this.hasDragged = !1, this.lastValidTouch = {}, this.pinchDown = [], this.eventsToUnbind = [], this.options = e, this.chart = t, this.runChartClick = !!e.chart.events?.click, this.pinchDown = [], this.lastValidTouch = {}, this.setDOMEvents(), g(this, "afterInit");\n      }\n      normalize(t, e) {\n        let i = t.touches,\n          s = i ? i.length ? i.item(0) : b(i.changedTouches, t.changedTouches)[0] : t;\n        e || (e = this.getChartPosition());\n        let o = s.pageX - e.left,\n          r = s.pageY - e.top;\n        return p(t, {\n          chartX: Math.round(o /= e.scaleX),\n          chartY: Math.round(r /= e.scaleY)\n        });\n      }\n      onContainerClick(t) {\n        let e = this.chart,\n          i = e.hoverPoint,\n          s = this.normalize(t),\n          o = e.plotLeft,\n          r = e.plotTop;\n        !e.cancelClick && (i && this.inClass(s.target, "highcharts-tracker") ? (g(i.series, "click", p(s, {\n          point: i\n        })), e.hoverPoint && i.firePointEvent("click", s)) : (p(s, this.getCoordinates(s)), e.isInsidePlot(s.chartX - o, s.chartY - r, {\n          visiblePlotOnly: !0\n        }) && g(e, "click", s)));\n      }\n      onContainerMouseDown(t) {\n        let i = (1 & (t.buttons || t.button)) == 1;\n        t = this.normalize(t), e.isFirefox && 0 !== t.button && this.onContainerMouseMove(t), (void 0 === t.button || i) && (this.zoomOption(t), i && t.preventDefault && t.preventDefault(), this.dragStart(t));\n      }\n      onContainerMouseLeave(t) {\n        let e = r[b(S.hoverChartIndex, -1)];\n        t = this.normalize(t), this.onContainerMouseMove(t), e && t.relatedTarget && !this.inClass(t.relatedTarget, "highcharts-tooltip") && (e.pointer.reset(), e.pointer.chartPosition = void 0);\n      }\n      onContainerMouseEnter(t) {\n        delete this.chartPosition;\n      }\n      onContainerMouseMove(t) {\n        let e = this.chart,\n          i = e.tooltip,\n          s = this.normalize(t);\n        this.setHoverChartIndex(t), ("mousedown" === e.mouseIsDown || this.touchSelect(s)) && this.drag(s), !e.openMenu && (this.inClass(s.target, "highcharts-tracker") || e.isInsidePlot(s.chartX - e.plotLeft, s.chartY - e.plotTop, {\n          visiblePlotOnly: !0\n        })) && !(i && i.shouldStickOnContact(s)) && (this.inClass(s.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(s));\n      }\n      onDocumentTouchEnd(t) {\n        let e = r[b(S.hoverChartIndex, -1)];\n        e && e.pointer.drop(t);\n      }\n      onContainerTouchMove(t) {\n        this.touchSelect(t) ? this.onContainerMouseMove(t) : this.touch(t);\n      }\n      onContainerTouchStart(t) {\n        this.touchSelect(t) ? this.onContainerMouseDown(t) : (this.zoomOption(t), this.touch(t, !0));\n      }\n      onDocumentMouseMove(t) {\n        let e = this.chart,\n          i = e.tooltip,\n          s = this.chartPosition,\n          o = this.normalize(t, s);\n        !s || e.isInsidePlot(o.chartX - e.plotLeft, o.chartY - e.plotTop, {\n          visiblePlotOnly: !0\n        }) || i && i.shouldStickOnContact(o) || this.inClass(o.target, "highcharts-tracker") || this.reset();\n      }\n      onDocumentMouseUp(t) {\n        let e = r[b(S.hoverChartIndex, -1)];\n        e && e.pointer.drop(t);\n      }\n      pinch(t) {\n        let e = this,\n          i = e.chart,\n          s = e.pinchDown,\n          o = t.touches || [],\n          r = o.length,\n          a = e.lastValidTouch,\n          l = e.hasZoom,\n          h = {},\n          d = 1 === r && (e.inClass(t.target, "highcharts-tracker") && i.runTrackerClick || e.runChartClick),\n          c = {},\n          u = e.chart.tooltip,\n          f = 1 === r && b(u && u.options.followTouchMove, !0),\n          m = e.selectionMarker;\n        r > 1 ? e.initiated = !0 : f && (e.initiated = !1), l && e.initiated && !d && !1 !== t.cancelable && t.preventDefault(), [].map.call(o, function (t) {\n          return e.normalize(t);\n        }), "touchstart" === t.type ? ([].forEach.call(o, function (t, e) {\n          s[e] = {\n            chartX: t.chartX,\n            chartY: t.chartY\n          };\n        }), a.x = [s[0].chartX, s[1] && s[1].chartX], a.y = [s[0].chartY, s[1] && s[1].chartY], i.axes.forEach(function (t) {\n          if (t.zoomEnabled) {\n            let e = i.bounds[t.horiz ? "h" : "v"],\n              s = t.minPixelPadding,\n              o = t.toPixels(Math.min(b(t.options.min, t.dataMin), t.dataMin)),\n              r = t.toPixels(Math.max(b(t.options.max, t.dataMax), t.dataMax)),\n              a = Math.min(o, r),\n              n = Math.max(o, r);\n            e.min = Math.min(t.pos, a - s), e.max = Math.max(t.pos + t.len, n + s);\n          }\n        }), e.res = !0) : f ? this.runPointActions(e.normalize(t)) : s.length && (g(i, "touchpan", {\n          originalEvent: t\n        }, () => {\n          m || (e.selectionMarker = m = p({\n            destroy: n,\n            touch: !0\n          }, i.plotBox)), e.pinchTranslate(s, o, h, m, c, a), e.hasPinched = l, e.scaleGroups(h, c);\n        }), e.res && (e.res = !1, this.reset(!1, 0)));\n      }\n      pinchTranslate(t, e, i, s, o, r) {\n        this.zoomHor && this.pinchTranslateDirection(!0, t, e, i, s, o, r), this.zoomVert && this.pinchTranslateDirection(!1, t, e, i, s, o, r);\n      }\n      pinchTranslateDirection(t, e, i, s, o, r, a, n) {\n        let l = this.chart,\n          h = t ? "x" : "y",\n          d = t ? "X" : "Y",\n          c = "chart" + d,\n          p = t ? "width" : "height",\n          u = l["plot" + (t ? "Left" : "Top")],\n          g = l.inverted,\n          f = l.bounds[t ? "h" : "v"],\n          m = 1 === e.length,\n          x = e[0][c],\n          y = !m && e[1][c],\n          b = function () {\n            "number" == typeof A && Math.abs(x - y) > 20 && (k = n || Math.abs(C - A) / Math.abs(x - y)), S = (u - C) / k + x, v = l["plot" + (t ? "Width" : "Height")] / k;\n          },\n          v,\n          M,\n          S,\n          k = n || 1,\n          C = i[0][c],\n          A = !m && i[1][c],\n          w;\n        b(), (M = S) < f.min ? (M = f.min, w = !0) : M + v > f.max && (M = f.max - v, w = !0), w ? (C -= .8 * (C - a[h][0]), "number" == typeof A && (A -= .8 * (A - a[h][1])), b()) : a[h] = [C, A], g || (r[h] = S - u, r[p] = v);\n        let T = g ? t ? "scaleY" : "scaleX" : "scale" + d,\n          P = g ? 1 / k : k;\n        o[p] = v, o[h] = M, s[T] = k * (g && !t ? -1 : 1), s["translate" + d] = P * u + (C - P * x);\n      }\n      reset(t, e) {\n        let i = this.chart,\n          s = i.hoverSeries,\n          o = i.hoverPoint,\n          r = i.hoverPoints,\n          a = i.tooltip,\n          n = a && a.shared ? r : o;\n        t && n && M(n).forEach(function (e) {\n          e.series.isCartesian && void 0 === e.plotX && (t = !1);\n        }), t ? a && n && M(n).length && (a.refresh(n), a.shared && r ? r.forEach(function (t) {\n          t.setState(t.state, !0), t.series.isCartesian && (t.series.xAxis.crosshair && t.series.xAxis.drawCrosshair(null, t), t.series.yAxis.crosshair && t.series.yAxis.drawCrosshair(null, t));\n        }) : o && (o.setState(o.state, !0), i.axes.forEach(function (t) {\n          t.crosshair && o.series[t.coll] === t && t.drawCrosshair(null, o);\n        }))) : (o && o.onMouseOut(), r && r.forEach(function (t) {\n          t.setState();\n        }), s && s.onMouseOut(), a && a.hide(e), this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove()), i.axes.forEach(function (t) {\n          t.hideCrosshair();\n        }), this.hoverX = i.hoverPoints = i.hoverPoint = null);\n      }\n      runPointActions(t, e, i) {\n        let s = this.chart,\n          o = s.series,\n          a = s.tooltip && s.tooltip.options.enabled ? s.tooltip : void 0,\n          n = !!a && a.shared,\n          h = e || s.hoverPoint,\n          d = h && h.series || s.hoverSeries,\n          c = (!t || "touchmove" !== t.type) && (!!e || d && d.directTouch && this.isDirectTouch),\n          p = this.getHoverData(h, d, o, c, n, t);\n        h = p.hoverPoint, d = p.hoverSeries;\n        let g = p.hoverPoints,\n          f = d && d.tooltipOptions.followPointer && !d.tooltipOptions.split,\n          m = n && d && !d.noSharedTooltip;\n        if (h && (i || h !== s.hoverPoint || a && a.isHidden)) {\n          if ((s.hoverPoints || []).forEach(function (t) {\n            -1 === g.indexOf(t) && t.setState();\n          }), s.hoverSeries !== d && d.onMouseOver(), this.applyInactiveState(g), (g || []).forEach(function (t) {\n            t.setState("hover");\n          }), s.hoverPoint && s.hoverPoint.firePointEvent("mouseOut"), !h.series) return;\n          s.hoverPoints = g, s.hoverPoint = h, h.firePointEvent("mouseOver", void 0, () => {\n            a && h && a.refresh(m ? g : h, t);\n          });\n        } else if (f && a && !a.isHidden) {\n          let e = a.getAnchor([{}], t);\n          s.isInsidePlot(e[0], e[1], {\n            visiblePlotOnly: !0\n          }) && a.updatePosition({\n            plotX: e[0],\n            plotY: e[1]\n          });\n        }\n        this.unDocMouseMove || (this.unDocMouseMove = l(s.container.ownerDocument, "mousemove", function (t) {\n          let e = r[S.hoverChartIndex];\n          e && e.pointer.onDocumentMouseMove(t);\n        }), this.eventsToUnbind.push(this.unDocMouseMove)), s.axes.forEach(function (e) {\n          let i;\n          let o = b((e.crosshair || {}).snap, !0);\n          !o || (i = s.hoverPoint) && i.series[e.coll] === e || (i = u(g, t => t.series && t.series[e.coll] === e)), i || !o ? e.drawCrosshair(t, i) : e.hideCrosshair();\n        });\n      }\n      scaleGroups(t, e) {\n        let i = this.chart;\n        i.series.forEach(function (s) {\n          let o = t || s.getPlotBox("series");\n          s.group && (s.xAxis && s.xAxis.zoomEnabled || i.mapView) && (s.group.attr(o), s.markerGroup && (s.markerGroup.attr(t || s.getPlotBox("marker")), s.markerGroup.clip(e ? i.clipRect : null)), s.dataLabelsGroup && s.dataLabelsGroup.attr(o));\n        }), i.clipRect.attr(e || i.clipBox);\n      }\n      setDOMEvents() {\n        let t = this.chart.container,\n          i = t.ownerDocument;\n        t.onmousedown = this.onContainerMouseDown.bind(this), t.onmousemove = this.onContainerMouseMove.bind(this), t.onclick = this.onContainerClick.bind(this), this.eventsToUnbind.push(l(t, "mouseenter", this.onContainerMouseEnter.bind(this))), this.eventsToUnbind.push(l(t, "mouseleave", this.onContainerMouseLeave.bind(this))), S.unbindDocumentMouseUp || (S.unbindDocumentMouseUp = l(i, "mouseup", this.onDocumentMouseUp.bind(this)));\n        let s = this.chart.renderTo.parentElement;\n        for (; s && "BODY" !== s.tagName;) this.eventsToUnbind.push(l(s, "scroll", () => {\n          delete this.chartPosition;\n        })), s = s.parentElement;\n        e.hasTouch && (this.eventsToUnbind.push(l(t, "touchstart", this.onContainerTouchStart.bind(this), {\n          passive: !1\n        })), this.eventsToUnbind.push(l(t, "touchmove", this.onContainerTouchMove.bind(this), {\n          passive: !1\n        })), S.unbindDocumentTouchEnd || (S.unbindDocumentTouchEnd = l(i, "touchend", this.onDocumentTouchEnd.bind(this), {\n          passive: !1\n        })));\n      }\n      setHoverChartIndex(t) {\n        let i = this.chart,\n          s = e.charts[b(S.hoverChartIndex, -1)];\n        s && s !== i && s.pointer.onContainerMouseLeave(t || {\n          relatedTarget: i.container\n        }), s && s.mouseIsDown || (S.hoverChartIndex = i.index);\n      }\n      touch(t, e) {\n        let i, s;\n        let o = this.chart;\n        this.setHoverChartIndex(), 1 === t.touches.length ? (t = this.normalize(t), o.isInsidePlot(t.chartX - o.plotLeft, t.chartY - o.plotTop, {\n          visiblePlotOnly: !0\n        }) && !o.openMenu ? (e && this.runPointActions(t), "touchmove" === t.type && (i = !!(s = this.pinchDown)[0] && Math.sqrt(Math.pow(s[0].chartX - t.chartX, 2) + Math.pow(s[0].chartY - t.chartY, 2)) >= 4), b(i, !0) && this.pinch(t)) : e && this.reset()) : 2 === t.touches.length && this.pinch(t);\n      }\n      touchSelect(t) {\n        return !!(this.chart.zooming.singleTouch && t.touches && 1 === t.touches.length);\n      }\n      zoomOption(t) {\n        let e = this.chart,\n          i = (e.options.chart, e.inverted),\n          s = e.zooming.type || "",\n          o,\n          r;\n        /touch/.test(t.type) && (s = b(e.zooming.pinchType, s)), this.zoomX = o = /x/.test(s), this.zoomY = r = /y/.test(s), this.zoomHor = o && !i || r && i, this.zoomVert = r && !i || o && i, this.hasZoom = o || r;\n      }\n    }\n    return (s = S || (S = {})).compose = function t(e) {\n      v(a, t) && l(e, "beforeRender", function () {\n        this.pointer = new s(this, this.options);\n      });\n    }, S;\n  }), i(e, "Core/Legend/Legend.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Templating.js"], e["Core/Globals.js"], e["Core/Series/Point.js"], e["Core/Renderer/RendererUtilities.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, r) {\n    var a;\n    let {\n        animObject: n,\n        setAnimation: l\n      } = t,\n      {\n        format: h\n      } = e,\n      {\n        composed: d,\n        marginNames: c\n      } = i,\n      {\n        distribute: p\n      } = o,\n      {\n        addEvent: u,\n        createElement: g,\n        css: f,\n        defined: m,\n        discardElement: x,\n        find: y,\n        fireEvent: b,\n        isNumber: v,\n        merge: M,\n        pick: S,\n        pushUnique: k,\n        relativeLength: C,\n        stableSort: A,\n        syncTimeout: w\n      } = r;\n    class T {\n      constructor(t, e) {\n        this.allItems = [], this.initialItemY = 0, this.itemHeight = 0, this.itemMarginBottom = 0, this.itemMarginTop = 0, this.itemX = 0, this.itemY = 0, this.lastItemY = 0, this.lastLineHeight = 0, this.legendHeight = 0, this.legendWidth = 0, this.maxItemWidth = 0, this.maxLegendWidth = 0, this.offsetWidth = 0, this.padding = 0, this.pages = [], this.symbolHeight = 0, this.symbolWidth = 0, this.titleHeight = 0, this.totalItemWidth = 0, this.widthOption = 0, this.chart = t, this.setOptions(e), e.enabled && (this.render(), u(this.chart, "endResize", function () {\n          this.legend.positionCheckboxes();\n        })), u(this.chart, "render", () => {\n          this.options.enabled && this.proximate && (this.proximatePositions(), this.positionItems());\n        });\n      }\n      setOptions(t) {\n        let e = S(t.padding, 8);\n        this.options = t, this.chart.styledMode || (this.itemStyle = t.itemStyle, this.itemHiddenStyle = M(this.itemStyle, t.itemHiddenStyle)), this.itemMarginTop = t.itemMarginTop, this.itemMarginBottom = t.itemMarginBottom, this.padding = e, this.initialItemY = e - 5, this.symbolWidth = S(t.symbolWidth, 16), this.pages = [], this.proximate = "proximate" === t.layout && !this.chart.inverted, this.baseline = void 0;\n      }\n      update(t, e) {\n        let i = this.chart;\n        this.setOptions(M(!0, this.options, t)), this.destroy(), i.isDirtyLegend = i.isDirtyBox = !0, S(e, !0) && i.redraw(), b(this, "afterUpdate", {\n          redraw: e\n        });\n      }\n      colorizeItem(t, e) {\n        let {\n          area: i,\n          group: s,\n          label: o,\n          line: r,\n          symbol: a\n        } = t.legendItem || {};\n        if (s?.[e ? "removeClass" : "addClass"]("highcharts-legend-item-hidden"), !this.chart.styledMode) {\n          let {\n              itemHiddenStyle: s = {}\n            } = this,\n            n = s.color,\n            {\n              fillColor: l,\n              fillOpacity: h,\n              lineColor: d,\n              marker: c\n            } = t.options,\n            p = t => (!e && (t.fill && (t.fill = n), t.stroke && (t.stroke = n)), t);\n          o?.css(M(e ? this.itemStyle : s)), r?.attr(p({\n            stroke: d || t.color\n          })), a && a.attr(p(c && a.isMarker ? t.pointAttribs() : {\n            fill: t.color\n          })), i?.attr(p({\n            fill: l || t.color,\n            "fill-opacity": l ? 1 : h ?? .75\n          }));\n        }\n        b(this, "afterColorizeItem", {\n          item: t,\n          visible: e\n        });\n      }\n      positionItems() {\n        this.allItems.forEach(this.positionItem, this), this.chart.isResizing || this.positionCheckboxes();\n      }\n      positionItem(t) {\n        let {\n            group: e,\n            x: i = 0,\n            y: s = 0\n          } = t.legendItem || {},\n          o = this.options,\n          r = o.symbolPadding,\n          a = !o.rtl,\n          n = t.checkbox;\n        if (e && e.element) {\n          let o = {\n            translateX: a ? i : this.legendWidth - i - 2 * r - 4,\n            translateY: s\n          };\n          e[m(e.translateY) ? "animate" : "attr"](o, void 0, () => {\n            b(this, "afterPositionItem", {\n              item: t\n            });\n          });\n        }\n        n && (n.x = i, n.y = s);\n      }\n      destroyItem(t) {\n        let e = t.checkbox,\n          i = t.legendItem || {};\n        for (let t of ["group", "label", "line", "symbol"]) i[t] && (i[t] = i[t].destroy());\n        e && x(e), t.legendItem = void 0;\n      }\n      destroy() {\n        for (let t of this.getAllItems()) this.destroyItem(t);\n        for (let t of ["clipRect", "up", "down", "pager", "nav", "box", "title", "group"]) this[t] && (this[t] = this[t].destroy());\n        this.display = null;\n      }\n      positionCheckboxes() {\n        let t;\n        let e = this.group && this.group.alignAttr,\n          i = this.clipHeight || this.legendHeight,\n          s = this.titleHeight;\n        e && (t = e.translateY, this.allItems.forEach(function (o) {\n          let r;\n          let a = o.checkbox;\n          a && (r = t + s + a.y + (this.scrollOffset || 0) + 3, f(a, {\n            left: e.translateX + o.checkboxOffset + a.x - 20 + "px",\n            top: r + "px",\n            display: this.proximate || r > t - 6 && r < t + i - 6 ? "" : "none"\n          }));\n        }, this));\n      }\n      renderTitle() {\n        let t = this.options,\n          e = this.padding,\n          i = t.title,\n          s,\n          o = 0;\n        i.text && (this.title || (this.title = this.chart.renderer.label(i.text, e - 3, e - 4, void 0, void 0, void 0, t.useHTML, void 0, "legend-title").attr({\n          zIndex: 1\n        }), this.chart.styledMode || this.title.css(i.style), this.title.add(this.group)), i.width || this.title.css({\n          width: this.maxLegendWidth + "px"\n        }), o = (s = this.title.getBBox()).height, this.offsetWidth = s.width, this.contentGroup.attr({\n          translateY: o\n        })), this.titleHeight = o;\n      }\n      setText(t) {\n        let e = this.options;\n        t.legendItem.label.attr({\n          text: e.labelFormat ? h(e.labelFormat, t, this.chart) : e.labelFormatter.call(t)\n        });\n      }\n      renderItem(t) {\n        let e = t.legendItem = t.legendItem || {},\n          i = this.chart,\n          s = i.renderer,\n          o = this.options,\n          r = "horizontal" === o.layout,\n          a = this.symbolWidth,\n          n = o.symbolPadding || 0,\n          l = this.itemStyle,\n          h = this.itemHiddenStyle,\n          d = r ? S(o.itemDistance, 20) : 0,\n          c = !o.rtl,\n          p = !t.series,\n          u = !p && t.series.drawLegendSymbol ? t.series : t,\n          g = u.options,\n          f = !!this.createCheckboxForItem && g && g.showCheckbox,\n          m = o.useHTML,\n          x = t.options.className,\n          y = e.label,\n          b = a + n + d + (f ? 20 : 0);\n        !y && (e.group = s.g("legend-item").addClass("highcharts-" + u.type + "-series highcharts-color-" + t.colorIndex + (x ? " " + x : "") + (p ? " highcharts-series-" + t.index : "")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), e.label = y = s.text("", c ? a + n : -n, this.baseline || 0, m), i.styledMode || y.css(M(t.visible ? l : h)), y.attr({\n          align: c ? "left" : "right",\n          zIndex: 2\n        }).add(e.group), !this.baseline && (this.fontMetrics = s.fontMetrics(y), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, y.attr("y", this.baseline), this.symbolHeight = S(o.symbolHeight, this.fontMetrics.f), o.squareSymbol && (this.symbolWidth = S(o.symbolWidth, Math.max(this.symbolHeight, 16)), b = this.symbolWidth + n + d + (f ? 20 : 0), c && y.attr("x", this.symbolWidth + n))), u.drawLegendSymbol(this, t), this.setItemEvents && this.setItemEvents(t, y, m)), f && !t.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(t), this.colorizeItem(t, t.visible), (i.styledMode || !l.width) && y.css({\n          width: (o.itemWidth || this.widthOption || i.spacingBox.width) - b + "px"\n        }), this.setText(t);\n        let v = y.getBBox(),\n          k = this.fontMetrics && this.fontMetrics.h || 0;\n        t.itemWidth = t.checkboxOffset = o.itemWidth || e.labelWidth || v.width + b, this.maxItemWidth = Math.max(this.maxItemWidth, t.itemWidth), this.totalItemWidth += t.itemWidth, this.itemHeight = t.itemHeight = Math.round(e.labelHeight || (v.height > 1.5 * k ? v.height : k));\n      }\n      layoutItem(t) {\n        let e = this.options,\n          i = this.padding,\n          s = "horizontal" === e.layout,\n          o = t.itemHeight,\n          r = this.itemMarginBottom,\n          a = this.itemMarginTop,\n          n = s ? S(e.itemDistance, 20) : 0,\n          l = this.maxLegendWidth,\n          h = e.alignColumns && this.totalItemWidth > l ? this.maxItemWidth : t.itemWidth,\n          d = t.legendItem || {};\n        s && this.itemX - i + h > l && (this.itemX = i, this.lastLineHeight && (this.itemY += a + this.lastLineHeight + r), this.lastLineHeight = 0), this.lastItemY = a + this.itemY + r, this.lastLineHeight = Math.max(o, this.lastLineHeight), d.x = this.itemX, d.y = this.itemY, s ? this.itemX += h : (this.itemY += a + o + r, this.lastLineHeight = o), this.offsetWidth = this.widthOption || Math.max((s ? this.itemX - i - (t.checkbox ? 0 : n) : h) + i, this.offsetWidth);\n      }\n      getAllItems() {\n        let t = [];\n        return this.chart.series.forEach(function (e) {\n          let i = e && e.options;\n          e && S(i.showInLegend, !m(i.linkedTo) && void 0, !0) && (t = t.concat((e.legendItem || {}).labels || ("point" === i.legendType ? e.data : e)));\n        }), b(this, "afterGetAllItems", {\n          allItems: t\n        }), t;\n      }\n      getAlignment() {\n        let t = this.options;\n        return this.proximate ? t.align.charAt(0) + "tv" : t.floating ? "" : t.align.charAt(0) + t.verticalAlign.charAt(0) + t.layout.charAt(0);\n      }\n      adjustMargins(t, e) {\n        let i = this.chart,\n          s = this.options,\n          o = this.getAlignment();\n        o && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (r, a) {\n          r.test(o) && !m(t[a]) && (i[c[a]] = Math.max(i[c[a]], i.legend[(a + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][a] * s[a % 2 ? "x" : "y"] + S(s.margin, 12) + e[a] + (i.titleOffset[a] || 0)));\n        });\n      }\n      proximatePositions() {\n        let t;\n        let e = this.chart,\n          i = [],\n          s = "left" === this.options.align;\n        for (let o of (this.allItems.forEach(function (t) {\n          let o,\n            r,\n            a = s,\n            n,\n            l;\n          t.yAxis && (t.xAxis.options.reversed && (a = !a), t.points && (o = y(a ? t.points : t.points.slice(0).reverse(), function (t) {\n            return v(t.plotY);\n          })), r = this.itemMarginTop + t.legendItem.label.getBBox().height + this.itemMarginBottom, l = t.yAxis.top - e.plotTop, n = t.visible ? (o ? o.plotY : t.yAxis.height) + (l - .3 * r) : l + t.yAxis.height, i.push({\n            target: n,\n            size: r,\n            item: t\n          }));\n        }, this), p(i, e.plotHeight))) t = o.item.legendItem || {}, v(o.pos) && (t.y = e.plotTop - e.spacing[0] + o.pos);\n      }\n      render() {\n        let t = this.chart,\n          e = t.renderer,\n          i = this.options,\n          s = this.padding,\n          o = this.getAllItems(),\n          r,\n          a,\n          n,\n          l = this.group,\n          h,\n          d = this.box;\n        this.itemX = s, this.itemY = this.initialItemY, this.offsetWidth = 0, this.lastItemY = 0, this.widthOption = C(i.width, t.spacingBox.width - s), h = t.spacingBox.width - 2 * s - i.x, ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) > -1 && (h /= 2), this.maxLegendWidth = this.widthOption || h, l || (this.group = l = e.g("legend").addClass(i.className || "").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = e.g().attr({\n          zIndex: 1\n        }).add(l), this.scrollGroup = e.g().add(this.contentGroup)), this.renderTitle(), A(o, (t, e) => (t.options && t.options.legendIndex || 0) - (e.options && e.options.legendIndex || 0)), i.reversed && o.reverse(), this.allItems = o, this.display = r = !!o.length, this.lastLineHeight = 0, this.maxItemWidth = 0, this.totalItemWidth = 0, this.itemHeight = 0, o.forEach(this.renderItem, this), o.forEach(this.layoutItem, this), a = (this.widthOption || this.offsetWidth) + s, n = this.lastItemY + this.lastLineHeight + this.titleHeight, n = this.handleOverflow(n) + s, d || (this.box = d = e.rect().addClass("highcharts-legend-box").attr({\n          r: i.borderRadius\n        }).add(l)), t.styledMode || d.attr({\n          stroke: i.borderColor,\n          "stroke-width": i.borderWidth || 0,\n          fill: i.backgroundColor || "none"\n        }).shadow(i.shadow), a > 0 && n > 0 && d[d.placed ? "animate" : "attr"](d.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: a,\n          height: n\n        }, d.strokeWidth())), l[r ? "show" : "hide"](), t.styledMode && "none" === l.getStyle("display") && (a = n = 0), this.legendWidth = a, this.legendHeight = n, r && this.align(), this.proximate || this.positionItems(), b(this, "afterRender");\n      }\n      align(t = this.chart.spacingBox) {\n        let e = this.chart,\n          i = this.options,\n          s = t.y;\n        /(lth|ct|rth)/.test(this.getAlignment()) && e.titleOffset[0] > 0 ? s += e.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && e.titleOffset[2] > 0 && (s -= e.titleOffset[2]), s !== t.y && (t = M(t, {\n          y: s\n        })), e.hasRendered || (this.group.placed = !1), this.group.align(M(i, {\n          width: this.legendWidth,\n          height: this.legendHeight,\n          verticalAlign: this.proximate ? "top" : i.verticalAlign\n        }), !0, t);\n      }\n      handleOverflow(t) {\n        let e = this,\n          i = this.chart,\n          s = i.renderer,\n          o = this.options,\n          r = o.y,\n          a = "top" === o.verticalAlign,\n          n = this.padding,\n          l = o.maxHeight,\n          h = o.navigation,\n          d = S(h.animation, !0),\n          c = h.arrowSize || 12,\n          p = this.pages,\n          u = this.allItems,\n          g = function (t) {\n            "number" == typeof t ? M.attr({\n              height: t\n            }) : M && (e.clipRect = M.destroy(), e.contentGroup.clip()), e.contentGroup.div && (e.contentGroup.div.style.clip = t ? "rect(" + n + "px,9999px," + (n + t) + "px,0)" : "auto");\n          },\n          f = function (t) {\n            return e[t] = s.circle(0, 0, 1.3 * c).translate(c / 2, c / 2).add(v), i.styledMode || e[t].attr("fill", "rgba(0,0,0,0.0001)"), e[t];\n          },\n          m,\n          x,\n          y,\n          b = i.spacingBox.height + (a ? -r : r) - n,\n          v = this.nav,\n          M = this.clipRect;\n        return "horizontal" !== o.layout || "middle" === o.verticalAlign || o.floating || (b /= 2), l && (b = Math.min(b, l)), p.length = 0, t && b > 0 && t > b && !1 !== h.enabled ? (this.clipHeight = m = Math.max(b - 20 - this.titleHeight - n, 0), this.currentPage = S(this.currentPage, 1), this.fullHeight = t, u.forEach((t, e) => {\n          y = t.legendItem || {};\n          let i = y.y || 0,\n            s = Math.round(y.label.getBBox().height),\n            o = p.length;\n          (!o || i - p[o - 1] > m && (x || i) !== p[o - 1]) && (p.push(x || i), o++), y.pageIx = o - 1, x && ((u[e - 1].legendItem || {}).pageIx = o - 1), e === u.length - 1 && i + s - p[o - 1] > m && i > p[o - 1] && (p.push(i), y.pageIx = o), i !== x && (x = i);\n        }), M || (M = e.clipRect = s.clipRect(0, n - 2, 9999, 0), e.contentGroup.clip(M)), g(m), v || (this.nav = v = s.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = s.symbol("triangle", 0, 0, c, c).add(v), f("upTracker").on("click", function () {\n          e.scroll(-1, d);\n        }), this.pager = s.text("", 15, 10).addClass("highcharts-legend-navigation"), !i.styledMode && h.style && this.pager.css(h.style), this.pager.add(v), this.down = s.symbol("triangle-down", 0, 0, c, c).add(v), f("downTracker").on("click", function () {\n          e.scroll(1, d);\n        })), e.scroll(0), t = b) : v && (g(), this.nav = v.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0), t;\n      }\n      scroll(t, e) {\n        let i = this.chart,\n          s = this.pages,\n          o = s.length,\n          r = this.clipHeight,\n          a = this.options.navigation,\n          h = this.pager,\n          d = this.padding,\n          c = this.currentPage + t;\n        if (c > o && (c = o), c > 0) {\n          void 0 !== e && l(e, i), this.nav.attr({\n            translateX: d,\n            translateY: r + this.padding + 7 + this.titleHeight,\n            visibility: "inherit"\n          }), [this.up, this.upTracker].forEach(function (t) {\n            t.attr({\n              class: 1 === c ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"\n            });\n          }), h.attr({\n            text: c + "/" + o\n          }), [this.down, this.downTracker].forEach(function (t) {\n            t.attr({\n              x: 18 + this.pager.getBBox().width,\n              class: c === o ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"\n            });\n          }, this), i.styledMode || (this.up.attr({\n            fill: 1 === c ? a.inactiveColor : a.activeColor\n          }), this.upTracker.css({\n            cursor: 1 === c ? "default" : "pointer"\n          }), this.down.attr({\n            fill: c === o ? a.inactiveColor : a.activeColor\n          }), this.downTracker.css({\n            cursor: c === o ? "default" : "pointer"\n          })), this.scrollOffset = -s[c - 1] + this.initialItemY, this.scrollGroup.animate({\n            translateY: this.scrollOffset\n          }), this.currentPage = c, this.positionCheckboxes();\n          let t = n(S(e, i.renderer.globalAnimation, !0));\n          w(() => {\n            b(this, "afterScroll", {\n              currentPage: c\n            });\n          }, t.duration);\n        }\n      }\n      setItemEvents(t, e, i) {\n        let o = this,\n          r = t.legendItem || {},\n          a = o.chart.renderer.boxWrapper,\n          n = t instanceof s,\n          l = "highcharts-legend-" + (n ? "point" : "series") + "-active",\n          h = o.chart.styledMode,\n          d = i ? [e, r.symbol] : [r.group],\n          c = e => {\n            o.allItems.forEach(i => {\n              t !== i && [i].concat(i.linkedSeries || []).forEach(t => {\n                t.setState(e, !n);\n              });\n            });\n          };\n        for (let i of d) i && i.on("mouseover", function () {\n          t.visible && c("inactive"), t.setState("hover"), t.visible && a.addClass(l), h || e.css(o.options.itemHoverStyle);\n        }).on("mouseout", function () {\n          o.chart.styledMode || e.css(M(t.visible ? o.itemStyle : o.itemHiddenStyle)), c(""), a.removeClass(l), t.setState();\n        }).on("click", function (e) {\n          let i = "legendItemClick",\n            s = function () {\n              t.setVisible && t.setVisible(), c(t.visible ? "inactive" : "");\n            };\n          a.removeClass(l), e = {\n            browserEvent: e\n          }, t.firePointEvent ? t.firePointEvent(i, e, s) : b(t, i, e, s);\n        });\n      }\n      createCheckboxForItem(t) {\n        t.checkbox = g("input", {\n          type: "checkbox",\n          className: "highcharts-legend-checkbox",\n          checked: t.selected,\n          defaultChecked: t.selected\n        }, this.options.itemCheckboxStyle, this.chart.container), u(t.checkbox, "click", function (e) {\n          let i = e.target;\n          b(t.series || t, "checkboxClick", {\n            checked: i.checked,\n            item: t\n          }, function () {\n            t.select();\n          });\n        });\n      }\n    }\n    return (a = T || (T = {})).compose = function t(e) {\n      k(d, t) && u(e, "beforeMargins", function () {\n        this.legend = new a(this, this.options.legend);\n      });\n    }, T;\n  }), i(e, "Core/Legend/LegendSymbol.js", [e["Core/Utilities.js"]], function (t) {\n    var e;\n    let {\n      extend: i,\n      merge: s,\n      pick: o\n    } = t;\n    return function (t) {\n      function e(t, e, r) {\n        let a = this.legendItem = this.legendItem || {},\n          {\n            chart: n,\n            options: l\n          } = this,\n          {\n            baseline: h = 0,\n            symbolWidth: d,\n            symbolHeight: c\n          } = t,\n          p = this.symbol || "circle",\n          u = c / 2,\n          g = n.renderer,\n          f = a.group,\n          m = h - Math.round(c * (r ? .4 : .3)),\n          x = {},\n          y,\n          b = l.marker,\n          v = 0;\n        if (n.styledMode || (x["stroke-width"] = Math.min(l.lineWidth || 0, 24), l.dashStyle ? x.dashstyle = l.dashStyle : "square" === l.linecap || (x["stroke-linecap"] = "round")), a.line = g.path().addClass("highcharts-graph").attr(x).add(f), r && (a.area = g.path().addClass("highcharts-area").add(f)), x["stroke-linecap"] && (v = Math.min(a.line.strokeWidth(), d) / 2), d) {\n          let t = [["M", v, m], ["L", d - v, m]];\n          a.line.attr({\n            d: t\n          }), a.area?.attr({\n            d: [...t, ["L", d - v, h], ["L", v, h]]\n          });\n        }\n        if (b && !1 !== b.enabled && d) {\n          let t = Math.min(o(b.radius, u), u);\n          0 === p.indexOf("url") && (b = s(b, {\n            width: c,\n            height: c\n          }), t = 0), a.symbol = y = g.symbol(p, d / 2 - t, m - t, 2 * t, 2 * t, i({\n            context: "legend"\n          }, b)).addClass("highcharts-point").add(f), y.isMarker = !0;\n        }\n      }\n      t.areaMarker = function (t, i) {\n        e.call(this, t, i, !0);\n      }, t.lineMarker = e, t.rectangle = function (t, e) {\n        let i = e.legendItem || {},\n          s = t.options,\n          r = t.symbolHeight,\n          a = s.squareSymbol,\n          n = a ? r : t.symbolWidth;\n        i.symbol = this.chart.renderer.rect(a ? (t.symbolWidth - r) / 2 : 0, t.baseline - r + 1, n, r, o(t.options.symbolRadius, r / 2)).addClass("highcharts-point").attr({\n          zIndex: 3\n        }).add(i.group);\n      };\n    }(e || (e = {})), e;\n  }), i(e, "Core/Series/SeriesDefaults.js", [], function () {\n    return {\n      lineWidth: 2,\n      allowPointSelect: !1,\n      crisp: !0,\n      showCheckbox: !1,\n      animation: {\n        duration: 1e3\n      },\n      enableMouseTracking: !0,\n      events: {},\n      marker: {\n        enabledThreshold: 2,\n        lineColor: "#ffffff",\n        lineWidth: 0,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 150\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: "#cccccc",\n            lineColor: "#000000",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        animation: {},\n        align: "center",\n        borderWidth: 0,\n        defer: !0,\n        formatter: function () {\n          let {\n            numberFormatter: t\n          } = this.series.chart;\n          return "number" != typeof this.y ? "" : t(this.y, -1);\n        },\n        padding: 5,\n        style: {\n          fontSize: "0.7em",\n          fontWeight: "bold",\n          color: "contrast",\n          textOutline: "1px contrast"\n        },\n        verticalAlign: "bottom",\n        x: 0,\n        y: 0\n      },\n      cropThreshold: 300,\n      opacity: 1,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 150\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          animation: {\n            duration: 0\n          }\n        },\n        inactive: {\n          animation: {\n            duration: 150\n          },\n          opacity: .2\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1e3,\n      findNearestPointBy: "x"\n    };\n  }), i(e, "Core/Series/SeriesRegistry.js", [e["Core/Globals.js"], e["Core/Defaults.js"], e["Core/Series/Point.js"], e["Core/Utilities.js"]], function (t, e, i, s) {\n    var o;\n    let {\n        defaultOptions: r\n      } = e,\n      {\n        extendClass: a,\n        merge: n\n      } = s;\n    return function (e) {\n      function s(t, s) {\n        let o = r.plotOptions || {},\n          a = s.defaultOptions,\n          n = s.prototype;\n        n.type = t, n.pointClass || (n.pointClass = i), a && (o[t] = a), e.seriesTypes[t] = s;\n      }\n      e.seriesTypes = t.seriesTypes, e.registerSeriesType = s, e.seriesType = function (t, o, l, h, d) {\n        let c = r.plotOptions || {};\n        return o = o || "", c[t] = n(c[o], l), s(t, a(e.seriesTypes[o] || function () {}, h)), e.seriesTypes[t].prototype.type = t, d && (e.seriesTypes[t].prototype.pointClass = a(i, d)), e.seriesTypes[t];\n      };\n    }(o || (o = {})), o;\n  }), i(e, "Core/Series/Series.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Defaults.js"], e["Core/Foundation.js"], e["Core/Globals.js"], e["Core/Legend/LegendSymbol.js"], e["Core/Series/Point.js"], e["Core/Series/SeriesDefaults.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, r, a, n, l, h) {\n    let {\n        animObject: d,\n        setAnimation: c\n      } = t,\n      {\n        defaultOptions: p\n      } = e,\n      {\n        registerEventOptions: u\n      } = i,\n      {\n        hasTouch: g,\n        svg: f,\n        win: m\n      } = s,\n      {\n        seriesTypes: x\n      } = n,\n      {\n        arrayMax: y,\n        arrayMin: b,\n        clamp: v,\n        correctFloat: M,\n        defined: S,\n        destroyObjectProperties: k,\n        diffObjects: C,\n        erase: A,\n        error: w,\n        extend: T,\n        find: P,\n        fireEvent: L,\n        getClosestDistance: D,\n        getNestedProperty: O,\n        insertItem: E,\n        isArray: B,\n        isNumber: j,\n        isString: I,\n        merge: R,\n        objectEach: z,\n        pick: G,\n        removeEvent: W,\n        splat: N,\n        syncTimeout: X\n      } = h;\n    class H {\n      constructor() {\n        this.zoneAxis = "y";\n      }\n      init(t, e) {\n        let i;\n        L(this, "init", {\n          options: e\n        });\n        let s = this,\n          o = t.series;\n        this.eventsToUnbind = [], s.chart = t, s.options = s.setOptions(e);\n        let r = s.options,\n          a = !1 !== r.visible;\n        s.linkedSeries = [], s.bindAxes(), T(s, {\n          name: r.name,\n          state: "",\n          visible: a,\n          selected: !0 === r.selected\n        }), u(this, r);\n        let n = r.events;\n        (n && n.click || r.point && r.point.events && r.point.events.click || r.allowPointSelect) && (t.runTrackerClick = !0), s.getColor(), s.getSymbol(), s.parallelArrays.forEach(function (t) {\n          s[t + "Data"] || (s[t + "Data"] = []);\n        }), s.isCartesian && (t.hasCartesianSeries = !0), o.length && (i = o[o.length - 1]), s._i = G(i && i._i, -1) + 1, s.opacity = s.options.opacity, t.orderItems("series", E(this, o)), r.dataSorting && r.dataSorting.enabled ? s.setDataSortingOptions() : s.points || s.data || s.setData(r.data, !1), L(this, "afterInit");\n      }\n      is(t) {\n        return x[t] && this instanceof x[t];\n      }\n      bindAxes() {\n        let t;\n        let e = this,\n          i = e.options,\n          s = e.chart;\n        L(this, "bindAxes", null, function () {\n          (e.axisTypes || []).forEach(function (o) {\n            s[o].forEach(function (s) {\n              t = s.options, (G(i[o], 0) === s.index || void 0 !== i[o] && i[o] === t.id) && (E(e, s.series), e[o] = s, s.isDirty = !0);\n            }), e[o] || e.optionalAxis === o || w(18, !0, s);\n          });\n        }), L(this, "afterBindAxes");\n      }\n      updateParallelArrays(t, e, i) {\n        let s = t.series,\n          o = j(e) ? function (i) {\n            let o = "y" === i && s.toYData ? s.toYData(t) : t[i];\n            s[i + "Data"][e] = o;\n          } : function (t) {\n            Array.prototype[e].apply(s[t + "Data"], i);\n          };\n        s.parallelArrays.forEach(o);\n      }\n      hasData() {\n        return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin || this.visible && this.yData && this.yData.length > 0;\n      }\n      hasMarkerChanged(t, e) {\n        let i = t.marker,\n          s = e.marker || {};\n        return i && (s.enabled && !i.enabled || s.symbol !== i.symbol || s.height !== i.height || s.width !== i.width);\n      }\n      autoIncrement(t) {\n        let e = this.options,\n          i = e.pointIntervalUnit,\n          s = e.relativeXValue,\n          o = this.chart.time,\n          r = this.xIncrement,\n          a,\n          n;\n        return (r = G(r, e.pointStart, 0), this.pointInterval = n = G(this.pointInterval, e.pointInterval, 1), s && j(t) && (n *= t), i && (a = new o.Date(r), "day" === i ? o.set("Date", a, o.get("Date", a) + n) : "month" === i ? o.set("Month", a, o.get("Month", a) + n) : "year" === i && o.set("FullYear", a, o.get("FullYear", a) + n), n = a.getTime() - r), s && j(t)) ? r + n : (this.xIncrement = r + n, r);\n      }\n      setDataSortingOptions() {\n        let t = this.options;\n        T(this, {\n          requireSorting: !1,\n          sorted: !1,\n          enabledDataSorting: !0,\n          allowDG: !1\n        }), S(t.pointRange) || (t.pointRange = 1);\n      }\n      setOptions(t) {\n        let e;\n        let i = this.chart,\n          s = i.options,\n          o = s.plotOptions,\n          r = i.userOptions || {},\n          a = R(t),\n          n = i.styledMode,\n          l = {\n            plotOptions: o,\n            userOptions: a\n          };\n        L(this, "setOptions", l);\n        let h = l.plotOptions[this.type],\n          d = r.plotOptions || {},\n          c = d.series || {},\n          u = p.plotOptions[this.type] || {},\n          g = d[this.type] || {};\n        this.userOptions = l.userOptions;\n        let f = R(h, o.series, g, a);\n        this.tooltipOptions = R(p.tooltip, p.plotOptions.series?.tooltip, u?.tooltip, i.userOptions.tooltip, d.series?.tooltip, g.tooltip, a.tooltip), this.stickyTracking = G(a.stickyTracking, g.stickyTracking, c.stickyTracking, !!this.tooltipOptions.shared && !this.noSharedTooltip || f.stickyTracking), null === h.marker && delete f.marker, this.zoneAxis = f.zoneAxis || "y";\n        let m = this.zones = (f.zones || []).slice();\n        return (f.negativeColor || f.negativeFillColor) && !f.zones && (e = {\n          value: f[this.zoneAxis + "Threshold"] || f.threshold || 0,\n          className: "highcharts-negative"\n        }, n || (e.color = f.negativeColor, e.fillColor = f.negativeFillColor), m.push(e)), m.length && S(m[m.length - 1].value) && m.push(n ? {} : {\n          color: this.color,\n          fillColor: this.fillColor\n        }), L(this, "afterSetOptions", {\n          options: f\n        }), f;\n      }\n      getName() {\n        return G(this.options.name, "Series " + (this.index + 1));\n      }\n      getCyclic(t, e, i) {\n        let s, o;\n        let r = this.chart,\n          a = `${t}Index`,\n          n = `${t}Counter`,\n          l = i?.length || r.options.chart.colorCount;\n        !e && (S(o = G("color" === t ? this.options.colorIndex : void 0, this[a])) ? s = o : (r.series.length || (r[n] = 0), s = r[n] % l, r[n] += 1), i && (e = i[s])), void 0 !== s && (this[a] = s), this[t] = e;\n      }\n      getColor() {\n        this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || p.plotOptions[this.type].color, this.chart.options.colors);\n      }\n      getPointsCollection() {\n        return (this.hasGroupedData ? this.points : this.data) || [];\n      }\n      getSymbol() {\n        let t = this.options.marker;\n        this.getCyclic("symbol", t.symbol, this.chart.options.symbols);\n      }\n      findPointIndex(t, e) {\n        let i, s, o;\n        let a = t.id,\n          n = t.x,\n          l = this.points,\n          h = this.options.dataSorting;\n        if (a) {\n          let t = this.chart.get(a);\n          t instanceof r && (i = t);\n        } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {\n          let e = e => !e.touched && e.index === t.index;\n          if (h && h.matchByName ? e = e => !e.touched && e.name === t.name : this.options.relativeXValue && (e = e => !e.touched && e.options.x === t.x), !(i = P(l, e))) return;\n        }\n        return i && void 0 !== (o = i && i.index) && (s = !0), void 0 === o && j(n) && (o = this.xData.indexOf(n, e)), -1 !== o && void 0 !== o && this.cropped && (o = o >= this.cropStart ? o - this.cropStart : o), !s && j(o) && l[o] && l[o].touched && (o = void 0), o;\n      }\n      updateData(t, e) {\n        let i = this.options,\n          s = i.dataSorting,\n          o = this.points,\n          r = [],\n          a = this.requireSorting,\n          n = t.length === o.length,\n          l,\n          h,\n          d,\n          c,\n          p = !0;\n        if (this.xIncrement = null, t.forEach(function (t, e) {\n          let h;\n          let d = S(t) && this.pointClass.prototype.optionsToObject.call({\n              series: this\n            }, t) || {},\n            p = d.x,\n            u = d.id;\n          u || j(p) ? (-1 === (h = this.findPointIndex(d, c)) || void 0 === h ? r.push(t) : o[h] && t !== i.data[h] ? (o[h].update(t, !1, null, !1), o[h].touched = !0, a && (c = h + 1)) : o[h] && (o[h].touched = !0), (!n || e !== h || s && s.enabled || this.hasDerivedData) && (l = !0)) : r.push(t);\n        }, this), l) for (h = o.length; h--;) (d = o[h]) && !d.touched && d.remove && d.remove(!1, e);else !n || s && s.enabled ? p = !1 : (t.forEach(function (t, e) {\n          t === o[e].y || o[e].destroyed || o[e].update(t, !1, null, !1);\n        }), r.length = 0);\n        return o.forEach(function (t) {\n          t && (t.touched = !1);\n        }), !!p && (r.forEach(function (t) {\n          this.addPoint(t, !1, null, null, !1);\n        }, this), null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = y(this.xData), this.autoIncrement()), !0);\n      }\n      setData(t, e = !0, i, s) {\n        let o = this,\n          r = o.points,\n          a = r && r.length || 0,\n          n = o.options,\n          l = o.chart,\n          h = n.dataSorting,\n          d = o.xAxis,\n          c = n.turboThreshold,\n          p = this.xData,\n          u = this.yData,\n          g = o.pointArrayMap,\n          f = g && g.length,\n          m = n.keys,\n          x,\n          y,\n          b,\n          v = 0,\n          M = 1,\n          S = null,\n          k;\n        l.options.chart.allowMutatingData || (n.data && delete o.options.data, o.userOptions.data && delete o.userOptions.data, k = R(!0, t)), t = k || t || [];\n        let C = t.length;\n        if (h && h.enabled && (t = this.sortData(t)), l.options.chart.allowMutatingData && !1 !== s && C && a && !o.cropped && !o.hasGroupedData && o.visible && !o.boosted && (b = this.updateData(t, i)), !b) {\n          if (o.xIncrement = null, o.colorCounter = 0, this.parallelArrays.forEach(function (t) {\n            o[t + "Data"].length = 0;\n          }), c && C > c) {\n            if (j(S = o.getFirstValidPoint(t))) for (x = 0; x < C; x++) p[x] = this.autoIncrement(), u[x] = t[x];else if (B(S)) {\n              if (f) {\n                if (S.length === f) for (x = 0; x < C; x++) p[x] = this.autoIncrement(), u[x] = t[x];else for (x = 0; x < C; x++) y = t[x], p[x] = y[0], u[x] = y.slice(1, f + 1);\n              } else if (m && (v = m.indexOf("x"), M = m.indexOf("y"), v = v >= 0 ? v : 0, M = M >= 0 ? M : 1), 1 === S.length && (M = 0), v === M) for (x = 0; x < C; x++) p[x] = this.autoIncrement(), u[x] = t[x][M];else for (x = 0; x < C; x++) y = t[x], p[x] = y[v], u[x] = y[M];\n            } else w(12, !1, l);\n          } else for (x = 0; x < C; x++) y = {\n            series: o\n          }, o.pointClass.prototype.applyOptions.apply(y, [t[x]]), o.updateParallelArrays(y, x);\n          for (u && I(u[0]) && w(14, !0, l), o.data = [], o.options.data = o.userOptions.data = t, x = a; x--;) r[x]?.destroy();\n          d && (d.minRange = d.userMinRange), o.isDirty = l.isDirtyBox = !0, o.isDirtyData = !!r, i = !1;\n        }\n        "point" === n.legendType && (this.processData(), this.generatePoints()), e && l.redraw(i);\n      }\n      sortData(t) {\n        let e = this,\n          i = e.options,\n          s = i.dataSorting,\n          o = s.sortKey || "y",\n          r = function (t, e) {\n            return S(e) && t.pointClass.prototype.optionsToObject.call({\n              series: t\n            }, e) || {};\n          };\n        t.forEach(function (i, s) {\n          t[s] = r(e, i), t[s].index = s;\n        }, this);\n        let a = t.concat().sort((t, e) => {\n          let i = O(o, t),\n            s = O(o, e);\n          return s < i ? -1 : s > i ? 1 : 0;\n        });\n        return a.forEach(function (t, e) {\n          t.x = e;\n        }, this), e.linkedSeries && e.linkedSeries.forEach(function (e) {\n          let i = e.options,\n            s = i.data;\n          i.dataSorting && i.dataSorting.enabled || !s || (s.forEach(function (i, o) {\n            s[o] = r(e, i), t[o] && (s[o].x = t[o].x, s[o].index = o);\n          }), e.setData(s, !1));\n        }), t;\n      }\n      getProcessedData(t) {\n        let e = this,\n          i = e.xAxis,\n          s = e.options,\n          o = s.cropThreshold,\n          r = t || e.getExtremesFromAll || s.getExtremesFromAll,\n          a = i?.logarithmic,\n          n = e.isCartesian,\n          l,\n          h,\n          d = 0,\n          c,\n          p,\n          u,\n          g = e.xData,\n          f = e.yData,\n          m = !1,\n          x = g.length;\n        i && (p = (c = i.getExtremes()).min, u = c.max, m = !!(i.categories && !i.names.length)), n && e.sorted && !r && (!o || x > o || e.forceCrop) && (g[x - 1] < p || g[0] > u ? (g = [], f = []) : e.yData && (g[0] < p || g[x - 1] > u) && (g = (l = this.cropData(e.xData, e.yData, p, u)).xData, f = l.yData, d = l.start, h = !0));\n        let y = D([a ? g.map(a.log2lin) : g], () => e.requireSorting && !m && w(15, !1, e.chart));\n        return {\n          xData: g,\n          yData: f,\n          cropped: h,\n          cropStart: d,\n          closestPointRange: y\n        };\n      }\n      processData(t) {\n        let e = this.xAxis;\n        if (this.isCartesian && !this.isDirty && !e.isDirty && !this.yAxis.isDirty && !t) return !1;\n        let i = this.getProcessedData();\n        this.cropped = i.cropped, this.cropStart = i.cropStart, this.processedXData = i.xData, this.processedYData = i.yData, this.closestPointRange = this.basePointRange = i.closestPointRange, L(this, "afterProcessData");\n      }\n      cropData(t, e, i, s) {\n        let o = t.length,\n          r,\n          a,\n          n = 0,\n          l = o;\n        for (r = 0; r < o; r++) if (t[r] >= i) {\n          n = Math.max(0, r - 1);\n          break;\n        }\n        for (a = r; a < o; a++) if (t[a] > s) {\n          l = a + 1;\n          break;\n        }\n        return {\n          xData: t.slice(n, l),\n          yData: e.slice(n, l),\n          start: n,\n          end: l\n        };\n      }\n      generatePoints() {\n        let t = this.options,\n          e = this.processedData || t.data,\n          i = this.processedXData,\n          s = this.processedYData,\n          o = this.pointClass,\n          r = i.length,\n          a = this.cropStart || 0,\n          n = this.hasGroupedData,\n          l = t.keys,\n          h = [],\n          d = t.dataGrouping && t.dataGrouping.groupAll ? a : 0,\n          c,\n          p,\n          u,\n          g,\n          f = this.data;\n        if (!f && !n) {\n          let t = [];\n          t.length = e.length, f = this.data = t;\n        }\n        for (l && n && (this.options.keys = !1), g = 0; g < r; g++) p = a + g, n ? ((u = new o(this, [i[g]].concat(N(s[g])))).dataGroup = this.groupMap[d + g], u.dataGroup.options && (u.options = u.dataGroup.options, T(u, u.dataGroup.options), delete u.dataLabels)) : (u = f[p]) || void 0 === e[p] || (f[p] = u = new o(this, e[p], i[g])), u && (u.index = n ? d + g : p, h[g] = u);\n        if (this.options.keys = l, f && (r !== (c = f.length) || n)) for (g = 0; g < c; g++) g !== a || n || (g += r), f[g] && (f[g].destroyElements(), f[g].plotX = void 0);\n        this.data = f, this.points = h, L(this, "afterGeneratePoints");\n      }\n      getXExtremes(t) {\n        return {\n          min: b(t),\n          max: y(t)\n        };\n      }\n      getExtremes(t, e) {\n        let i = this.xAxis,\n          s = this.yAxis,\n          o = this.processedXData || this.xData,\n          r = [],\n          a = this.requireSorting && !this.is("column") ? 1 : 0,\n          n = !!s && s.positiveValuesOnly,\n          l,\n          h,\n          d,\n          c,\n          p,\n          u,\n          g,\n          f = 0,\n          m = 0,\n          x = 0;\n        t = t || this.stackedYData || this.processedYData || [];\n        let v = t.length;\n        for (i && (f = (l = i.getExtremes()).min, m = l.max), u = 0; u < v; u++) if (c = o[u], h = (j(p = t[u]) || B(p)) && ((j(p) ? p > 0 : p.length) || !n), d = e || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !i || (o[u + a] || c) >= f && (o[u - a] || c) <= m, h && d) {\n          if (g = p.length) for (; g--;) j(p[g]) && (r[x++] = p[g]);else r[x++] = p;\n        }\n        let M = {\n          activeYData: r,\n          dataMin: b(r),\n          dataMax: y(r)\n        };\n        return L(this, "afterGetExtremes", {\n          dataExtremes: M\n        }), M;\n      }\n      applyExtremes() {\n        let t = this.getExtremes();\n        return this.dataMin = t.dataMin, this.dataMax = t.dataMax, t;\n      }\n      getFirstValidPoint(t) {\n        let e = t.length,\n          i = 0,\n          s = null;\n        for (; null === s && i < e;) s = t[i], i++;\n        return s;\n      }\n      translate() {\n        this.processedXData || this.processData(), this.generatePoints();\n        let t = this.options,\n          e = t.stacking,\n          i = this.xAxis,\n          s = i.categories,\n          o = this.enabledDataSorting,\n          r = this.yAxis,\n          a = this.points,\n          n = a.length,\n          l = this.pointPlacementToXValue(),\n          h = !!l,\n          d = t.threshold,\n          c = t.startFromThreshold ? d : 0,\n          p,\n          u,\n          g,\n          f,\n          m = Number.MAX_VALUE;\n        function x(t) {\n          return v(t, -1e5, 1e5);\n        }\n        for (p = 0; p < n; p++) {\n          let t;\n          let n = a[p],\n            y = n.x,\n            b,\n            v,\n            k = n.y,\n            C = n.low,\n            A = e && r.stacking?.stacks[(this.negStacks && k < (c ? 0 : d) ? "-" : "") + this.stackKey];\n          u = i.translate(y, !1, !1, !1, !0, l), n.plotX = j(u) ? M(x(u)) : void 0, e && this.visible && A && A[y] && (f = this.getStackIndicator(f, y, this.index), !n.isNull && f.key && (v = (b = A[y]).points[f.key]), b && B(v) && (C = v[0], k = v[1], C === c && f.key === A[y].base && (C = G(j(d) ? d : r.min)), r.positiveValuesOnly && S(C) && C <= 0 && (C = void 0), n.total = n.stackTotal = G(b.total), n.percentage = S(n.y) && b.total ? n.y / b.total * 100 : void 0, n.stackY = k, this.irregularWidths || b.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis))), n.yBottom = S(C) ? x(r.translate(C, !1, !0, !1, !0)) : void 0, this.dataModify && (k = this.dataModify.modifyValue(k, p)), j(k) && void 0 !== n.plotX && (t = j(t = r.translate(k, !1, !0, !1, !0)) ? x(t) : void 0), n.plotY = t, n.isInside = this.isPointInside(n), n.clientX = h ? M(i.translate(y, !1, !1, !1, !0, l)) : u, n.negative = (n.y || 0) < (d || 0), n.category = G(s && s[n.x], n.x), n.isNull || !1 === n.visible || (void 0 !== g && (m = Math.min(m, Math.abs(u - g))), g = u), n.zone = this.zones.length ? n.getZone() : void 0, !n.graphic && this.group && o && (n.isNew = !0);\n        }\n        this.closestPointRangePx = m, L(this, "afterTranslate");\n      }\n      getValidPoints(t, e, i) {\n        let s = this.chart;\n        return (t || this.points || []).filter(function (t) {\n          let {\n              plotX: o,\n              plotY: r\n            } = t,\n            a = !i && (t.isNull || !j(r));\n          return !a && (!e || !!s.isInsidePlot(o, r, {\n            inverted: s.inverted\n          })) && !1 !== t.visible;\n        });\n      }\n      getClipBox() {\n        let {\n            chart: t,\n            xAxis: e,\n            yAxis: i\n          } = this,\n          s = R(t.clipBox);\n        return e && e.len !== t.plotSizeX && (s.width = e.len), i && i.len !== t.plotSizeY && (s.height = i.len), s;\n      }\n      getSharedClipKey() {\n        return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0), this.sharedClipKey;\n      }\n      setClip() {\n        let {\n            chart: t,\n            group: e,\n            markerGroup: i\n          } = this,\n          s = t.sharedClips,\n          o = t.renderer,\n          r = this.getClipBox(),\n          a = this.getSharedClipKey(),\n          n = s[a];\n        n ? n.animate(r) : s[a] = n = o.clipRect(r), e && e.clip(!1 === this.options.clip ? void 0 : n), i && i.clip();\n      }\n      animate(t) {\n        let {\n            chart: e,\n            group: i,\n            markerGroup: s\n          } = this,\n          o = e.inverted,\n          r = d(this.options.animation),\n          a = [this.getSharedClipKey(), r.duration, r.easing, r.defer].join(","),\n          n = e.sharedClips[a],\n          l = e.sharedClips[a + "m"];\n        if (t && i) {\n          let t = this.getClipBox();\n          if (n) n.attr("height", t.height);else {\n            t.width = 0, o && (t.x = e.plotHeight), n = e.renderer.clipRect(t), e.sharedClips[a] = n;\n            let i = {\n              x: -99,\n              y: -99,\n              width: o ? e.plotWidth + 199 : 99,\n              height: o ? 99 : e.plotHeight + 199\n            };\n            l = e.renderer.clipRect(i), e.sharedClips[a + "m"] = l;\n          }\n          i.clip(n), s && s.clip(l);\n        } else if (n && !n.hasClass("highcharts-animating")) {\n          let t = this.getClipBox(),\n            e = r.step;\n          s && s.element.childNodes.length && (r.step = function (t, i) {\n            e && e.apply(i, arguments), "width" === i.prop && l && l.element && l.attr(o ? "height" : "width", t + 99);\n          }), n.addClass("highcharts-animating").animate(t, r);\n        }\n      }\n      afterAnimate() {\n        this.setClip(), z(this.chart.sharedClips, (t, e, i) => {\n          t && !this.chart.container.querySelector(`[clip-path="url(#${t.id})"]`) && (t.destroy(), delete i[e]);\n        }), this.finishedAnimating = !0, L(this, "afterAnimate");\n      }\n      drawPoints(t = this.points) {\n        let e, i, s, o, r, a, n;\n        let l = this.chart,\n          h = l.styledMode,\n          {\n            colorAxis: d,\n            options: c\n          } = this,\n          p = c.marker,\n          u = this[this.specialGroup || "markerGroup"],\n          g = this.xAxis,\n          f = G(p.enabled, !g || !!g.isRadial || null, this.closestPointRangePx >= p.enabledThreshold * p.radius);\n        if (!1 !== p.enabled || this._hasPointMarkers) for (e = 0; e < t.length; e++) {\n          o = (s = (i = t[e]).graphic) ? "animate" : "attr", r = i.marker || {}, a = !!i.marker;\n          let c = (f && void 0 === r.enabled || r.enabled) && !i.isNull && !1 !== i.visible;\n          if (c) {\n            let t = G(r.symbol, this.symbol, "rect");\n            n = this.markerAttribs(i, i.selected && "select"), this.enabledDataSorting && (i.startXPos = g.reversed ? -(n.width || 0) : g.width);\n            let e = !1 !== i.isInside;\n            if (!s && e && ((n.width || 0) > 0 || i.hasImage) && (i.graphic = s = l.renderer.symbol(t, n.x, n.y, n.width, n.height, a ? r : p).add(u), this.enabledDataSorting && l.hasRendered && (s.attr({\n              x: i.startXPos\n            }), o = "animate")), s && "animate" === o && s[e ? "show" : "hide"](e).animate(n), s) {\n              let t = this.pointAttribs(i, h || !i.selected ? void 0 : "select");\n              h ? d && s.css({\n                fill: t.fill\n              }) : s[o](t);\n            }\n            s && s.addClass(i.getClassName(), !0);\n          } else s && (i.graphic = s.destroy());\n        }\n      }\n      markerAttribs(t, e) {\n        let i = this.options,\n          s = i.marker,\n          o = t.marker || {},\n          r = o.symbol || s.symbol,\n          a = {},\n          n,\n          l,\n          h = G(o.radius, s && s.radius);\n        e && (n = s.states[e], h = G((l = o.states && o.states[e]) && l.radius, n && n.radius, h && h + (n && n.radiusPlus || 0))), t.hasImage = r && 0 === r.indexOf("url"), t.hasImage && (h = 0);\n        let d = t.pos();\n        return j(h) && d && (a.x = d[0] - h, a.y = d[1] - h, i.crisp && (a.x = Math.floor(a.x))), h && (a.width = a.height = 2 * h), a;\n      }\n      pointAttribs(t, e) {\n        let i = this.options.marker,\n          s = t && t.options,\n          o = s && s.marker || {},\n          r = s && s.color,\n          a = t && t.color,\n          n = t && t.zone && t.zone.color,\n          l,\n          h,\n          d = this.color,\n          c,\n          p,\n          u = G(o.lineWidth, i.lineWidth),\n          g = 1;\n        return d = r || n || a || d, c = o.fillColor || i.fillColor || d, p = o.lineColor || i.lineColor || d, e = e || "normal", l = i.states[e] || {}, u = G((h = o.states && o.states[e] || {}).lineWidth, l.lineWidth, u + G(h.lineWidthPlus, l.lineWidthPlus, 0)), c = h.fillColor || l.fillColor || c, {\n          stroke: p = h.lineColor || l.lineColor || p,\n          "stroke-width": u,\n          fill: c,\n          opacity: g = G(h.opacity, l.opacity, g)\n        };\n      }\n      destroy(t) {\n        let e, i, s;\n        let o = this,\n          r = o.chart,\n          a = /AppleWebKit\\/533/.test(m.navigator.userAgent),\n          n = o.data || [];\n        for (L(o, "destroy", {\n          keepEventsForUpdate: t\n        }), this.removeEvents(t), (o.axisTypes || []).forEach(function (t) {\n          (s = o[t]) && s.series && (A(s.series, o), s.isDirty = s.forceRedraw = !0);\n        }), o.legendItem && o.chart.legend.destroyItem(o), e = n.length; e--;) (i = n[e]) && i.destroy && i.destroy();\n        o.zones.forEach(k), h.clearTimeout(o.animationTimeout), z(o, function (t, e) {\n          t instanceof l && !t.survive && t[a && "group" === e ? "hide" : "destroy"]();\n        }), r.hoverSeries === o && (r.hoverSeries = void 0), A(r.series, o), r.orderItems("series"), z(o, function (e, i) {\n          t && "hcEvents" === i || delete o[i];\n        });\n      }\n      applyZones() {\n        let {\n            area: t,\n            chart: e,\n            graph: i,\n            zones: s,\n            points: o,\n            xAxis: r,\n            yAxis: a,\n            zoneAxis: n\n          } = this,\n          {\n            inverted: l,\n            renderer: h\n          } = e,\n          d = this[`${n}Axis`],\n          {\n            isXAxis: c,\n            len: p = 0\n          } = d || {},\n          u = (i?.strokeWidth() || 0) / 2 + 1,\n          g = (t, e = 0, i = 0) => {\n            l && (i = p - i);\n            let {\n                translated: s = 0,\n                lineClip: o\n              } = t,\n              r = i - s;\n            o?.push(["L", e, Math.abs(r) < u ? i - u * (r <= 0 ? -1 : 1) : s]);\n          };\n        if (s.length && (i || t) && d && j(d.min)) {\n          let e = d.getExtremes().max,\n            u = t => {\n              t.forEach((e, i) => {\n                ("M" === e[0] || "L" === e[0]) && (t[i] = [e[0], c ? p - e[1] : e[1], c ? e[2] : p - e[2]]);\n              });\n            };\n          if (s.forEach((t, i) => {\n            t.lineClip = [], t.translated = v(d.toPixels(G(t.value, e), !0) || 0, 0, p);\n          }), i && !this.showLine && i.hide(), t && t.hide(), "y" === n && o.length < r.len) for (let t of o) {\n            let {\n                plotX: e,\n                plotY: i,\n                zone: o\n              } = t,\n              r = o && s[s.indexOf(o) - 1];\n            o && g(o, e, i), r && g(r, e, i);\n          }\n          let f = [],\n            m = d.toPixels(d.getExtremes().min, !0);\n          s.forEach(e => {\n            let s = e.lineClip || [],\n              o = Math.round(e.translated || 0);\n            r.reversed && s.reverse();\n            let {\n                clip: n,\n                simpleClip: d\n              } = e,\n              p = 0,\n              g = 0,\n              x = r.len,\n              y = a.len;\n            c ? (p = o, x = m) : (g = o, y = m);\n            let b = [["M", p, g], ["L", x, g], ["L", x, y], ["L", p, y], ["Z"]],\n              v = [b[0], ...s, b[1], b[2], ...f, b[3], b[4]];\n            f = s.reverse(), m = o, l && (u(v), t && u(b)), n ? (n.animate({\n              d: v\n            }), d?.animate({\n              d: b\n            })) : (n = e.clip = h.path(v), t && (d = e.simpleClip = h.path(b))), i && e.graph?.clip(n), t && e.area?.clip(d);\n          });\n        } else this.visible && (i && i.show(), t && t.show());\n      }\n      plotGroup(t, e, i, s, o) {\n        let r = this[t],\n          a = !r,\n          n = {\n            visibility: i,\n            zIndex: s || .1\n          };\n        return S(this.opacity) && !this.chart.styledMode && "inactive" !== this.state && (n.opacity = this.opacity), r || (this[t] = r = this.chart.renderer.g().add(o)), r.addClass("highcharts-" + e + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (S(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (r.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0), r.attr(n)[a ? "attr" : "animate"](this.getPlotBox(e)), r;\n      }\n      getPlotBox(t) {\n        let e = this.xAxis,\n          i = this.yAxis,\n          s = this.chart,\n          o = s.inverted && !s.polar && e && !1 !== this.invertible && "series" === t;\n        return s.inverted && (e = i, i = this.xAxis), {\n          translateX: e ? e.left : s.plotLeft,\n          translateY: i ? i.top : s.plotTop,\n          rotation: o ? 90 : 0,\n          rotationOriginX: o ? (e.len - i.len) / 2 : 0,\n          rotationOriginY: o ? (e.len + i.len) / 2 : 0,\n          scaleX: o ? -1 : 1,\n          scaleY: 1\n        };\n      }\n      removeEvents(t) {\n        let {\n          eventsToUnbind: e\n        } = this;\n        t || W(this), e.length && (e.forEach(t => {\n          t();\n        }), e.length = 0);\n      }\n      render() {\n        let t = this,\n          {\n            chart: e,\n            options: i,\n            hasRendered: s\n          } = t,\n          o = d(i.animation),\n          r = t.visible ? "inherit" : "hidden",\n          a = i.zIndex,\n          n = e.seriesGroup,\n          l = t.finishedAnimating ? 0 : o.duration;\n        L(this, "render"), t.plotGroup("group", "series", r, a, n), t.markerGroup = t.plotGroup("markerGroup", "markers", r, a, n), !1 !== i.clip && t.setClip(), l && t.animate?.(!0), t.drawGraph && (t.drawGraph(), t.applyZones()), t.visible && t.drawPoints(), t.drawDataLabels?.(), t.redrawPoints?.(), i.enableMouseTracking && t.drawTracker?.(), l && t.animate?.(), s || (l && o.defer && (l += o.defer), t.animationTimeout = X(() => {\n          t.afterAnimate();\n        }, l || 0)), t.isDirty = !1, t.hasRendered = !0, L(t, "afterRender");\n      }\n      redraw() {\n        let t = this.isDirty || this.isDirtyData;\n        this.translate(), this.render(), t && delete this.kdTree;\n      }\n      reserveSpace() {\n        return this.visible || !this.chart.options.chart.ignoreHiddenSeries;\n      }\n      searchPoint(t, e) {\n        let {\n            xAxis: i,\n            yAxis: s\n          } = this,\n          o = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: o ? i.len - t.chartY + i.pos : t.chartX - i.pos,\n          plotY: o ? s.len - t.chartX + s.pos : t.chartY - s.pos\n        }, e, t);\n      }\n      buildKDTree(t) {\n        this.buildingKdTree = !0;\n        let e = this,\n          i = e.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;\n        delete e.kdTree, X(function () {\n          e.kdTree = function t(i, s, o) {\n            let r, a;\n            let n = i?.length;\n            if (n) return r = e.kdAxisArray[s % o], i.sort((t, e) => (t[r] || 0) - (e[r] || 0)), {\n              point: i[a = Math.floor(n / 2)],\n              left: t(i.slice(0, a), s + 1, o),\n              right: t(i.slice(a + 1), s + 1, o)\n            };\n          }(e.getValidPoints(void 0, !e.directTouch), i, i), e.buildingKdTree = !1;\n        }, e.options.kdNow || t?.type === "touchstart" ? 0 : 1);\n      }\n      searchKDTree(t, e, i) {\n        let s = this,\n          [o, r] = this.kdAxisArray,\n          a = e ? "distX" : "dist",\n          n = (s.options.findNearestPointBy || "").indexOf("y") > -1 ? 2 : 1,\n          l = !!s.isBubble;\n        if (this.kdTree || this.buildingKdTree || this.buildKDTree(i), this.kdTree) return function t(e, i, n, h) {\n          let d = i.point,\n            c = s.kdAxisArray[n % h],\n            p,\n            u,\n            g = d;\n          !function (t, e) {\n            let i = t[o],\n              s = e[o],\n              a = S(i) && S(s) ? i - s : null,\n              n = t[r],\n              h = e[r],\n              d = S(n) && S(h) ? n - h : 0,\n              c = l && e.marker?.radius || 0;\n            e.dist = Math.sqrt((a && a * a || 0) + d * d) - c, e.distX = S(a) ? Math.abs(a) - c : Number.MAX_VALUE;\n          }(e, d);\n          let f = (e[c] || 0) - (d[c] || 0) + (l && d.marker?.radius || 0),\n            m = f < 0 ? "left" : "right",\n            x = f < 0 ? "right" : "left";\n          return i[m] && (g = (p = t(e, i[m], n + 1, h))[a] < g[a] ? p : d), i[x] && Math.sqrt(f * f) < g[a] && (g = (u = t(e, i[x], n + 1, h))[a] < g[a] ? u : g), g;\n        }(t, this.kdTree, n, n);\n      }\n      pointPlacementToXValue() {\n        let {\n            options: t,\n            xAxis: e\n          } = this,\n          i = t.pointPlacement;\n        return "between" === i && (i = e.reversed ? -.5 : .5), j(i) ? i * (t.pointRange || e.pointRange) : 0;\n      }\n      isPointInside(t) {\n        let {\n            chart: e,\n            xAxis: i,\n            yAxis: s\n          } = this,\n          {\n            plotX: o = -1,\n            plotY: r = -1\n          } = t,\n          a = r >= 0 && r <= (s ? s.len : e.plotHeight) && o >= 0 && o <= (i ? i.len : e.plotWidth);\n        return a;\n      }\n      drawTracker() {\n        let t = this,\n          e = t.options,\n          i = e.trackByArea,\n          s = [].concat((i ? t.areaPath : t.graphPath) || []),\n          o = t.chart,\n          r = o.pointer,\n          a = o.renderer,\n          n = o.options.tooltip?.snap || 0,\n          l = () => {\n            e.enableMouseTracking && o.hoverSeries !== t && t.onMouseOver();\n          },\n          h = "rgba(192,192,192," + (f ? 1e-4 : .002) + ")",\n          d = t.tracker;\n        d ? d.attr({\n          d: s\n        }) : t.graph && (t.tracker = d = a.path(s).attr({\n          visibility: t.visible ? "inherit" : "hidden",\n          zIndex: 2\n        }).addClass(i ? "highcharts-tracker-area" : "highcharts-tracker-line").add(t.group), o.styledMode || d.attr({\n          "stroke-linecap": "round",\n          "stroke-linejoin": "round",\n          stroke: h,\n          fill: i ? h : "none",\n          "stroke-width": t.graph.strokeWidth() + (i ? 0 : 2 * n)\n        }), [t.tracker, t.markerGroup, t.dataLabelsGroup].forEach(t => {\n          t && (t.addClass("highcharts-tracker").on("mouseover", l).on("mouseout", t => {\n            r.onTrackerMouseOut(t);\n          }), e.cursor && !o.styledMode && t.css({\n            cursor: e.cursor\n          }), g && t.on("touchstart", l));\n        })), L(this, "afterDrawTracker");\n      }\n      addPoint(t, e, i, s, o) {\n        let r, a;\n        let n = this.options,\n          l = this.data,\n          h = this.chart,\n          d = this.xAxis,\n          c = d && d.hasNames && d.names,\n          p = n.data,\n          u = this.xData;\n        e = G(e, !0);\n        let g = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(g, [t]);\n        let f = g.x;\n        if (a = u.length, this.requireSorting && f < u[a - 1]) for (r = !0; a && u[a - 1] > f;) a--;\n        this.updateParallelArrays(g, "splice", [a, 0, 0]), this.updateParallelArrays(g, a), c && g.name && (c[f] = g.name), p.splice(a, 0, t), (r || this.processedData) && (this.data.splice(a, 0, null), this.processData()), "point" === n.legendType && this.generatePoints(), i && (l[0] && l[0].remove ? l[0].remove(!1) : (l.shift(), this.updateParallelArrays(g, "shift"), p.shift())), !1 !== o && L(this, "addPoint", {\n          point: g\n        }), this.isDirty = !0, this.isDirtyData = !0, e && h.redraw(s);\n      }\n      removePoint(t, e, i) {\n        let s = this,\n          o = s.data,\n          r = o[t],\n          a = s.points,\n          n = s.chart,\n          l = function () {\n            a && a.length === o.length && a.splice(t, 1), o.splice(t, 1), s.options.data.splice(t, 1), s.updateParallelArrays(r || {\n              series: s\n            }, "splice", [t, 1]), r && r.destroy(), s.isDirty = !0, s.isDirtyData = !0, e && n.redraw();\n          };\n        c(i, n), e = G(e, !0), r ? r.firePointEvent("remove", null, l) : l();\n      }\n      remove(t, e, i, s) {\n        let o = this,\n          r = o.chart;\n        function a() {\n          o.destroy(s), r.isDirtyLegend = r.isDirtyBox = !0, r.linkSeries(s), G(t, !0) && r.redraw(e);\n        }\n        !1 !== i ? L(o, "remove", null, a) : a();\n      }\n      update(t, e) {\n        L(this, "update", {\n          options: t = C(t, this.userOptions)\n        });\n        let i = this,\n          s = i.chart,\n          o = i.userOptions,\n          r = i.initialType || i.type,\n          a = s.options.plotOptions,\n          n = x[r].prototype,\n          l = i.finishedAnimating && {\n            animation: !1\n          },\n          h = {},\n          d,\n          c,\n          p = ["colorIndex", "eventOptions", "navigatorSeries", "symbolIndex", "baseSeries"],\n          u = t.type || o.type || s.options.chart.type,\n          g = !(this.hasDerivedData || u && u !== this.type || void 0 !== t.pointStart || void 0 !== t.pointInterval || void 0 !== t.relativeXValue || t.joinBy || t.mapData || ["dataGrouping", "pointStart", "pointInterval", "pointIntervalUnit", "keys"].some(t => i.hasOptionChanged(t)));\n        u = u || r, g && (p.push("data", "isDirtyData", "isDirtyCanvas", "points", "processedData", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "hasDataLabels", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), !1 !== t.visible && p.push("area", "graph"), i.parallelArrays.forEach(function (t) {\n          p.push(t + "Data");\n        }), t.data && (t.dataSorting && T(i.options.dataSorting, t.dataSorting), this.setData(t.data, !1))), t = R(o, {\n          index: void 0 === o.index ? i.index : o.index,\n          pointStart: a?.series?.pointStart ?? o.pointStart ?? i.xData?.[0]\n        }, !g && {\n          data: i.options.data\n        }, t, l), g && t.data && (t.data = i.options.data), (p = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(p)).forEach(function (t) {\n          p[t] = i[t], delete i[t];\n        });\n        let f = !1;\n        if (x[u]) {\n          if (f = u !== i.type, i.remove(!1, !1, !1, !0), f) {\n            if (Object.setPrototypeOf) Object.setPrototypeOf(i, x[u].prototype);else {\n              let t = Object.hasOwnProperty.call(i, "hcEvents") && i.hcEvents;\n              for (c in n) i[c] = void 0;\n              T(i, x[u].prototype), t ? i.hcEvents = t : delete i.hcEvents;\n            }\n          }\n        } else w(17, !0, s, {\n          missingModuleFor: u\n        });\n        if (p.forEach(function (t) {\n          i[t] = p[t];\n        }), i.init(s, t), g && this.points) for (let t of (!1 === (d = i.options).visible ? (h.graphic = 1, h.dataLabel = 1) : (this.hasMarkerChanged(d, o) && (h.graphic = 1), i.hasDataLabels?.() || (h.dataLabel = 1)), this.points)) t && t.series && (t.resolveColor(), Object.keys(h).length && t.destroyElements(h), !1 === d.showInLegend && t.legendItem && s.legend.destroyItem(t));\n        i.initialType = r, s.linkSeries(), s.setSortedData(), f && i.linkedSeries.length && (i.isDirtyData = !0), L(this, "afterUpdate"), G(e, !0) && s.redraw(!!g && void 0);\n      }\n      setName(t) {\n        this.name = this.options.name = this.userOptions.name = t, this.chart.isDirtyLegend = !0;\n      }\n      hasOptionChanged(t) {\n        let e = this.chart,\n          i = this.options[t],\n          s = e.options.plotOptions,\n          o = this.userOptions[t],\n          r = G(s?.[this.type]?.[t], s?.series?.[t]);\n        return o && !S(r) ? i !== o : i !== G(r, i);\n      }\n      onMouseOver() {\n        let t = this.chart,\n          e = t.hoverSeries,\n          i = t.pointer;\n        i.setHoverChartIndex(), e && e !== this && e.onMouseOut(), this.options.events.mouseOver && L(this, "mouseOver"), this.setState("hover"), t.hoverSeries = this;\n      }\n      onMouseOut() {\n        let t = this.options,\n          e = this.chart,\n          i = e.tooltip,\n          s = e.hoverPoint;\n        e.hoverSeries = null, s && s.onMouseOut(), this && t.events.mouseOut && L(this, "mouseOut"), i && !this.stickyTracking && (!i.shared || this.noSharedTooltip) && i.hide(), e.series.forEach(function (t) {\n          t.setState("", !0);\n        });\n      }\n      setState(t, e) {\n        let i = this,\n          s = i.options,\n          o = i.graph,\n          r = s.inactiveOtherPoints,\n          a = s.states,\n          n = G(a[t || "normal"] && a[t || "normal"].animation, i.chart.options.chart.animation),\n          l = s.lineWidth,\n          h = s.opacity;\n        if (t = t || "", i.state !== t && ([i.group, i.markerGroup, i.dataLabelsGroup].forEach(function (e) {\n          e && (i.state && e.removeClass("highcharts-series-" + i.state), t && e.addClass("highcharts-series-" + t));\n        }), i.state = t, !i.chart.styledMode)) {\n          if (a[t] && !1 === a[t].enabled) return;\n          if (t && (l = a[t].lineWidth || l + (a[t].lineWidthPlus || 0), h = G(a[t].opacity, h)), o && !o.dashstyle && j(l)) for (let t of [o, ...this.zones.map(t => t.graph)]) t?.animate({\n            "stroke-width": l\n          }, n);\n          r || [i.group, i.markerGroup, i.dataLabelsGroup, i.labelBySeries].forEach(function (t) {\n            t && t.animate({\n              opacity: h\n            }, n);\n          });\n        }\n        e && r && i.points && i.setAllPointsToState(t || void 0);\n      }\n      setAllPointsToState(t) {\n        this.points.forEach(function (e) {\n          e.setState && e.setState(t);\n        });\n      }\n      setVisible(t, e) {\n        let i = this,\n          s = i.chart,\n          o = s.options.chart.ignoreHiddenSeries,\n          r = i.visible;\n        i.visible = t = i.options.visible = i.userOptions.visible = void 0 === t ? !r : t;\n        let a = t ? "show" : "hide";\n        ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(t => {\n          i[t]?.[a]();\n        }), (s.hoverSeries === i || s.hoverPoint?.series === i) && i.onMouseOut(), i.legendItem && s.legend.colorizeItem(i, t), i.isDirty = !0, i.options.stacking && s.series.forEach(t => {\n          t.options.stacking && t.visible && (t.isDirty = !0);\n        }), i.linkedSeries.forEach(e => {\n          e.setVisible(t, !1);\n        }), o && (s.isDirtyBox = !0), L(i, a), !1 !== e && s.redraw();\n      }\n      show() {\n        this.setVisible(!0);\n      }\n      hide() {\n        this.setVisible(!1);\n      }\n      select(t) {\n        this.selected = t = this.options.selected = void 0 === t ? !this.selected : t, this.checkbox && (this.checkbox.checked = t), L(this, t ? "select" : "unselect");\n      }\n      shouldShowTooltip(t, e, i = {}) {\n        return i.series = this, i.visiblePlotOnly = !0, this.chart.isInsidePlot(t, e, i);\n      }\n      drawLegendSymbol(t, e) {\n        o[this.options.legendSymbol || "rectangle"]?.call(this, t, e);\n      }\n    }\n    return H.defaultOptions = a, H.types = n.seriesTypes, H.registerType = n.registerSeriesType, T(H.prototype, {\n      axisTypes: ["xAxis", "yAxis"],\n      coll: "series",\n      colorCounter: 0,\n      directTouch: !1,\n      isCartesian: !0,\n      kdAxisArray: ["clientX", "plotY"],\n      parallelArrays: ["x", "y"],\n      pointClass: r,\n      requireSorting: !0,\n      sorted: !0\n    }), n.series = H, H;\n  }), i(e, "Core/Chart/Chart.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Axis/Axis.js"], e["Core/Defaults.js"], e["Core/Templating.js"], e["Core/Foundation.js"], e["Core/Globals.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Renderer/SVG/SVGRenderer.js"], e["Core/Time.js"], e["Core/Utilities.js"], e["Core/Renderer/HTML/AST.js"], e["Core/Axis/Tick.js"]], function (t, e, i, s, o, r, a, n, l, h, d, c, p, u) {\n    let {\n        animate: g,\n        animObject: f,\n        setAnimation: m\n      } = t,\n      {\n        defaultOptions: x,\n        defaultTime: y\n      } = i,\n      {\n        numberFormat: b\n      } = s,\n      {\n        registerEventOptions: v\n      } = o,\n      {\n        charts: M,\n        doc: S,\n        marginNames: k,\n        svg: C,\n        win: A\n      } = r,\n      {\n        seriesTypes: w\n      } = l,\n      {\n        addEvent: T,\n        attr: P,\n        createElement: L,\n        clamp: D,\n        css: O,\n        defined: E,\n        diffObjects: B,\n        discardElement: j,\n        erase: I,\n        error: R,\n        extend: z,\n        find: G,\n        fireEvent: W,\n        getStyle: N,\n        isArray: X,\n        isNumber: H,\n        isObject: Y,\n        isString: F,\n        merge: U,\n        objectEach: V,\n        pick: _,\n        pInt: Z,\n        relativeLength: $,\n        removeEvent: K,\n        splat: q,\n        syncTimeout: J,\n        uniqueKey: Q\n      } = c;\n    class tt {\n      static chart(t, e, i) {\n        return new tt(t, e, i);\n      }\n      constructor(t, e, i) {\n        this.sharedClips = {};\n        let s = [...arguments];\n        (F(t) || t.nodeName) && (this.renderTo = s.shift()), this.init(s[0], s[1]);\n      }\n      setZoomOptions() {\n        let t = this.options.chart,\n          e = t.zooming;\n        this.zooming = {\n          ...e,\n          type: _(t.zoomType, e.type),\n          key: _(t.zoomKey, e.key),\n          pinchType: _(t.pinchType, e.pinchType),\n          singleTouch: _(t.zoomBySingleTouch, e.singleTouch, !1),\n          resetButton: U(e.resetButton, t.resetZoomButton)\n        };\n      }\n      init(t, e) {\n        W(this, "init", {\n          args: arguments\n        }, function () {\n          let i = U(x, t),\n            s = i.chart;\n          this.userOptions = z({}, t), this.margin = [], this.spacing = [], this.bounds = {\n            h: {},\n            v: {}\n          }, this.labelCollectors = [], this.callback = e, this.isResizing = 0, this.options = i, this.axes = [], this.series = [], this.time = t.time && Object.keys(t.time).length ? new d(t.time) : r.time, this.numberFormatter = s.numberFormatter || b, this.styledMode = s.styledMode, this.hasCartesianSeries = s.showAxes, this.index = M.length, M.push(this), r.chartCount++, v(this, s), this.xAxis = [], this.yAxis = [], this.pointCount = this.colorCounter = this.symbolCounter = 0, this.setZoomOptions(), W(this, "afterInit"), this.firstRender();\n        });\n      }\n      initSeries(t) {\n        let e = this.options.chart,\n          i = t.type || e.type,\n          s = w[i];\n        s || R(17, !0, this, {\n          missingModuleFor: i\n        });\n        let o = new s();\n        return "function" == typeof o.init && o.init(this, t), o;\n      }\n      setSortedData() {\n        this.getSeriesOrderByLinks().forEach(function (t) {\n          t.points || t.data || !t.enabledDataSorting || t.setData(t.options.data, !1);\n        });\n      }\n      getSeriesOrderByLinks() {\n        return this.series.concat().sort(function (t, e) {\n          return t.linkedSeries.length || e.linkedSeries.length ? e.linkedSeries.length - t.linkedSeries.length : 0;\n        });\n      }\n      orderItems(t, e = 0) {\n        let i = this[t],\n          s = this.options[t] = q(this.options[t]).slice(),\n          o = this.userOptions[t] = this.userOptions[t] ? q(this.userOptions[t]).slice() : [];\n        if (this.hasRendered && (s.splice(e), o.splice(e)), i) for (let t = e, r = i.length; t < r; ++t) {\n          let e = i[t];\n          e && (e.index = t, e instanceof n && (e.name = e.getName()), e.options.isInternal || (s[t] = e.options, o[t] = e.userOptions));\n        }\n      }\n      isInsidePlot(t, e, i = {}) {\n        let {\n            inverted: s,\n            plotBox: o,\n            plotLeft: r,\n            plotTop: a,\n            scrollablePlotBox: n\n          } = this,\n          l = 0,\n          h = 0;\n        i.visiblePlotOnly && this.scrollingContainer && ({\n          scrollLeft: l,\n          scrollTop: h\n        } = this.scrollingContainer);\n        let d = i.series,\n          c = i.visiblePlotOnly && n || o,\n          p = i.inverted ? e : t,\n          u = i.inverted ? t : e,\n          g = {\n            x: p,\n            y: u,\n            isInsidePlot: !0,\n            options: i\n          };\n        if (!i.ignoreX) {\n          let t = d && (s && !this.polar ? d.yAxis : d.xAxis) || {\n              pos: r,\n              len: 1 / 0\n            },\n            e = i.paneCoordinates ? t.pos + p : r + p;\n          e >= Math.max(l + r, t.pos) && e <= Math.min(l + r + c.width, t.pos + t.len) || (g.isInsidePlot = !1);\n        }\n        if (!i.ignoreY && g.isInsidePlot) {\n          let t = !s && i.axis && !i.axis.isXAxis && i.axis || d && (s ? d.xAxis : d.yAxis) || {\n              pos: a,\n              len: 1 / 0\n            },\n            e = i.paneCoordinates ? t.pos + u : a + u;\n          e >= Math.max(h + a, t.pos) && e <= Math.min(h + a + c.height, t.pos + t.len) || (g.isInsidePlot = !1);\n        }\n        return W(this, "afterIsInsidePlot", g), g.isInsidePlot;\n      }\n      redraw(t) {\n        W(this, "beforeRedraw");\n        let e = this.hasCartesianSeries ? this.axes : this.colorAxis || [],\n          i = this.series,\n          s = this.pointer,\n          o = this.legend,\n          r = this.userOptions.legend,\n          a = this.renderer,\n          n = a.isHidden(),\n          l = [],\n          h,\n          d,\n          c,\n          p = this.isDirtyBox,\n          u = this.isDirtyLegend,\n          g;\n        for (a.rootFontSize = a.boxWrapper.getStyle("font-size"), this.setResponsive && this.setResponsive(!1), m(!!this.hasRendered && t, this), n && this.temporaryDisplay(), this.layOutTitles(!1), c = i.length; c--;) if (((g = i[c]).options.stacking || g.options.centerInCategory) && (d = !0, g.isDirty)) {\n          h = !0;\n          break;\n        }\n        if (h) for (c = i.length; c--;) (g = i[c]).options.stacking && (g.isDirty = !0);\n        i.forEach(function (t) {\n          t.isDirty && ("point" === t.options.legendType ? ("function" == typeof t.updateTotals && t.updateTotals(), u = !0) : r && (r.labelFormatter || r.labelFormat) && (u = !0)), t.isDirtyData && W(t, "updatedData");\n        }), u && o && o.options.enabled && (o.render(), this.isDirtyLegend = !1), d && this.getStacks(), e.forEach(function (t) {\n          t.updateNames(), t.setScale();\n        }), this.getMargins(), e.forEach(function (t) {\n          t.isDirty && (p = !0);\n        }), e.forEach(function (t) {\n          let e = t.min + "," + t.max;\n          t.extKey !== e && (t.extKey = e, l.push(function () {\n            W(t, "afterSetExtremes", z(t.eventArgs, t.getExtremes())), delete t.eventArgs;\n          })), (p || d) && t.redraw();\n        }), p && this.drawChartBox(), W(this, "predraw"), i.forEach(function (t) {\n          (p || t.isDirty) && t.visible && t.redraw(), t.isDirtyData = !1;\n        }), s && s.reset(!0), a.draw(), W(this, "redraw"), W(this, "render"), n && this.temporaryDisplay(!0), l.forEach(function (t) {\n          t.call();\n        });\n      }\n      get(t) {\n        let e = this.series;\n        function i(e) {\n          return e.id === t || e.options && e.options.id === t;\n        }\n        let s = G(this.axes, i) || G(this.series, i);\n        for (let t = 0; !s && t < e.length; t++) s = G(e[t].points || [], i);\n        return s;\n      }\n      getAxes() {\n        let t = this.userOptions;\n        for (let i of (W(this, "getAxes"), ["xAxis", "yAxis"])) {\n          let s = t[i] = q(t[i] || {});\n          for (let t of s) new e(this, t, i);\n        }\n        W(this, "afterGetAxes");\n      }\n      getSelectedPoints() {\n        return this.series.reduce((t, e) => (e.getPointsCollection().forEach(e => {\n          _(e.selectedStaging, e.selected) && t.push(e);\n        }), t), []);\n      }\n      getSelectedSeries() {\n        return this.series.filter(function (t) {\n          return t.selected;\n        });\n      }\n      setTitle(t, e, i) {\n        this.applyDescription("title", t), this.applyDescription("subtitle", e), this.applyDescription("caption", void 0), this.layOutTitles(i);\n      }\n      applyDescription(t, e) {\n        let i = this,\n          s = this.options[t] = U(this.options[t], e),\n          o = this[t];\n        o && e && (this[t] = o = o.destroy()), s && !o && ((o = this.renderer.text(s.text, 0, 0, s.useHTML).attr({\n          align: s.align,\n          class: "highcharts-" + t,\n          zIndex: s.zIndex || 4\n        }).add()).update = function (e, s) {\n          i.applyDescription(t, e), i.layOutTitles(s);\n        }, this.styledMode || o.css(z("title" === t ? {\n          fontSize: this.options.isStock ? "1em" : "1.2em"\n        } : {}, s.style)), this[t] = o);\n      }\n      layOutTitles(t = !0) {\n        let e = [0, 0, 0],\n          i = this.renderer,\n          s = this.spacingBox;\n        ["title", "subtitle", "caption"].forEach(function (t) {\n          let o = this[t],\n            r = this.options[t],\n            a = r.verticalAlign || "top",\n            n = "title" === t ? "top" === a ? -3 : 0 : "top" === a ? e[0] + 2 : 0;\n          if (o) {\n            o.css({\n              width: (r.width || s.width + (r.widthAdjust || 0)) + "px"\n            });\n            let t = i.fontMetrics(o).b,\n              l = Math.round(o.getBBox(r.useHTML).height);\n            o.align(z({\n              y: "bottom" === a ? t : n + t,\n              height: l\n            }, r), !1, "spacingBox"), r.floating || ("top" === a ? e[0] = Math.ceil(e[0] + l) : "bottom" === a && (e[2] = Math.ceil(e[2] + l)));\n          }\n        }, this), e[0] && "top" === (this.options.title.verticalAlign || "top") && (e[0] += this.options.title.margin), e[2] && "bottom" === this.options.caption.verticalAlign && (e[2] += this.options.caption.margin);\n        let o = !this.titleOffset || this.titleOffset.join(",") !== e.join(",");\n        this.titleOffset = e, W(this, "afterLayOutTitles"), !this.isDirtyBox && o && (this.isDirtyBox = this.isDirtyLegend = o, this.hasRendered && t && this.isDirtyBox && this.redraw());\n      }\n      getContainerBox() {\n        return {\n          width: N(this.renderTo, "width", !0) || 0,\n          height: N(this.renderTo, "height", !0) || 0\n        };\n      }\n      getChartSize() {\n        let t = this.options.chart,\n          e = t.width,\n          i = t.height,\n          s = this.getContainerBox();\n        this.chartWidth = Math.max(0, e || s.width || 600), this.chartHeight = Math.max(0, $(i, this.chartWidth) || (s.height > 1 ? s.height : 400)), this.containerBox = s;\n      }\n      temporaryDisplay(t) {\n        let e = this.renderTo,\n          i;\n        if (t) for (; e && e.style;) e.hcOrigStyle && (O(e, e.hcOrigStyle), delete e.hcOrigStyle), e.hcOrigDetached && (S.body.removeChild(e), e.hcOrigDetached = !1), e = e.parentNode;else for (; e && e.style && (S.body.contains(e) || e.parentNode || (e.hcOrigDetached = !0, S.body.appendChild(e)), ("none" === N(e, "display", !1) || e.hcOricDetached) && (e.hcOrigStyle = {\n          display: e.style.display,\n          height: e.style.height,\n          overflow: e.style.overflow\n        }, i = {\n          display: "block",\n          overflow: "hidden"\n        }, e !== this.renderTo && (i.height = 0), O(e, i), e.offsetWidth || e.style.setProperty("display", "block", "important")), (e = e.parentNode) !== S.body););\n      }\n      setClassName(t) {\n        this.container.className = "highcharts-container " + (t || "");\n      }\n      getContainer() {\n        let t = this.options,\n          e = t.chart,\n          i = "data-highcharts-chart",\n          s = Q(),\n          o,\n          r = this.renderTo;\n        r || (this.renderTo = r = e.renderTo), F(r) && (this.renderTo = r = S.getElementById(r)), r || R(13, !0, this);\n        let n = Z(P(r, i));\n        H(n) && M[n] && M[n].hasRendered && M[n].destroy(), P(r, i, this.index), r.innerHTML = p.emptyHTML, e.skipClone || r.offsetWidth || this.temporaryDisplay(), this.getChartSize();\n        let l = this.chartWidth,\n          d = this.chartHeight;\n        O(r, {\n          overflow: "hidden"\n        }), this.styledMode || (o = z({\n          position: "relative",\n          overflow: "hidden",\n          width: l + "px",\n          height: d + "px",\n          textAlign: "left",\n          lineHeight: "normal",\n          zIndex: 0,\n          "-webkit-tap-highlight-color": "rgba(0,0,0,0)",\n          userSelect: "none",\n          "touch-action": "manipulation",\n          outline: "none"\n        }, e.style || {}));\n        let c = L("div", {\n          id: s\n        }, o, r);\n        this.container = c, this._cursor = c.style.cursor;\n        let u = e.renderer || !C ? a.getRendererType(e.renderer) : h;\n        if (this.renderer = new u(c, l, d, void 0, e.forExport, t.exporting && t.exporting.allowHTML, this.styledMode), this.containerBox = this.getContainerBox(), m(void 0, this), this.setClassName(e.className), this.styledMode) for (let e in t.defs) this.renderer.definition(t.defs[e]);else this.renderer.setStyle(e.style);\n        this.renderer.chartIndex = this.index, W(this, "afterGetContainer");\n      }\n      getMargins(t) {\n        let {\n          spacing: e,\n          margin: i,\n          titleOffset: s\n        } = this;\n        this.resetMargins(), s[0] && !E(i[0]) && (this.plotTop = Math.max(this.plotTop, s[0] + e[0])), s[2] && !E(i[2]) && (this.marginBottom = Math.max(this.marginBottom, s[2] + e[2])), this.legend && this.legend.display && this.legend.adjustMargins(i, e), W(this, "getMargins"), t || this.getAxisMargins();\n      }\n      getAxisMargins() {\n        let t = this,\n          e = t.axisOffset = [0, 0, 0, 0],\n          i = t.colorAxis,\n          s = t.margin,\n          o = function (t) {\n            t.forEach(function (t) {\n              t.visible && t.getOffset();\n            });\n          };\n        t.hasCartesianSeries ? o(t.axes) : i && i.length && o(i), k.forEach(function (i, o) {\n          E(s[o]) || (t[i] += e[o]);\n        }), t.setChartSize();\n      }\n      getOptions() {\n        return B(this.userOptions, x);\n      }\n      reflow(t) {\n        let e = this,\n          i = e.containerBox,\n          s = e.getContainerBox();\n        delete e.pointer.chartPosition, !e.isPrinting && !e.isResizing && i && s.width && ((s.width !== i.width || s.height !== i.height) && (c.clearTimeout(e.reflowTimeout), e.reflowTimeout = J(function () {\n          e.container && e.setSize(void 0, void 0, !1);\n        }, t ? 100 : 0)), e.containerBox = s);\n      }\n      setReflow() {\n        let t = this,\n          e = e => {\n            t.options?.chart.reflow && t.hasLoaded && t.reflow(e);\n          };\n        if ("function" == typeof ResizeObserver) new ResizeObserver(e).observe(t.renderTo);else {\n          let t = T(A, "resize", e);\n          T(this, "destroy", t);\n        }\n      }\n      setSize(t, e, i) {\n        let s = this,\n          o = s.renderer;\n        s.isResizing += 1, m(i, s);\n        let r = o.globalAnimation;\n        s.oldChartHeight = s.chartHeight, s.oldChartWidth = s.chartWidth, void 0 !== t && (s.options.chart.width = t), void 0 !== e && (s.options.chart.height = e), s.getChartSize();\n        let {\n          chartWidth: a,\n          chartHeight: n,\n          scrollablePixelsX: l = 0,\n          scrollablePixelsY: h = 0\n        } = s;\n        (s.isDirtyBox || a !== s.oldChartWidth || n !== s.oldChartHeight) && (s.styledMode || (r ? g : O)(s.container, {\n          width: `${a + l}px`,\n          height: `${n + h}px`\n        }, r), s.setChartSize(!0), o.setSize(a, n, r), s.axes.forEach(function (t) {\n          t.isDirty = !0, t.setScale();\n        }), s.isDirtyLegend = !0, s.isDirtyBox = !0, s.layOutTitles(), s.getMargins(), s.redraw(r), s.oldChartHeight = void 0, W(s, "resize"), setTimeout(() => {\n          s && W(s, "endResize", void 0, () => {\n            s.isResizing -= 1;\n          });\n        }, f(r).duration));\n      }\n      setChartSize(t) {\n        let e, i, s, o;\n        let r = this.inverted,\n          a = this.renderer,\n          n = this.chartWidth,\n          l = this.chartHeight,\n          h = this.options.chart,\n          d = this.spacing,\n          c = this.clipOffset;\n        this.plotLeft = e = Math.round(this.plotLeft), this.plotTop = i = Math.round(this.plotTop), this.plotWidth = s = Math.max(0, Math.round(n - e - this.marginRight)), this.plotHeight = o = Math.max(0, Math.round(l - i - this.marginBottom)), this.plotSizeX = r ? o : s, this.plotSizeY = r ? s : o, this.plotBorderWidth = h.plotBorderWidth || 0, this.spacingBox = a.spacingBox = {\n          x: d[3],\n          y: d[0],\n          width: n - d[3] - d[1],\n          height: l - d[0] - d[2]\n        }, this.plotBox = a.plotBox = {\n          x: e,\n          y: i,\n          width: s,\n          height: o\n        };\n        let p = 2 * Math.floor(this.plotBorderWidth / 2),\n          u = Math.ceil(Math.max(p, c[3]) / 2),\n          g = Math.ceil(Math.max(p, c[0]) / 2);\n        this.clipBox = {\n          x: u,\n          y: g,\n          width: Math.floor(this.plotSizeX - Math.max(p, c[1]) / 2 - u),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(p, c[2]) / 2 - g))\n        }, t || (this.axes.forEach(function (t) {\n          t.setAxisSize(), t.setAxisTranslation();\n        }), a.alignElements()), W(this, "afterSetChartSize", {\n          skipAxes: t\n        });\n      }\n      resetMargins() {\n        W(this, "resetMargins");\n        let t = this,\n          e = t.options.chart;\n        ["margin", "spacing"].forEach(function (i) {\n          let s = e[i],\n            o = Y(s) ? s : [s, s, s, s];\n          ["Top", "Right", "Bottom", "Left"].forEach(function (s, r) {\n            t[i][r] = _(e[i + s], o[r]);\n          });\n        }), k.forEach(function (e, i) {\n          t[e] = _(t.margin[i], t.spacing[i]);\n        }), t.axisOffset = [0, 0, 0, 0], t.clipOffset = [0, 0, 0, 0];\n      }\n      drawChartBox() {\n        let t = this.options.chart,\n          e = this.renderer,\n          i = this.chartWidth,\n          s = this.chartHeight,\n          o = this.styledMode,\n          r = this.plotBGImage,\n          a = t.backgroundColor,\n          n = t.plotBackgroundColor,\n          l = t.plotBackgroundImage,\n          h = this.plotLeft,\n          d = this.plotTop,\n          c = this.plotWidth,\n          p = this.plotHeight,\n          u = this.plotBox,\n          g = this.clipRect,\n          f = this.clipBox,\n          m = this.chartBackground,\n          x = this.plotBackground,\n          y = this.plotBorder,\n          b,\n          v,\n          M,\n          S = "animate";\n        m || (this.chartBackground = m = e.rect().addClass("highcharts-background").add(), S = "attr"), o ? b = v = m.strokeWidth() : (v = (b = t.borderWidth || 0) + (t.shadow ? 8 : 0), M = {\n          fill: a || "none"\n        }, (b || m["stroke-width"]) && (M.stroke = t.borderColor, M["stroke-width"] = b), m.attr(M).shadow(t.shadow)), m[S]({\n          x: v / 2,\n          y: v / 2,\n          width: i - v - b % 2,\n          height: s - v - b % 2,\n          r: t.borderRadius\n        }), S = "animate", x || (S = "attr", this.plotBackground = x = e.rect().addClass("highcharts-plot-background").add()), x[S](u), !o && (x.attr({\n          fill: n || "none"\n        }).shadow(t.plotShadow), l && (r ? (l !== r.attr("href") && r.attr("href", l), r.animate(u)) : this.plotBGImage = e.image(l, h, d, c, p).add())), g ? g.animate({\n          width: f.width,\n          height: f.height\n        }) : this.clipRect = e.clipRect(f), S = "animate", y || (S = "attr", this.plotBorder = y = e.rect().addClass("highcharts-plot-border").attr({\n          zIndex: 1\n        }).add()), o || y.attr({\n          stroke: t.plotBorderColor,\n          "stroke-width": t.plotBorderWidth || 0,\n          fill: "none"\n        }), y[S](y.crisp({\n          x: h,\n          y: d,\n          width: c,\n          height: p\n        }, -y.strokeWidth())), this.isDirtyBox = !1, W(this, "afterDrawChartBox");\n      }\n      propFromSeries() {\n        let t, e, i;\n        let s = this,\n          o = s.options.chart,\n          r = s.options.series;\n        ["inverted", "angular", "polar"].forEach(function (a) {\n          for (e = w[o.type], i = o[a] || e && e.prototype[a], t = r && r.length; !i && t--;) (e = w[r[t].type]) && e.prototype[a] && (i = !0);\n          s[a] = i;\n        });\n      }\n      linkSeries(t) {\n        let e = this,\n          i = e.series;\n        i.forEach(function (t) {\n          t.linkedSeries.length = 0;\n        }), i.forEach(function (t) {\n          let {\n            linkedTo: i\n          } = t.options;\n          if (F(i)) {\n            let s;\n            (s = ":previous" === i ? e.series[t.index - 1] : e.get(i)) && s.linkedParent !== t && (s.linkedSeries.push(t), t.linkedParent = s, s.enabledDataSorting && t.setDataSortingOptions(), t.visible = _(t.options.visible, s.options.visible, t.visible));\n          }\n        }), W(this, "afterLinkSeries", {\n          isUpdating: t\n        });\n      }\n      renderSeries() {\n        this.series.forEach(function (t) {\n          t.translate(), t.render();\n        });\n      }\n      render() {\n        let t = this.axes,\n          e = this.colorAxis,\n          i = this.renderer,\n          s = this.options.chart.axisLayoutRuns || 2,\n          o = t => {\n            t.forEach(t => {\n              t.visible && t.render();\n            });\n          },\n          r = 0,\n          a = !0,\n          n,\n          l = 0;\n        for (let e of (this.setTitle(), W(this, "beforeMargins"), this.getStacks?.(), this.getMargins(!0), this.setChartSize(), t)) {\n          let {\n              options: t\n            } = e,\n            {\n              labels: i\n            } = t;\n          if (e.horiz && e.visible && i.enabled && e.series.length && "colorAxis" !== e.coll && !this.polar) {\n            r = t.tickLength, e.createGroups();\n            let s = new u(e, 0, "", !0),\n              o = s.createLabel("x", i);\n            if (s.destroy(), o && _(i.reserveSpace, !H(t.crossing)) && (r = o.getBBox().height + i.distance + Math.max(t.offset || 0, 0)), r) {\n              o?.destroy();\n              break;\n            }\n          }\n        }\n        for (this.plotHeight = Math.max(this.plotHeight - r, 0); (a || n || s > 1) && l < s;) {\n          let e = this.plotWidth,\n            i = this.plotHeight;\n          for (let e of t) 0 === l ? e.setScale() : (e.horiz && a || !e.horiz && n) && e.setTickInterval(!0);\n          0 === l ? this.getAxisMargins() : this.getMargins(), a = e / this.plotWidth > (l ? 1 : 1.1), n = i / this.plotHeight > (l ? 1 : 1.05), l++;\n        }\n        this.drawChartBox(), this.hasCartesianSeries ? o(t) : e && e.length && o(e), this.seriesGroup || (this.seriesGroup = i.g("series-group").attr({\n          zIndex: 3\n        }).shadow(this.options.chart.seriesGroupShadow).add()), this.renderSeries(), this.addCredits(), this.setResponsive && this.setResponsive(), this.hasRendered = !0;\n      }\n      addCredits(t) {\n        let e = this,\n          i = U(!0, this.options.credits, t);\n        i.enabled && !this.credits && (this.credits = this.renderer.text(i.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {\n          i.href && (A.location.href = i.href);\n        }).attr({\n          align: i.position.align,\n          zIndex: 8\n        }), e.styledMode || this.credits.css(i.style), this.credits.add().align(i.position), this.credits.update = function (t) {\n          e.credits = e.credits.destroy(), e.addCredits(t);\n        });\n      }\n      destroy() {\n        let t;\n        let e = this,\n          i = e.axes,\n          s = e.series,\n          o = e.container,\n          a = o && o.parentNode;\n        for (W(e, "destroy"), e.renderer.forExport ? I(M, e) : M[e.index] = void 0, r.chartCount--, e.renderTo.removeAttribute("data-highcharts-chart"), K(e), t = i.length; t--;) i[t] = i[t].destroy();\n        for (this.scroller && this.scroller.destroy && this.scroller.destroy(), t = s.length; t--;) s[t] = s[t].destroy();\n        ["title", "subtitle", "chartBackground", "plotBackground", "plotBGImage", "plotBorder", "seriesGroup", "clipRect", "credits", "pointer", "rangeSelector", "legend", "resetZoomButton", "tooltip", "renderer"].forEach(function (t) {\n          let i = e[t];\n          i && i.destroy && (e[t] = i.destroy());\n        }), o && (o.innerHTML = p.emptyHTML, K(o), a && j(o)), V(e, function (t, i) {\n          delete e[i];\n        });\n      }\n      firstRender() {\n        let t = this,\n          e = t.options;\n        t.getContainer(), t.resetMargins(), t.setChartSize(), t.propFromSeries(), t.getAxes();\n        let i = X(e.series) ? e.series : [];\n        e.series = [], i.forEach(function (e) {\n          t.initSeries(e);\n        }), t.linkSeries(), t.setSortedData(), W(t, "beforeRender"), t.render(), t.pointer.getChartPosition(), t.renderer.imgCount || t.hasLoaded || t.onload(), t.temporaryDisplay(!0);\n      }\n      onload() {\n        this.callbacks.concat([this.callback]).forEach(function (t) {\n          t && void 0 !== this.index && t.apply(this, [this]);\n        }, this), W(this, "load"), W(this, "render"), E(this.index) && this.setReflow(), this.warnIfA11yModuleNotLoaded(), this.hasLoaded = !0;\n      }\n      warnIfA11yModuleNotLoaded() {\n        let {\n          options: t,\n          title: e\n        } = this;\n        !t || this.accessibility || (this.renderer.boxWrapper.attr({\n          role: "img",\n          "aria-label": (e && e.element.textContent || "").replace(/</g, "&lt;")\n        }), t.accessibility && !1 === t.accessibility.enabled || R(\'Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.\', !1, this));\n      }\n      addSeries(t, e, i) {\n        let s;\n        let o = this;\n        return t && (e = _(e, !0), W(o, "addSeries", {\n          options: t\n        }, function () {\n          s = o.initSeries(t), o.isDirtyLegend = !0, o.linkSeries(), s.enabledDataSorting && s.setData(t.data, !1), W(o, "afterAddSeries", {\n            series: s\n          }), e && o.redraw(i);\n        })), s;\n      }\n      addAxis(t, e, i, s) {\n        return this.createAxis(e ? "xAxis" : "yAxis", {\n          axis: t,\n          redraw: i,\n          animation: s\n        });\n      }\n      addColorAxis(t, e, i) {\n        return this.createAxis("colorAxis", {\n          axis: t,\n          redraw: e,\n          animation: i\n        });\n      }\n      createAxis(t, i) {\n        let s = new e(this, i.axis, t);\n        return _(i.redraw, !0) && this.redraw(i.animation), s;\n      }\n      showLoading(t) {\n        let e = this,\n          i = e.options,\n          s = i.loading,\n          o = function () {\n            r && O(r, {\n              left: e.plotLeft + "px",\n              top: e.plotTop + "px",\n              width: e.plotWidth + "px",\n              height: e.plotHeight + "px"\n            });\n          },\n          r = e.loadingDiv,\n          a = e.loadingSpan;\n        r || (e.loadingDiv = r = L("div", {\n          className: "highcharts-loading highcharts-loading-hidden"\n        }, null, e.container)), a || (e.loadingSpan = a = L("span", {\n          className: "highcharts-loading-inner"\n        }, null, r), T(e, "redraw", o)), r.className = "highcharts-loading", p.setElementHTML(a, _(t, i.lang.loading, "")), e.styledMode || (O(r, z(s.style, {\n          zIndex: 10\n        })), O(a, s.labelStyle), e.loadingShown || (O(r, {\n          opacity: 0,\n          display: ""\n        }), g(r, {\n          opacity: s.style.opacity || .5\n        }, {\n          duration: s.showDuration || 0\n        }))), e.loadingShown = !0, o();\n      }\n      hideLoading() {\n        let t = this.options,\n          e = this.loadingDiv;\n        e && (e.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || g(e, {\n          opacity: 0\n        }, {\n          duration: t.loading.hideDuration || 100,\n          complete: function () {\n            O(e, {\n              display: "none"\n            });\n          }\n        })), this.loadingShown = !1;\n      }\n      update(t, e, i, s) {\n        let o, r, a;\n        let n = this,\n          l = {\n            credits: "addCredits",\n            title: "setTitle",\n            subtitle: "setSubtitle",\n            caption: "setCaption"\n          },\n          h = t.isResponsiveOptions,\n          c = [];\n        W(n, "update", {\n          options: t\n        }), h || n.setResponsive(!1, !0), t = B(t, n.options), n.userOptions = U(n.userOptions, t);\n        let p = t.chart;\n        p && (U(!0, n.options.chart, p), this.setZoomOptions(), "className" in p && n.setClassName(p.className), ("inverted" in p || "polar" in p || "type" in p) && (n.propFromSeries(), o = !0), "alignTicks" in p && (o = !0), "events" in p && v(this, p), V(p, function (t, e) {\n          -1 !== n.propsRequireUpdateSeries.indexOf("chart." + e) && (r = !0), -1 !== n.propsRequireDirtyBox.indexOf(e) && (n.isDirtyBox = !0), -1 === n.propsRequireReflow.indexOf(e) || (n.isDirtyBox = !0, h || (a = !0));\n        }), !n.styledMode && p.style && n.renderer.setStyle(n.options.chart.style || {})), !n.styledMode && t.colors && (this.options.colors = t.colors), t.time && (this.time === y && (this.time = new d(t.time)), U(!0, n.options.time, t.time)), V(t, function (e, i) {\n          n[i] && "function" == typeof n[i].update ? n[i].update(e, !1) : "function" == typeof n[l[i]] ? n[l[i]](e) : "colors" !== i && -1 === n.collectionsWithUpdate.indexOf(i) && U(!0, n.options[i], t[i]), "chart" !== i && -1 !== n.propsRequireUpdateSeries.indexOf(i) && (r = !0);\n        }), this.collectionsWithUpdate.forEach(function (e) {\n          t[e] && (q(t[e]).forEach(function (t, s) {\n            let o;\n            let r = E(t.id);\n            r && (o = n.get(t.id)), !o && n[e] && (o = n[e][_(t.index, s)]) && (r && E(o.options.id) || o.options.isInternal) && (o = void 0), o && o.coll === e && (o.update(t, !1), i && (o.touched = !0)), !o && i && n.collectionsWithInit[e] && (n.collectionsWithInit[e][0].apply(n, [t].concat(n.collectionsWithInit[e][1] || []).concat([!1])).touched = !0);\n          }), i && n[e].forEach(function (t) {\n            t.touched || t.options.isInternal ? delete t.touched : c.push(t);\n          }));\n        }), c.forEach(function (t) {\n          t.chart && t.remove && t.remove(!1);\n        }), o && n.axes.forEach(function (t) {\n          t.update({}, !1);\n        }), r && n.getSeriesOrderByLinks().forEach(function (t) {\n          t.chart && t.update({}, !1);\n        }, this);\n        let u = p && p.width,\n          g = p && (F(p.height) ? $(p.height, u || n.chartWidth) : p.height);\n        a || H(u) && u !== n.chartWidth || H(g) && g !== n.chartHeight ? n.setSize(u, g, s) : _(e, !0) && n.redraw(s), W(n, "afterUpdate", {\n          options: t,\n          redraw: e,\n          animation: s\n        });\n      }\n      setSubtitle(t, e) {\n        this.applyDescription("subtitle", t), this.layOutTitles(e);\n      }\n      setCaption(t, e) {\n        this.applyDescription("caption", t), this.layOutTitles(e);\n      }\n      showResetZoom() {\n        let t = this,\n          e = x.lang,\n          i = t.zooming.resetButton,\n          s = i.theme,\n          o = "chart" === i.relativeTo || "spacingBox" === i.relativeTo ? null : "scrollablePlotBox";\n        function r() {\n          t.zoomOut();\n        }\n        W(this, "beforeShowResetZoom", null, function () {\n          t.resetZoomButton = t.renderer.button(e.resetZoom, null, null, r, s).attr({\n            align: i.position.align,\n            title: e.resetZoomTitle\n          }).addClass("highcharts-reset-zoom").add().align(i.position, !1, o);\n        }), W(this, "afterShowResetZoom");\n      }\n      zoomOut() {\n        W(this, "selection", {\n          resetSelection: !0\n        }, this.zoom);\n      }\n      zoom(t) {\n        let e = this,\n          i = e.pointer,\n          s = !1,\n          o;\n        !t || t.resetSelection ? (e.axes.forEach(function (t) {\n          o = t.zoom();\n        }), i.initiated = !1) : t.xAxis.concat(t.yAxis).forEach(function (t) {\n          let r = t.axis,\n            a = r.isXAxis,\n            {\n              hasPinched: n,\n              mouseDownX: l,\n              mouseDownY: h\n            } = i;\n          (i[a ? "zoomX" : "zoomY"] && E(l) && E(h) && e.isInsidePlot(l - e.plotLeft, h - e.plotTop, {\n            axis: r,\n            ignoreX: n,\n            ignoreY: n\n          }) || !E(e.inverted ? l : h)) && (o = r.zoom(t.min, t.max), r.displayBtn && (s = !0));\n        });\n        let r = e.resetZoomButton;\n        s && !r ? e.showResetZoom() : !s && Y(r) && (e.resetZoomButton = r.destroy()), o && e.redraw(_(e.options.chart.animation, t && t.animation, e.pointCount < 100));\n      }\n      pan(t, e) {\n        let i;\n        let s = this,\n          o = s.hoverPoints,\n          r = "object" == typeof e ? e : {\n            enabled: e,\n            type: "x"\n          },\n          a = s.options.chart;\n        a && a.panning && (a.panning = r);\n        let n = r.type;\n        W(this, "pan", {\n          originalEvent: t\n        }, function () {\n          o && o.forEach(function (t) {\n            t.setState();\n          });\n          let e = s.xAxis;\n          "xy" === n ? e = e.concat(s.yAxis) : "y" === n && (e = s.yAxis);\n          let r = {};\n          e.forEach(function (e) {\n            if (!e.options.panningEnabled || e.options.isInternal) return;\n            let o = e.horiz,\n              a = t[o ? "chartX" : "chartY"],\n              l = o ? "mouseDownX" : "mouseDownY",\n              h = s[l],\n              d = e.minPointOffset || 0,\n              c = e.reversed && !s.inverted || !e.reversed && s.inverted ? -1 : 1,\n              p = e.getExtremes(),\n              u = e.toValue(h - a, !0) + d * c,\n              g = e.toValue(h + e.len - a, !0) - (d * c || e.isXAxis && e.pointRangePadding || 0),\n              f = g < u,\n              m = e.hasVerticalPanning(),\n              x = f ? g : u,\n              y = f ? u : g,\n              b = e.panningState,\n              v;\n            m && !e.isXAxis && (!b || b.isDirty) && e.series.forEach(function (t) {\n              let e = t.getProcessedData(!0),\n                i = t.getExtremes(e.yData, !0);\n              b || (b = {\n                startMin: Number.MAX_VALUE,\n                startMax: -Number.MAX_VALUE\n              }), H(i.dataMin) && H(i.dataMax) && (b.startMin = Math.min(_(t.options.threshold, 1 / 0), i.dataMin, b.startMin), b.startMax = Math.max(_(t.options.threshold, -1 / 0), i.dataMax, b.startMax));\n            });\n            let M = Math.min(_(b && b.startMin, p.dataMin), d ? p.min : e.toValue(e.toPixels(p.min) - e.minPixelPadding)),\n              S = Math.max(_(b && b.startMax, p.dataMax), d ? p.max : e.toValue(e.toPixels(p.max) + e.minPixelPadding));\n            e.panningState = b, e.isOrdinal || ((v = M - x) > 0 && (y += v, x = M), (v = y - S) > 0 && (y = S, x -= v), e.series.length && x !== p.min && y !== p.max && x >= M && y <= S && (e.setExtremes(x, y, !1, !1, {\n              trigger: "pan"\n            }), !s.resetZoomButton && x !== M && y !== S && n.match("y") && (s.showResetZoom(), e.displayBtn = !1), i = !0), r[l] = a);\n          }), V(r, (t, e) => {\n            s[e] = t;\n          }), i && s.redraw(!1), O(s.container, {\n            cursor: "move"\n          });\n        });\n      }\n    }\n    return z(tt.prototype, {\n      callbacks: [],\n      collectionsWithInit: {\n        xAxis: [tt.prototype.addAxis, [!0]],\n        yAxis: [tt.prototype.addAxis, [!1]],\n        series: [tt.prototype.addSeries]\n      },\n      collectionsWithUpdate: ["xAxis", "yAxis", "series"],\n      propsRequireDirtyBox: ["backgroundColor", "borderColor", "borderWidth", "borderRadius", "plotBackgroundColor", "plotBackgroundImage", "plotBorderColor", "plotBorderWidth", "plotShadow", "shadow"],\n      propsRequireReflow: ["margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "spacing", "spacingTop", "spacingRight", "spacingBottom", "spacingLeft"],\n      propsRequireUpdateSeries: ["chart.inverted", "chart.polar", "chart.ignoreHiddenSeries", "chart.type", "colors", "plotOptions", "time", "tooltip"]\n    }), tt;\n  }), i(e, "Extensions/ScrollablePlotArea.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Globals.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s) {\n    let {\n        stop: o\n      } = t,\n      {\n        composed: r\n      } = e,\n      {\n        addEvent: a,\n        createElement: n,\n        css: l,\n        defined: h,\n        extend: d,\n        merge: c,\n        pick: p,\n        pushUnique: u\n      } = s;\n    function g() {\n      let t;\n      let {\n          axisOffset: e,\n          chartWidth: s,\n          chartHeight: r,\n          container: h,\n          plotHeight: d,\n          plotLeft: c,\n          plotTop: u,\n          plotWidth: g,\n          scrollablePixelsX: f = 0,\n          scrollablePixelsY: m = 0,\n          scrollingContainer: x\n        } = this,\n        y = !this.fixedDiv,\n        b = this.options.chart,\n        v = b.scrollablePlotArea,\n        {\n          scrollPositionX: M,\n          scrollPositionY: S\n        } = v,\n        k = i.getRendererType(),\n        {\n          fixedRenderer: C\n        } = this;\n      C ? C.setSize(s, r) : (this.fixedDiv = n("div", {\n        className: "highcharts-fixed"\n      }, {\n        position: "absolute",\n        overflow: "hidden",\n        pointerEvents: "none",\n        zIndex: (b.style?.zIndex || 0) + 2,\n        top: 0\n      }, void 0, !0), x?.parentNode.insertBefore(this.fixedDiv, x), l(this.renderTo, {\n        overflow: "visible"\n      }), this.fixedRenderer = C = new k(this.fixedDiv, s, r, b.style), this.scrollableMask = C.path().attr({\n        fill: b.backgroundColor || "#fff",\n        "fill-opacity": p(v.opacity, .85),\n        zIndex: -1\n      }).addClass("highcharts-scrollable-mask").add(), a(this, "afterShowResetZoom", this.moveFixedElements), a(this, "afterApplyDrilldown", this.moveFixedElements), a(this, "afterLayOutTitles", this.moveFixedElements)), (this.scrollableDirty || y) && (this.scrollableDirty = !1, this.moveFixedElements());\n      let A = s + f,\n        w = r + m;\n      o(this.container), l(h, {\n        width: `${A}px`,\n        height: `${w}px`\n      }), this.renderer.boxWrapper.attr({\n        width: A,\n        height: w,\n        viewBox: [0, 0, A, w].join(" ")\n      }), this.chartBackground?.attr({\n        width: A,\n        height: w\n      }), x && (l(x, {\n        width: `${this.chartWidth}px`,\n        height: `${this.chartHeight}px`\n      }), y && (M && (x.scrollLeft = f * M), S && (x.scrollTop = m * S)));\n      let T = u - e[0] - 1,\n        P = c - e[3] - 1,\n        L = u + d + e[2] + 1,\n        D = c + g + e[1] + 1,\n        O = c + g - f,\n        E = u + d - m;\n      t = f ? [["M", 0, T], ["L", c - 1, T], ["L", c - 1, L], ["L", 0, L], ["Z"], ["M", O, T], ["L", s, T], ["L", s, L], ["L", O, L], ["Z"]] : m ? [["M", P, 0], ["L", P, u - 1], ["L", D, u - 1], ["L", D, 0], ["Z"], ["M", P, E], ["L", P, r], ["L", D, r], ["L", D, E], ["Z"]] : [["M", 0, 0]], "adjustHeight" !== this.redrawTrigger && this.scrollableMask?.attr({\n        d: t\n      });\n    }\n    function f() {\n      let t;\n      let e = this.container,\n        i = this.fixedRenderer,\n        s = [".highcharts-breadcrumbs-group", ".highcharts-contextbutton", ".highcharts-caption", ".highcharts-credits", ".highcharts-legend", ".highcharts-legend-checkbox", ".highcharts-navigator-series", ".highcharts-navigator-xaxis", ".highcharts-navigator-yaxis", ".highcharts-navigator", ".highcharts-reset-zoom", ".highcharts-drillup-button", ".highcharts-scrollbar", ".highcharts-subtitle", ".highcharts-title"];\n      for (let o of (this.scrollablePixelsX && !this.inverted ? t = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? t = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? t = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (t = ".highcharts-yaxis"), t && s.push(`${t}:not(.highcharts-radial-axis)`, `${t}-labels:not(.highcharts-radial-axis-labels)`), s)) [].forEach.call(e.querySelectorAll(o), t => {\n        (t.namespaceURI === i.SVG_NS ? i.box : i.box.parentNode).appendChild(t), t.style.pointerEvents = "auto";\n      });\n    }\n    function m() {\n      let t;\n      let e = {\n        WebkitOverflowScrolling: "touch",\n        overflowX: "hidden",\n        overflowY: "hidden"\n      };\n      this.scrollablePixelsX && (e.overflowX = "auto"), this.scrollablePixelsY && (e.overflowY = "auto"), this.scrollingParent = n("div", {\n        className: "highcharts-scrolling-parent"\n      }, {\n        position: "relative"\n      }, this.renderTo), this.scrollingContainer = n("div", {\n        className: "highcharts-scrolling"\n      }, e, this.scrollingParent), a(this.scrollingContainer, "scroll", () => {\n        this.pointer && (delete this.pointer.chartPosition, this.hoverPoint && (t = this.hoverPoint), this.pointer.runPointActions(void 0, t, !0));\n      }), this.innerContainer = n("div", {\n        className: "highcharts-inner-container"\n      }, null, this.scrollingContainer), this.innerContainer.appendChild(this.container), this.setUpScrolling = null;\n    }\n    function x() {\n      this.chart.scrollableDirty = !0;\n    }\n    function y(t) {\n      let e, i, s;\n      let o = this.options.chart.scrollablePlotArea,\n        r = o && o.minWidth,\n        a = o && o.minHeight;\n      if (!this.renderer.forExport && (r ? (this.scrollablePixelsX = e = Math.max(0, r - this.chartWidth), e && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = c(this.plotBox), this.plotBox.width = this.plotWidth += e, this.inverted ? this.clipBox.height += e : this.clipBox.width += e, s = {\n        1: {\n          name: "right",\n          value: e\n        }\n      })) : a && (this.scrollablePixelsY = i = Math.max(0, a - this.chartHeight), h(i) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = c(this.plotBox), this.plotBox.height = this.plotHeight += i, this.inverted ? this.clipBox.width += i : this.clipBox.height += i, s = {\n        2: {\n          name: "bottom",\n          value: i\n        }\n      })), s && !t.skipAxes)) for (let t of this.axes) if (s[t.side]) {\n        let e = t.getPlotLinePath;\n        t.getPlotLinePath = function () {\n          let i = s[t.side].name,\n            o = s[t.side].value,\n            r = this[i];\n          this[i] = r - o;\n          let a = e.apply(this, arguments);\n          return this[i] = r, a;\n        };\n      } else t.setAxisSize(), t.setAxisTranslation();\n    }\n    function b() {\n      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    }\n    function v() {\n      this.chart.scrollableDirty = !0;\n    }\n    return {\n      compose: function t(e, i, s) {\n        u(r, t) && (a(e, "afterInit", x), d(i.prototype, {\n          applyFixed: g,\n          moveFixedElements: f,\n          setUpScrolling: m\n        }), a(i, "afterSetChartSize", y), a(i, "render", b), a(s, "show", v));\n      }\n    };\n  }), i(e, "Core/Axis/Stacking/StackItem.js", [e["Core/Templating.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i) {\n    let {\n        format: s\n      } = t,\n      {\n        series: o\n      } = e,\n      {\n        destroyObjectProperties: r,\n        fireEvent: a,\n        isNumber: n,\n        pick: l\n      } = i;\n    return class {\n      constructor(t, e, i, s, o) {\n        let r = t.chart.inverted,\n          a = t.reversed;\n        this.axis = t;\n        let n = this.isNegative = !!i != !!a;\n        this.options = e = e || {}, this.x = s, this.total = null, this.cumulative = null, this.points = {}, this.hasValidPoints = !1, this.stack = o, this.leftCliff = 0, this.rightCliff = 0, this.alignOptions = {\n          align: e.align || (r ? n ? "left" : "right" : "center"),\n          verticalAlign: e.verticalAlign || (r ? "middle" : n ? "bottom" : "top"),\n          y: e.y,\n          x: e.x\n        }, this.textAlign = e.textAlign || (r ? n ? "right" : "left" : "center");\n      }\n      destroy() {\n        r(this, this.axis);\n      }\n      render(t) {\n        let e = this.axis.chart,\n          i = this.options,\n          o = i.format,\n          r = o ? s(o, this, e) : i.formatter.call(this);\n        if (this.label) this.label.attr({\n          text: r,\n          visibility: "hidden"\n        });else {\n          this.label = e.renderer.label(r, null, void 0, i.shape, void 0, void 0, i.useHTML, !1, "stack-labels");\n          let s = {\n            r: i.borderRadius || 0,\n            text: r,\n            padding: l(i.padding, 5),\n            visibility: "hidden"\n          };\n          e.styledMode || (s.fill = i.backgroundColor, s.stroke = i.borderColor, s["stroke-width"] = i.borderWidth, this.label.css(i.style || {})), this.label.attr(s), this.label.added || this.label.add(t);\n        }\n        this.label.labelrank = e.plotSizeY, a(this, "afterRender");\n      }\n      setOffset(t, e, i, s, r, h) {\n        let {\n            alignOptions: d,\n            axis: c,\n            label: p,\n            options: u,\n            textAlign: g\n          } = this,\n          f = c.chart,\n          m = this.getStackBox({\n            xOffset: t,\n            width: e,\n            boxBottom: i,\n            boxTop: s,\n            defaultX: r,\n            xAxis: h\n          }),\n          {\n            verticalAlign: x\n          } = d;\n        if (p && m) {\n          let t = p.getBBox(),\n            e = p.padding,\n            i = "justify" === l(u.overflow, "justify"),\n            s;\n          d.x = u.x || 0, d.y = u.y || 0;\n          let {\n            x: r,\n            y: a\n          } = this.adjustStackPosition({\n            labelBox: t,\n            verticalAlign: x,\n            textAlign: g\n          });\n          m.x -= r, m.y -= a, p.align(d, !1, m), (s = f.isInsidePlot(p.alignAttr.x + d.x + r, p.alignAttr.y + d.y + a)) || (i = !1), i && o.prototype.justifyDataLabel.call(c, p, d, p.alignAttr, t, m), p.attr({\n            x: p.alignAttr.x,\n            y: p.alignAttr.y,\n            rotation: u.rotation,\n            rotationOriginX: t.width / 2,\n            rotationOriginY: t.height / 2\n          }), l(!i && u.crop, !0) && (s = n(p.x) && n(p.y) && f.isInsidePlot(p.x - e + (p.width || 0), p.y) && f.isInsidePlot(p.x + e, p.y)), p[s ? "show" : "hide"]();\n        }\n        a(this, "afterSetOffset", {\n          xOffset: t,\n          width: e\n        });\n      }\n      adjustStackPosition({\n        labelBox: t,\n        verticalAlign: e,\n        textAlign: i\n      }) {\n        let s = {\n            bottom: 0,\n            middle: 1,\n            top: 2,\n            right: 1,\n            center: 0,\n            left: -1\n          },\n          o = s[e],\n          r = s[i];\n        return {\n          x: t.width / 2 + t.width / 2 * r,\n          y: t.height / 2 * o\n        };\n      }\n      getStackBox(t) {\n        let e = this.axis,\n          i = e.chart,\n          {\n            boxTop: s,\n            defaultX: o,\n            xOffset: r,\n            width: a,\n            boxBottom: h\n          } = t,\n          d = e.stacking.usePercentage ? 100 : l(s, this.total, 0),\n          c = e.toPixels(d),\n          p = t.xAxis || i.xAxis[0],\n          u = l(o, p.translate(this.x)) + r,\n          g = e.toPixels(h || n(e.min) && e.logarithmic && e.logarithmic.lin2log(e.min) || 0),\n          f = Math.abs(c - g),\n          m = i.inverted,\n          x = this.isNegative;\n        return m ? {\n          x: (x ? c : c - f) - i.plotLeft,\n          y: p.height - u - a,\n          width: f,\n          height: a\n        } : {\n          x: u + p.transB - i.plotLeft,\n          y: (x ? c - f : c) - i.plotTop,\n          width: a,\n          height: f\n        };\n      }\n    };\n  }), i(e, "Core/Axis/Stacking/StackingAxis.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Axis/Axis.js"], e["Core/Globals.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Axis/Stacking/StackItem.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, r) {\n    var a;\n    let {\n        getDeferredAnimation: n\n      } = t,\n      {\n        composed: l\n      } = i,\n      {\n        series: {\n          prototype: h\n        }\n      } = s,\n      {\n        addEvent: d,\n        correctFloat: c,\n        defined: p,\n        destroyObjectProperties: u,\n        fireEvent: g,\n        isArray: f,\n        isNumber: m,\n        objectEach: x,\n        pick: y,\n        pushUnique: b\n      } = r;\n    function v() {\n      let t = this.inverted;\n      this.axes.forEach(t => {\n        t.stacking && t.stacking.stacks && t.hasVisibleSeries && (t.stacking.oldStacks = t.stacking.stacks);\n      }), this.series.forEach(e => {\n        let i = e.xAxis && e.xAxis.options || {};\n        e.options.stacking && e.reserveSpace() && (e.stackKey = [e.type, y(e.options.stack, ""), t ? i.top : i.left, t ? i.height : i.width].join(","));\n      });\n    }\n    function M() {\n      let t = this.stacking;\n      if (t) {\n        let e = t.stacks;\n        x(e, (t, i) => {\n          u(t), delete e[i];\n        }), t.stackTotalGroup?.destroy();\n      }\n    }\n    function S() {\n      this.stacking || (this.stacking = new P(this));\n    }\n    function k(t, e, i, s) {\n      return !p(t) || t.x !== e || s && t.stackKey !== s ? t = {\n        x: e,\n        index: 0,\n        key: s,\n        stackKey: s\n      } : t.index++, t.key = [i, e, t.index].join(","), t;\n    }\n    function C() {\n      let t;\n      let e = this,\n        i = e.yAxis,\n        s = e.stackKey || "",\n        o = i.stacking.stacks,\n        r = e.processedXData,\n        a = e.options.stacking,\n        n = e[a + "Stacker"];\n      n && [s, "-" + s].forEach(i => {\n        let s = r.length,\n          a,\n          l,\n          h;\n        for (; s--;) a = r[s], t = e.getStackIndicator(t, a, e.index, i), l = o[i]?.[a], (h = l?.points[t.key || ""]) && n.call(e, h, l, s);\n      });\n    }\n    function A(t, e, i) {\n      let s = e.total ? 100 / e.total : 0;\n      t[0] = c(t[0] * s), t[1] = c(t[1] * s), this.stackedYData[i] = t[1];\n    }\n    function w(t) {\n      (this.is("column") || this.is("columnrange")) && (this.options.centerInCategory && !this.options.stacking && this.chart.series.length > 1 ? h.setStackedPoints.call(this, t, "group") : t.stacking.resetStacks());\n    }\n    function T(t, e) {\n      let i, s, r, a, n, l, h, d, u;\n      let g = e || this.options.stacking;\n      if (!g || !this.reserveSpace() || ({\n        group: "xAxis"\n      }[g] || "yAxis") !== t.coll) return;\n      let m = this.processedXData,\n        x = this.processedYData,\n        b = [],\n        v = x.length,\n        M = this.options,\n        S = M.threshold || 0,\n        k = M.startFromThreshold ? S : 0,\n        C = M.stack,\n        A = e ? `${this.type},${g}` : this.stackKey || "",\n        w = "-" + A,\n        T = this.negStacks,\n        P = t.stacking,\n        L = P.stacks,\n        D = P.oldStacks;\n      for (P.stacksTouched += 1, h = 0; h < v; h++) {\n        d = m[h], u = x[h], l = (i = this.getStackIndicator(i, d, this.index)).key || "", L[n = (s = T && u < (k ? 0 : S)) ? w : A] || (L[n] = {}), L[n][d] || (D[n]?.[d] ? (L[n][d] = D[n][d], L[n][d].total = null) : L[n][d] = new o(t, t.options.stackLabels, !!s, d, C)), r = L[n][d], null !== u ? (r.points[l] = r.points[this.index] = [y(r.cumulative, k)], p(r.cumulative) || (r.base = l), r.touched = P.stacksTouched, i.index > 0 && !1 === this.singleStacks && (r.points[l][0] = r.points[this.index + "," + d + ",0"][0])) : (delete r.points[l], delete r.points[this.index]);\n        let e = r.total || 0;\n        "percent" === g ? (a = s ? A : w, e = T && L[a]?.[d] ? (a = L[a][d]).total = Math.max(a.total || 0, e) + Math.abs(u) || 0 : c(e + (Math.abs(u) || 0))) : "group" === g ? (f(u) && (u = u[0]), null !== u && e++) : e = c(e + (u || 0)), "group" === g ? r.cumulative = (e || 1) - 1 : r.cumulative = c(y(r.cumulative, k) + (u || 0)), r.total = e, null !== u && (r.points[l].push(r.cumulative), b[h] = r.cumulative, r.hasValidPoints = !0);\n      }\n      "percent" === g && (P.usePercentage = !0), "group" !== g && (this.stackedYData = b), P.oldStacks = {};\n    }\n    class P {\n      constructor(t) {\n        this.oldStacks = {}, this.stacks = {}, this.stacksTouched = 0, this.axis = t;\n      }\n      buildStacks() {\n        let t, e;\n        let i = this.axis,\n          s = i.series,\n          o = "xAxis" === i.coll,\n          r = i.options.reversedStacks,\n          a = s.length;\n        for (this.resetStacks(), this.usePercentage = !1, e = a; e--;) t = s[r ? e : a - e - 1], o && t.setGroupedPoints(i), t.setStackedPoints(i);\n        if (!o) for (e = 0; e < a; e++) s[e].modifyStacks();\n        g(i, "afterBuildStacks");\n      }\n      cleanStacks() {\n        this.oldStacks && (this.stacks = this.oldStacks, x(this.stacks, t => {\n          x(t, t => {\n            t.cumulative = t.total;\n          });\n        }));\n      }\n      resetStacks() {\n        x(this.stacks, t => {\n          x(t, (e, i) => {\n            m(e.touched) && e.touched < this.stacksTouched ? (e.destroy(), delete t[i]) : (e.total = null, e.cumulative = null);\n          });\n        });\n      }\n      renderStackTotals() {\n        let t = this.axis,\n          e = t.chart,\n          i = e.renderer,\n          s = this.stacks,\n          o = t.options.stackLabels?.animation,\n          r = n(e, o || !1),\n          a = this.stackTotalGroup = this.stackTotalGroup || i.g("stack-labels").attr({\n            zIndex: 6,\n            opacity: 0\n          }).add();\n        a.translate(e.plotLeft, e.plotTop), x(s, t => {\n          x(t, t => {\n            t.render(a);\n          });\n        }), a.animate({\n          opacity: 1\n        }, r);\n      }\n    }\n    return (a || (a = {})).compose = function t(e, i, s) {\n      if (b(l, t)) {\n        let t = i.prototype,\n          o = s.prototype;\n        d(e, "init", S), d(e, "destroy", M), t.getStacks = v, o.getStackIndicator = k, o.modifyStacks = C, o.percentStacker = A, o.setGroupedPoints = w, o.setStackedPoints = T;\n      }\n    }, a;\n  }), i(e, "Series/Line/LineSeries.js", [e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i) {\n    let {\n      defined: s,\n      merge: o,\n      isObject: r\n    } = i;\n    class a extends t {\n      drawGraph() {\n        let t = this.options,\n          e = (this.gappedPath || this.getGraphPath).call(this),\n          i = this.chart.styledMode;\n        [this, ...this.zones].forEach((s, a) => {\n          let n,\n            l = s.graph,\n            h = l ? "animate" : "attr",\n            d = s.dashStyle || t.dashStyle;\n          l ? (l.endX = this.preventGraphAnimation ? null : e.xMap, l.animate({\n            d: e\n          })) : e.length && (s.graph = l = this.chart.renderer.path(e).addClass("highcharts-graph" + (a ? ` highcharts-zone-graph-${a - 1} ` : " ") + (a && s.className || "")).attr({\n            zIndex: 1\n          }).add(this.group)), l && !i && (n = {\n            stroke: !a && t.lineColor || s.color || this.color || "#cccccc",\n            "stroke-width": t.lineWidth || 0,\n            fill: this.fillGraph && this.color || "none"\n          }, d ? n.dashstyle = d : "square" !== t.linecap && (n["stroke-linecap"] = n["stroke-linejoin"] = "round"), l[h](n).shadow(a < 2 && t.shadow && o({\n            filterUnits: "userSpaceOnUse"\n          }, r(t.shadow) ? t.shadow : {}))), l && (l.startX = e.xMap, l.isArea = e.isArea);\n        });\n      }\n      getGraphPath(t, e, i) {\n        let o = this,\n          r = o.options,\n          a = [],\n          n = [],\n          l,\n          h = r.step;\n        t = t || o.points;\n        let d = t.reversed;\n        return d && t.reverse(), (h = {\n          right: 1,\n          center: 2\n        }[h] || h && 3) && d && (h = 4 - h), (t = this.getValidPoints(t, !1, !(r.connectNulls && !e && !i))).forEach(function (d, c) {\n          let p;\n          let u = d.plotX,\n            g = d.plotY,\n            f = t[c - 1],\n            m = d.isNull || "number" != typeof g;\n          (d.leftCliff || f && f.rightCliff) && !i && (l = !0), m && !s(e) && c > 0 ? l = !r.connectNulls : m && !e ? l = !0 : (0 === c || l ? p = [["M", d.plotX, d.plotY]] : o.getPointSpline ? p = [o.getPointSpline(t, d, c)] : h ? (p = 1 === h ? [["L", f.plotX, g]] : 2 === h ? [["L", (f.plotX + u) / 2, f.plotY], ["L", (f.plotX + u) / 2, g]] : [["L", u, f.plotY]]).push(["L", u, g]) : p = [["L", u, g]], n.push(d.x), h && (n.push(d.x), 2 === h && n.push(d.x)), a.push.apply(a, p), l = !1);\n        }), a.xMap = n, o.graphPath = a, a;\n      }\n    }\n    return a.defaultOptions = o(t.defaultOptions, {\n      legendSymbol: "lineMarker"\n    }), e.registerSeriesType("line", a), a;\n  }), i(e, "Series/Area/AreaSeries.js", [e["Core/Color/Color.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i) {\n    let {\n        parse: s\n      } = t,\n      {\n        seriesTypes: {\n          line: o\n        }\n      } = e,\n      {\n        extend: r,\n        merge: a,\n        objectEach: n,\n        pick: l\n      } = i;\n    class h extends o {\n      drawGraph() {\n        this.areaPath = [], super.drawGraph.apply(this);\n        let {\n          areaPath: t,\n          options: e\n        } = this;\n        [this, ...this.zones].forEach((i, s) => {\n          let o = {},\n            r = i.fillColor || e.fillColor,\n            a = i.area,\n            n = a ? "animate" : "attr";\n          a ? (a.endX = this.preventGraphAnimation ? null : t.xMap, a.animate({\n            d: t\n          })) : (o.zIndex = 0, (a = i.area = this.chart.renderer.path(t).addClass("highcharts-area" + (s ? ` highcharts-zone-area-${s - 1} ` : " ") + (s && i.className || "")).add(this.group)).isArea = !0), this.chart.styledMode || (o.fill = r || i.color || this.color, o["fill-opacity"] = r ? 1 : e.fillOpacity ?? .75, a.css({\n            pointerEvents: this.stickyTracking ? "none" : "auto"\n          })), a[n](o), a.startX = t.xMap, a.shiftUnit = e.step ? 2 : 1;\n        });\n      }\n      getGraphPath(t) {\n        let e, i, s;\n        let r = o.prototype.getGraphPath,\n          a = this.options,\n          n = a.stacking,\n          h = this.yAxis,\n          d = [],\n          c = [],\n          p = this.index,\n          u = h.stacking.stacks[this.stackKey],\n          g = a.threshold,\n          f = Math.round(h.getThreshold(a.threshold)),\n          m = l(a.connectNulls, "percent" === n),\n          x = function (i, s, o) {\n            let r = t[i],\n              a = n && u[r.x].points[p],\n              l = r[o + "Null"] || 0,\n              m = r[o + "Cliff"] || 0,\n              x,\n              y,\n              b = !0;\n            m || l ? (x = (l ? a[0] : a[1]) + m, y = a[0] + m, b = !!l) : !n && t[s] && t[s].isNull && (x = y = g), void 0 !== x && (c.push({\n              plotX: e,\n              plotY: null === x ? f : h.getThreshold(x),\n              isNull: b,\n              isCliff: !0\n            }), d.push({\n              plotX: e,\n              plotY: null === y ? f : h.getThreshold(y),\n              doCurve: !1\n            }));\n          };\n        t = t || this.points, n && (t = this.getStackPoints(t));\n        for (let o = 0, r = t.length; o < r; ++o) n || (t[o].leftCliff = t[o].rightCliff = t[o].leftNull = t[o].rightNull = void 0), i = t[o].isNull, e = l(t[o].rectPlotX, t[o].plotX), s = n ? l(t[o].yBottom, f) : f, i && !m || (m || x(o, o - 1, "left"), i && !n && m || (c.push(t[o]), d.push({\n          x: o,\n          plotX: e,\n          plotY: s\n        })), m || x(o, o + 1, "right"));\n        let y = r.call(this, c, !0, !0);\n        d.reversed = !0;\n        let b = r.call(this, d, !0, !0),\n          v = b[0];\n        v && "M" === v[0] && (b[0] = ["L", v[1], v[2]]);\n        let M = y.concat(b);\n        M.length && M.push(["Z"]);\n        let S = r.call(this, c, !1, m);\n        return M.xMap = y.xMap, this.areaPath = M, S;\n      }\n      getStackPoints(t) {\n        let e = this,\n          i = [],\n          s = [],\n          o = this.xAxis,\n          r = this.yAxis,\n          a = r.stacking.stacks[this.stackKey],\n          h = {},\n          d = r.series,\n          c = d.length,\n          p = r.options.reversedStacks ? 1 : -1,\n          u = d.indexOf(e);\n        if (t = t || this.points, this.options.stacking) {\n          for (let e = 0; e < t.length; e++) t[e].leftNull = t[e].rightNull = void 0, h[t[e].x] = t[e];\n          n(a, function (t, e) {\n            null !== t.total && s.push(e);\n          }), s.sort(function (t, e) {\n            return t - e;\n          });\n          let g = d.map(t => t.visible);\n          s.forEach(function (t, n) {\n            let f = 0,\n              m,\n              x;\n            if (h[t] && !h[t].isNull) i.push(h[t]), [-1, 1].forEach(function (i) {\n              let o = 1 === i ? "rightNull" : "leftNull",\n                r = a[s[n + i]],\n                l = 0;\n              if (r) {\n                let i = u;\n                for (; i >= 0 && i < c;) {\n                  let s = d[i].index;\n                  !(m = r.points[s]) && (s === e.index ? h[t][o] = !0 : g[i] && (x = a[t].points[s]) && (l -= x[1] - x[0])), i += p;\n                }\n              }\n              h[t][1 === i ? "rightCliff" : "leftCliff"] = l;\n            });else {\n              let e = u;\n              for (; e >= 0 && e < c;) {\n                let i = d[e].index;\n                if (m = a[t].points[i]) {\n                  f = m[1];\n                  break;\n                }\n                e += p;\n              }\n              f = l(f, 0), f = r.translate(f, 0, 1, 0, 1), i.push({\n                isNull: !0,\n                plotX: o.translate(t, 0, 0, 0, 1),\n                x: t,\n                plotY: f,\n                yBottom: f\n              });\n            }\n          });\n        }\n        return i;\n      }\n    }\n    return h.defaultOptions = a(o.defaultOptions, {\n      threshold: 0,\n      legendSymbol: "areaMarker"\n    }), r(h.prototype, {\n      singleStacks: !1\n    }), e.registerSeriesType("area", h), h;\n  }), i(e, "Series/Spline/SplineSeries.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e) {\n    let {\n        line: i\n      } = t.seriesTypes,\n      {\n        merge: s,\n        pick: o\n      } = e;\n    class r extends i {\n      getPointSpline(t, e, i) {\n        let s, r, a, n;\n        let l = e.plotX || 0,\n          h = e.plotY || 0,\n          d = t[i - 1],\n          c = t[i + 1];\n        function p(t) {\n          return t && !t.isNull && !1 !== t.doCurve && !e.isCliff;\n        }\n        if (p(d) && p(c)) {\n          let t = d.plotX || 0,\n            i = d.plotY || 0,\n            o = c.plotX || 0,\n            p = c.plotY || 0,\n            u = 0;\n          s = (1.5 * l + t) / 2.5, r = (1.5 * h + i) / 2.5, a = (1.5 * l + o) / 2.5, n = (1.5 * h + p) / 2.5, a !== s && (u = (n - r) * (a - l) / (a - s) + h - n), r += u, n += u, r > i && r > h ? (r = Math.max(i, h), n = 2 * h - r) : r < i && r < h && (r = Math.min(i, h), n = 2 * h - r), n > p && n > h ? (n = Math.max(p, h), r = 2 * h - n) : n < p && n < h && (n = Math.min(p, h), r = 2 * h - n), e.rightContX = a, e.rightContY = n, e.controlPoints = {\n            low: [s, r],\n            high: [a, n]\n          };\n        }\n        let u = ["C", o(d.rightContX, d.plotX, 0), o(d.rightContY, d.plotY, 0), o(s, l, 0), o(r, h, 0), l, h];\n        return d.rightContX = d.rightContY = void 0, u;\n      }\n    }\n    return r.defaultOptions = s(i.defaultOptions), t.registerSeriesType("spline", r), r;\n  }), i(e, "Series/AreaSpline/AreaSplineSeries.js", [e["Series/Spline/SplineSeries.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i) {\n    let {\n        area: s,\n        area: {\n          prototype: o\n        }\n      } = e.seriesTypes,\n      {\n        extend: r,\n        merge: a\n      } = i;\n    class n extends t {}\n    return n.defaultOptions = a(t.defaultOptions, s.defaultOptions), r(n.prototype, {\n      getGraphPath: o.getGraphPath,\n      getStackPoints: o.getStackPoints,\n      drawGraph: o.drawGraph\n    }), e.registerSeriesType("areaspline", n), n;\n  }), i(e, "Series/Column/ColumnSeriesDefaults.js", [], function () {\n    return {\n      borderRadius: 3,\n      centerInCategory: !1,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1\n        },\n        select: {\n          color: "#cccccc",\n          borderColor: "#000000"\n        }\n      },\n      dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        y: void 0\n      },\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: "#ffffff"\n    };\n  }), i(e, "Series/Column/ColumnSeries.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Color/Color.js"], e["Series/Column/ColumnSeriesDefaults.js"], e["Core/Globals.js"], e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, r, a) {\n    let {\n        animObject: n\n      } = t,\n      {\n        parse: l\n      } = e,\n      {\n        hasTouch: h,\n        noop: d\n      } = s,\n      {\n        clamp: c,\n        defined: p,\n        extend: u,\n        fireEvent: g,\n        isArray: f,\n        isNumber: m,\n        merge: x,\n        pick: y,\n        objectEach: b,\n        relativeLength: v\n      } = a;\n    class M extends o {\n      animate(t) {\n        let e, i;\n        let s = this,\n          o = this.yAxis,\n          r = o.pos,\n          a = s.options,\n          l = this.chart.inverted,\n          h = {},\n          d = l ? "translateX" : "translateY";\n        t ? (h.scaleY = .001, i = c(o.toPixels(a.threshold), r, r + o.len), l ? h.translateX = i - o.len : h.translateY = i, s.clipBox && s.setClip(), s.group.attr(h)) : (e = Number(s.group.attr(d)), s.group.animate({\n          scaleY: 1\n        }, u(n(s.options.animation), {\n          step: function (t, i) {\n            s.group && (h[d] = e + i.pos * (r - e), s.group.attr(h));\n          }\n        })));\n      }\n      init(t, e) {\n        super.init.apply(this, arguments);\n        let i = this;\n        (t = i.chart).hasRendered && t.series.forEach(function (t) {\n          t.type === i.type && (t.isDirty = !0);\n        });\n      }\n      getColumnMetrics() {\n        let t = this,\n          e = t.options,\n          i = t.xAxis,\n          s = t.yAxis,\n          o = i.options.reversedStacks,\n          r = i.reversed && !o || !i.reversed && o,\n          a = {},\n          n,\n          l = 0;\n        !1 === e.grouping ? l = 1 : t.chart.series.forEach(function (e) {\n          let i;\n          let o = e.yAxis,\n            r = e.options;\n          e.type === t.type && e.reserveSpace() && s.len === o.len && s.pos === o.pos && (r.stacking && "group" !== r.stacking ? (void 0 === a[n = e.stackKey] && (a[n] = l++), i = a[n]) : !1 !== r.grouping && (i = l++), e.columnIndex = i);\n        });\n        let h = Math.min(Math.abs(i.transA) * (!i.brokenAxis?.hasBreaks && i.ordinal?.slope || e.pointRange || i.closestPointRange || i.tickInterval || 1), i.len),\n          d = h * e.groupPadding,\n          c = (h - 2 * d) / (l || 1),\n          p = Math.min(e.maxPointWidth || i.len, y(e.pointWidth, c * (1 - 2 * e.pointPadding))),\n          u = (c - p) / 2,\n          g = (t.columnIndex || 0) + (r ? 1 : 0),\n          f = u + (d + g * c - h / 2) * (r ? -1 : 1);\n        return t.columnMetrics = {\n          width: p,\n          offset: f,\n          paddedWidth: c,\n          columnCount: l\n        }, t.columnMetrics;\n      }\n      crispCol(t, e, i, s) {\n        this.chart;\n        let o = this.borderWidth,\n          r = -(o % 2 ? .5 : 0),\n          a = o % 2 ? .5 : 1;\n        this.options.crisp && (i = Math.round(t + i) + r - (t = Math.round(t) + r));\n        let n = Math.round(e + s) + a,\n          l = .5 >= Math.abs(e) && n > .5;\n        return s = n - (e = Math.round(e) + a), l && s && (e -= 1, s += 1), {\n          x: t,\n          y: e,\n          width: i,\n          height: s\n        };\n      }\n      adjustForMissingColumns(t, e, i, s) {\n        if (!i.isNull && s.columnCount > 1) {\n          let o = this.xAxis.series.filter(t => t.visible).map(t => t.index),\n            r = 0,\n            a = 0;\n          b(this.xAxis.stacking?.stacks, t => {\n            if ("number" == typeof i.x) {\n              let e = t[i.x.toString()];\n              if (e) {\n                let t = e.points[this.index];\n                if (f(t)) {\n                  let t = Object.keys(e.points).filter(t => !t.match(",") && e.points[t] && e.points[t].length > 1).map(parseFloat).filter(t => -1 !== o.indexOf(t)).sort((t, e) => e - t);\n                  r = t.indexOf(this.index), a = t.length;\n                }\n              }\n            }\n          });\n          let n = (a - 1) * s.paddedWidth + e;\n          t = (i.plotX || 0) + n / 2 - e - r * s.paddedWidth;\n        }\n        return t;\n      }\n      translate() {\n        let t = this,\n          e = t.chart,\n          i = t.options,\n          s = t.dense = t.closestPointRange * t.xAxis.transA < 2,\n          r = t.borderWidth = y(i.borderWidth, s ? 0 : 1),\n          a = t.xAxis,\n          n = t.yAxis,\n          l = i.threshold,\n          h = y(i.minPointLength, 5),\n          d = t.getColumnMetrics(),\n          u = d.width,\n          f = t.pointXOffset = d.offset,\n          x = t.dataMin,\n          b = t.dataMax,\n          v = t.barW = Math.max(u, 1 + 2 * r),\n          M = t.translatedThreshold = n.getThreshold(l);\n        e.inverted && (M -= .5), i.pointPadding && (v = Math.ceil(v)), o.prototype.translate.apply(t), t.points.forEach(function (s) {\n          let o = y(s.yBottom, M),\n            r = 999 + Math.abs(o),\n            g = s.plotX || 0,\n            S = c(s.plotY, -r, n.len + r);\n          s.stackBox;\n          let k,\n            C = Math.min(S, o),\n            A = Math.max(S, o) - C,\n            w = u,\n            T = g + f,\n            P = v;\n          h && Math.abs(A) < h && (A = h, k = !n.reversed && !s.negative || n.reversed && s.negative, m(l) && m(b) && s.y === l && b <= l && (n.min || 0) < l && (x !== b || (n.max || 0) <= l) && (k = !k, s.negative = !s.negative), C = Math.abs(C - M) > h ? o - h : M - (k ? h : 0)), p(s.options.pointWidth) && (T -= Math.round(((w = P = Math.ceil(s.options.pointWidth)) - u) / 2)), i.centerInCategory && !i.stacking && (T = t.adjustForMissingColumns(T, w, s, d)), s.barX = T, s.pointWidth = w, s.tooltipPos = e.inverted ? [c(n.len + n.pos - e.plotLeft - S, n.pos - e.plotLeft, n.len + n.pos - e.plotLeft), a.len + a.pos - e.plotTop - T - P / 2, A] : [a.left - e.plotLeft + T + P / 2, c(S + n.pos - e.plotTop, n.pos - e.plotTop, n.len + n.pos - e.plotTop), A], s.shapeType = t.pointClass.prototype.shapeType || "roundedRect", s.shapeArgs = t.crispCol(T, s.isNull ? M : C, P, s.isNull ? 0 : A);\n        }), g(this, "afterColumnTranslate");\n      }\n      drawGraph() {\n        this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");\n      }\n      pointAttribs(t, e) {\n        let i = this.options,\n          s = this.pointAttrToOptions || {},\n          o = s.stroke || "borderColor",\n          r = s["stroke-width"] || "borderWidth",\n          a,\n          n,\n          h,\n          d = t && t.color || this.color,\n          c = t && t[o] || i[o] || d,\n          p = t && t.options.dashStyle || i.dashStyle,\n          u = t && t[r] || i[r] || this[r] || 0,\n          g = y(t && t.opacity, i.opacity, 1);\n        t && this.zones.length && (n = t.getZone(), d = t.options.color || n && (n.color || t.nonZonedColor) || this.color, n && (c = n.borderColor || c, p = n.dashStyle || p, u = n.borderWidth || u)), e && t && (h = (a = x(i.states[e], t.options.states && t.options.states[e] || {})).brightness, d = a.color || void 0 !== h && l(d).brighten(a.brightness).get() || d, c = a[o] || c, u = a[r] || u, p = a.dashStyle || p, g = y(a.opacity, g));\n        let f = {\n          fill: d,\n          stroke: c,\n          "stroke-width": u,\n          opacity: g\n        };\n        return p && (f.dashstyle = p), f;\n      }\n      drawPoints(t = this.points) {\n        let e;\n        let i = this,\n          s = this.chart,\n          o = i.options,\n          r = s.renderer,\n          a = o.animationLimit || 250;\n        t.forEach(function (t) {\n          let n = t.plotY,\n            l = t.graphic,\n            h = !!l,\n            d = l && s.pointCount < a ? "animate" : "attr";\n          m(n) && null !== t.y ? (e = t.shapeArgs, l && t.hasNewShapeType() && (l = l.destroy()), i.enabledDataSorting && (t.startXPos = i.xAxis.reversed ? -(e && e.width || 0) : i.xAxis.width), !l && (t.graphic = l = r[t.shapeType](e).add(t.group || i.group), l && i.enabledDataSorting && s.hasRendered && s.pointCount < a && (l.attr({\n            x: t.startXPos\n          }), h = !0, d = "animate")), l && h && l[d](x(e)), s.styledMode || l[d](i.pointAttribs(t, t.selected && "select")).shadow(!1 !== t.allowShadow && o.shadow), l && (l.addClass(t.getClassName(), !0), l.attr({\n            visibility: t.visible ? "inherit" : "hidden"\n          }))) : l && (t.graphic = l.destroy());\n        });\n      }\n      drawTracker(t = this.points) {\n        let e;\n        let i = this,\n          s = i.chart,\n          o = s.pointer,\n          r = function (t) {\n            let e = o.getPointFromEvent(t);\n            void 0 !== e && i.options.enableMouseTracking && (o.isDirectTouch = !0, e.onMouseOver(t));\n          };\n        t.forEach(function (t) {\n          e = f(t.dataLabels) ? t.dataLabels : t.dataLabel ? [t.dataLabel] : [], t.graphic && (t.graphic.element.point = t), e.forEach(function (e) {\n            e.div ? e.div.point = t : e.element.point = t;\n          });\n        }), i._hasTracking || (i.trackerGroups.forEach(function (t) {\n          i[t] && (i[t].addClass("highcharts-tracker").on("mouseover", r).on("mouseout", function (t) {\n            o.onTrackerMouseOut(t);\n          }), h && i[t].on("touchstart", r), !s.styledMode && i.options.cursor && i[t].css({\n            cursor: i.options.cursor\n          }));\n        }), i._hasTracking = !0), g(this, "afterDrawTracker");\n      }\n      remove() {\n        let t = this,\n          e = t.chart;\n        e.hasRendered && e.series.forEach(function (e) {\n          e.type === t.type && (e.isDirty = !0);\n        }), o.prototype.remove.apply(t, arguments);\n      }\n    }\n    return M.defaultOptions = x(o.defaultOptions, i), u(M.prototype, {\n      directTouch: !0,\n      getSymbol: d,\n      negStacks: !0,\n      trackerGroups: ["group", "dataLabelsGroup"]\n    }), r.registerSeriesType("column", M), M;\n  }), i(e, "Core/Series/DataLabel.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Templating.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e, i, s) {\n    var o;\n    let {\n        getDeferredAnimation: r\n      } = t,\n      {\n        format: a\n      } = e,\n      {\n        composed: n\n      } = i,\n      {\n        defined: l,\n        extend: h,\n        fireEvent: d,\n        isArray: c,\n        isString: p,\n        merge: u,\n        objectEach: g,\n        pick: f,\n        pInt: m,\n        pushUnique: x,\n        splat: y\n      } = s;\n    return function (t) {\n      function e() {\n        return S(this).some(t => t?.enabled);\n      }\n      function i(t, e, i, s, o) {\n        let r = this,\n          a = this.chart,\n          n = this.isCartesian && a.inverted,\n          d = this.enabledDataSorting,\n          c = t.plotX,\n          p = t.plotY,\n          u = i.rotation,\n          g = i.align,\n          m = l(c) && l(p) && a.isInsidePlot(c, Math.round(p), {\n            inverted: n,\n            paneCoordinates: !0,\n            series: r\n          }),\n          x = i => {\n            d && r.xAxis && !M && r.setDataLabelStartPos(t, e, o, m, i);\n          },\n          y,\n          b,\n          v,\n          M = "justify" === f(i.overflow, d ? "none" : "justify"),\n          S = this.visible && !1 !== t.visible && l(c) && (t.series.forceDL || d && !M || m || f(i.inside, !!this.options.stacking) && s && a.isInsidePlot(c, n ? s.x + 1 : s.y + s.height - 1, {\n            inverted: n,\n            paneCoordinates: !0,\n            series: r\n          })),\n          k = t.pos();\n        if (S && k) {\n          u && e.attr({\n            align: g\n          });\n          let t = e.getBBox(!0),\n            n = [0, 0];\n          if (y = a.renderer.fontMetrics(e).b, s = h({\n            x: k[0],\n            y: Math.round(k[1]),\n            width: 0,\n            height: 0\n          }, s), h(i, {\n            width: t.width,\n            height: t.height\n          }), u ? (M = !1, b = a.renderer.rotCorr(y, u), v = {\n            x: s.x + (i.x || 0) + s.width / 2 + b.x,\n            y: s.y + (i.y || 0) + {\n              top: 0,\n              middle: .5,\n              bottom: 1\n            }[i.verticalAlign] * s.height\n          }, n = [t.x - Number(e.attr("x")), t.y - Number(e.attr("y"))], x(v), e[o ? "attr" : "animate"](v)) : (x(s), e.align(i, void 0, s), v = e.alignAttr), M && s.height >= 0) this.justifyDataLabel(e, i, v, t, s, o);else if (f(i.crop, !0)) {\n            let {\n              x: e,\n              y: i\n            } = v;\n            e += n[0], i += n[1], S = a.isInsidePlot(e, i, {\n              paneCoordinates: !0,\n              series: r\n            }) && a.isInsidePlot(e + t.width, i + t.height, {\n              paneCoordinates: !0,\n              series: r\n            });\n          }\n          i.shape && !u && e[o ? "attr" : "animate"]({\n            anchorX: k[0],\n            anchorY: k[1]\n          });\n        }\n        o && d && (e.placed = !1), S || d && !M ? e.show() : (e.hide(), e.placed = !1);\n      }\n      function s() {\n        return this.plotGroup("dataLabelsGroup", "data-labels", this.hasRendered ? "inherit" : "hidden", this.options.dataLabels.zIndex || 6);\n      }\n      function o(t) {\n        let e = this.hasRendered || 0,\n          i = this.initDataLabelsGroup().attr({\n            opacity: +e\n          });\n        return !e && i && (this.visible && i.show(), this.options.animation ? i.animate({\n          opacity: 1\n        }, t) : i.attr({\n          opacity: 1\n        })), i;\n      }\n      function b(t) {\n        let e;\n        t = t || this.points;\n        let i = this,\n          s = i.chart,\n          o = i.options,\n          n = s.renderer,\n          {\n            backgroundColor: h,\n            plotBackgroundColor: c\n          } = s.options.chart,\n          u = n.getContrast(p(c) && c || p(h) && h || "#000000"),\n          x = S(i),\n          {\n            animation: b,\n            defer: v\n          } = x[0],\n          k = v ? r(s, b, i) : {\n            defer: 0,\n            duration: 0\n          };\n        d(this, "drawDataLabels"), i.hasDataLabels?.() && (e = this.initDataLabels(k), t.forEach(t => {\n          let r = t.dataLabels || [];\n          y(M(x, t.dlOptions || t.options?.dataLabels)).forEach((h, d) => {\n            let c = h.enabled && t.visible && (!t.isNull || t.dataLabelOnNull) && function (t, e) {\n                let i = e.filter;\n                if (i) {\n                  let e = i.operator,\n                    s = t[i.property],\n                    o = i.value;\n                  return ">" === e && s > o || "<" === e && s < o || ">=" === e && s >= o || "<=" === e && s <= o || "==" === e && s == o || "===" === e && s === o || "!=" === e && s != o || "!==" === e && s !== o;\n                }\n                return !0;\n              }(t, h),\n              {\n                backgroundColor: x,\n                borderColor: y,\n                distance: b,\n                style: v = {}\n              } = h,\n              M,\n              S,\n              k,\n              C,\n              A = {},\n              w = r[d],\n              T = !w,\n              P;\n            if (c && (S = f(h[t.formatPrefix + "Format"], h.format), M = t.getLabelConfig(), k = l(S) ? a(S, M, s) : (h[t.formatPrefix + "Formatter"] || h.formatter).call(M, h), C = h.rotation, !s.styledMode && (v.color = f(h.color, v.color, p(i.color) ? i.color : void 0, "#000000"), "contrast" === v.color ? ("none" !== x && (P = x), t.contrastColor = n.getContrast("auto" !== P && P || t.color || i.color), v.color = P || !l(b) && h.inside || 0 > m(b || 0) || o.stacking ? t.contrastColor : u) : delete t.contrastColor, o.cursor && (v.cursor = o.cursor)), A = {\n              r: h.borderRadius || 0,\n              rotation: C,\n              padding: h.padding,\n              zIndex: 1\n            }, s.styledMode || (A.fill = "auto" === x ? t.color : x, A.stroke = "auto" === y ? t.color : y, A["stroke-width"] = h.borderWidth), g(A, (t, e) => {\n              void 0 === t && delete A[e];\n            })), !w || c && l(k) && !!w.div == !!h.useHTML && (w.rotation && h.rotation || w.rotation === h.rotation) || (w = void 0, T = !0), c && l(k) && (w ? A.text = k : (w = C ? n.text(k, 0, 0, h.useHTML).addClass("highcharts-data-label") : n.label(k, 0, 0, h.shape, void 0, void 0, h.useHTML, void 0, "data-label")) && w.addClass(" highcharts-data-label-color-" + t.colorIndex + " " + (h.className || "") + (h.useHTML ? " highcharts-tracker" : "")), w)) {\n              w.options = h, w.attr(A), s.styledMode || w.css(v).shadow(h.shadow);\n              let o = h[t.formatPrefix + "TextPath"] || h.textPath;\n              o && !h.useHTML && (w.setTextPath(t.getDataLabelPath?.(w) || t.graphic, o), t.dataLabelPath && !o.enabled && (t.dataLabelPath = t.dataLabelPath.destroy())), w.added || w.add(e), i.alignDataLabel(t, w, h, void 0, T), w.isActive = !0, r[d] && r[d] !== w && r[d].destroy(), r[d] = w;\n            }\n          });\n          let h = r.length;\n          for (; h--;) r[h] && r[h].isActive ? r[h].isActive = !1 : (r[h]?.destroy(), r.splice(h, 1));\n          t.dataLabel = r[0], t.dataLabels = r;\n        })), d(this, "afterDrawDataLabels");\n      }\n      function v(t, e, i, s, o, r) {\n        let a = this.chart,\n          n = e.align,\n          l = e.verticalAlign,\n          h = t.box ? 0 : t.padding || 0,\n          {\n            x: d = 0,\n            y: c = 0\n          } = e,\n          p,\n          u;\n        return (p = (i.x || 0) + h) < 0 && ("right" === n && d >= 0 ? (e.align = "left", e.inside = !0) : d -= p, u = !0), (p = (i.x || 0) + s.width - h) > a.plotWidth && ("left" === n && d <= 0 ? (e.align = "right", e.inside = !0) : d += a.plotWidth - p, u = !0), (p = i.y + h) < 0 && ("bottom" === l && c >= 0 ? (e.verticalAlign = "top", e.inside = !0) : c -= p, u = !0), (p = (i.y || 0) + s.height - h) > a.plotHeight && ("top" === l && c <= 0 ? (e.verticalAlign = "bottom", e.inside = !0) : c += a.plotHeight - p, u = !0), u && (e.x = d, e.y = c, t.placed = !r, t.align(e, void 0, o)), u;\n      }\n      function M(t, e) {\n        let i = [],\n          s;\n        if (c(t) && !c(e)) i = t.map(function (t) {\n          return u(t, e);\n        });else if (c(e) && !c(t)) i = e.map(function (e) {\n          return u(t, e);\n        });else if (c(t) || c(e)) {\n          if (c(t) && c(e)) for (s = Math.max(t.length, e.length); s--;) i[s] = u(t[s], e[s]);\n        } else i = u(t, e);\n        return i;\n      }\n      function S(t) {\n        let e = t.chart.options.plotOptions;\n        return y(M(M(e?.series?.dataLabels, e?.[t.type]?.dataLabels), t.options.dataLabels));\n      }\n      function k(t, e, i, s, o) {\n        let r = this.chart,\n          a = r.inverted,\n          n = this.xAxis,\n          l = n.reversed,\n          h = ((a ? e.height : e.width) || 0) / 2,\n          d = t.pointWidth,\n          c = d ? d / 2 : 0;\n        e.startXPos = a ? o.x : l ? -h - c : n.width - h + c, e.startYPos = a ? l ? this.yAxis.height - h + c : -h - c : o.y, s ? "hidden" === e.visibility && (e.show(), e.attr({\n          opacity: 0\n        }).animate({\n          opacity: 1\n        })) : e.attr({\n          opacity: 1\n        }).animate({\n          opacity: 0\n        }, void 0, e.hide), r.hasRendered && (i && e.attr({\n          x: e.startXPos,\n          y: e.startYPos\n        }), e.placed = !0);\n      }\n      t.compose = function t(r) {\n        if (x(n, t)) {\n          let t = r.prototype;\n          t.initDataLabelsGroup = s, t.initDataLabels = o, t.alignDataLabel = i, t.drawDataLabels = b, t.justifyDataLabel = v, t.setDataLabelStartPos = k, t.hasDataLabels = e;\n        }\n      };\n    }(o || (o = {})), o;\n  }), i(e, "Series/Column/ColumnDataLabel.js", [e["Core/Series/DataLabel.js"], e["Core/Globals.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s) {\n    var o;\n    let {\n        composed: r\n      } = e,\n      {\n        series: a\n      } = i,\n      {\n        merge: n,\n        pick: l,\n        pushUnique: h\n      } = s;\n    return function (e) {\n      function i(t, e, i, s, o) {\n        let r = this.chart.inverted,\n          h = t.series,\n          d = (h.xAxis ? h.xAxis.len : this.chart.plotSizeX) || 0,\n          c = (h.yAxis ? h.yAxis.len : this.chart.plotSizeY) || 0,\n          p = t.dlBox || t.shapeArgs,\n          u = l(t.below, t.plotY > l(this.translatedThreshold, c)),\n          g = l(i.inside, !!this.options.stacking);\n        if (p) {\n          if (s = n(p), !("allow" === i.overflow && !1 === i.crop)) {\n            s.y < 0 && (s.height += s.y, s.y = 0);\n            let t = s.y + s.height - c;\n            t > 0 && t < s.height && (s.height -= t);\n          }\n          r && (s = {\n            x: c - s.y - s.height,\n            y: d - s.x - s.width,\n            width: s.height,\n            height: s.width\n          }), g || (r ? (s.x += u ? 0 : s.width, s.width = 0) : (s.y += u ? s.height : 0, s.height = 0));\n        }\n        i.align = l(i.align, !r || g ? "center" : u ? "right" : "left"), i.verticalAlign = l(i.verticalAlign, r || g ? "middle" : u ? "top" : "bottom"), a.prototype.alignDataLabel.call(this, t, e, i, s, o), i.inside && t.contrastColor && e.css({\n          color: t.contrastColor\n        });\n      }\n      e.compose = function e(s) {\n        t.compose(a), h(r, e) && (s.prototype.alignDataLabel = i);\n      };\n    }(o || (o = {})), o;\n  }), i(e, "Series/Bar/BarSeries.js", [e["Series/Column/ColumnSeries.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i) {\n    let {\n      extend: s,\n      merge: o\n    } = i;\n    class r extends t {}\n    return r.defaultOptions = o(t.defaultOptions, {}), s(r.prototype, {\n      inverted: !0\n    }), e.registerSeriesType("bar", r), r;\n  }), i(e, "Series/Scatter/ScatterSeriesDefaults.js", [], function () {\n    return {\n      lineWidth: 0,\n      findNearestPointBy: "xy",\n      jitter: {\n        x: 0,\n        y: 0\n      },\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: \'<span style="color:{point.color}">‚óè</span> <span style="font-size: 0.8em"> {series.name}</span><br/>\',\n        pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"\n      }\n    };\n  }), i(e, "Series/Scatter/ScatterSeries.js", [e["Series/Scatter/ScatterSeriesDefaults.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i) {\n    let {\n        column: s,\n        line: o\n      } = e.seriesTypes,\n      {\n        addEvent: r,\n        extend: a,\n        merge: n\n      } = i;\n    class l extends o {\n      applyJitter() {\n        let t = this,\n          e = this.options.jitter,\n          i = this.points.length;\n        e && this.points.forEach(function (s, o) {\n          ["x", "y"].forEach(function (r, a) {\n            let n,\n              l = "plot" + r.toUpperCase(),\n              h,\n              d,\n              c;\n            e[r] && !s.isNull && (n = t[r + "Axis"], c = e[r] * n.transA, n && !n.isLog && (h = Math.max(0, s[l] - c), d = Math.min(n.len, s[l] + c), s[l] = h + (d - h) * function (t) {\n              let e = 1e4 * Math.sin(t);\n              return e - Math.floor(e);\n            }(o + a * i), "x" === r && (s.clientX = s.plotX)));\n          });\n        });\n      }\n      drawGraph() {\n        this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy());\n      }\n    }\n    return l.defaultOptions = n(o.defaultOptions, t), a(l.prototype, {\n      drawTracker: s.prototype.drawTracker,\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: ["group", "markerGroup", "dataLabelsGroup"]\n    }), r(l, "afterTranslate", function () {\n      this.applyJitter();\n    }), e.registerSeriesType("scatter", l), l;\n  }), i(e, "Series/CenteredUtilities.js", [e["Core/Globals.js"], e["Core/Series/Series.js"], e["Core/Utilities.js"]], function (t, e, i) {\n    var s, o;\n    let {\n        deg2rad: r\n      } = t,\n      {\n        fireEvent: a,\n        isNumber: n,\n        pick: l,\n        relativeLength: h\n      } = i;\n    return (o = s || (s = {})).getCenter = function () {\n      let t = this.options,\n        i = this.chart,\n        s = 2 * (t.slicedOffset || 0),\n        o = i.plotWidth - 2 * s,\n        r = i.plotHeight - 2 * s,\n        d = t.center,\n        c = Math.min(o, r),\n        p = t.thickness,\n        u,\n        g = t.size,\n        f = t.innerSize || 0,\n        m,\n        x;\n      "string" == typeof g && (g = parseFloat(g)), "string" == typeof f && (f = parseFloat(f));\n      let y = [l(d[0], "50%"), l(d[1], "50%"), l(g && g < 0 ? void 0 : t.size, "100%"), l(f && f < 0 ? void 0 : t.innerSize || 0, "0%")];\n      for (!i.angular || this instanceof e || (y[3] = 0), m = 0; m < 4; ++m) x = y[m], u = m < 2 || 2 === m && /%$/.test(x), y[m] = h(x, [o, r, c, y[2]][m]) + (u ? s : 0);\n      return y[3] > y[2] && (y[3] = y[2]), n(p) && 2 * p < y[2] && p > 0 && (y[3] = y[2] - 2 * p), a(this, "afterGetCenter", {\n        positions: y\n      }), y;\n    }, o.getStartAndEndRadians = function (t, e) {\n      let i = n(t) ? t : 0,\n        s = n(e) && e > i && e - i < 360 ? e : i + 360;\n      return {\n        start: r * (i + -90),\n        end: r * (s + -90)\n      };\n    }, s;\n  }), i(e, "Series/Pie/PiePoint.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Series/Point.js"], e["Core/Utilities.js"]], function (t, e, i) {\n    let {\n        setAnimation: s\n      } = t,\n      {\n        addEvent: o,\n        defined: r,\n        extend: a,\n        isNumber: n,\n        isString: l,\n        pick: h,\n        relativeLength: d\n      } = i;\n    class c extends e {\n      getConnectorPath(t) {\n        let e = t.dataLabelPosition,\n          i = t.options || {},\n          s = i.connectorShape,\n          o = this.connectorShapes[s] || s;\n        return e && o.call(this, {\n          ...e.computed,\n          alignment: e.alignment\n        }, e.connectorPosition, i) || [];\n      }\n      getTranslate() {\n        return this.sliced && this.slicedTranslation || {\n          translateX: 0,\n          translateY: 0\n        };\n      }\n      haloPath(t) {\n        let e = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e.x, e.y, e.r + t, e.r + t, {\n          innerR: e.r - 1,\n          start: e.start,\n          end: e.end,\n          borderRadius: e.borderRadius\n        });\n      }\n      constructor(t, e, i) {\n        super(t, e, i), this.half = 0, this.name ?? (this.name = "Slice");\n        let s = t => {\n          this.slice("select" === t.type);\n        };\n        o(this, "select", s), o(this, "unselect", s);\n      }\n      isValid() {\n        return n(this.y) && this.y >= 0;\n      }\n      setVisible(t, e = !0) {\n        t !== this.visible && this.update({\n          visible: t ?? !this.visible\n        }, e, void 0, !1);\n      }\n      slice(t, e, i) {\n        let o = this.series,\n          a = o.chart;\n        s(i, a), e = h(e, !0), this.sliced = this.options.sliced = t = r(t) ? t : !this.sliced, o.options.data[o.data.indexOf(this)] = this.options, this.graphic && this.graphic.animate(this.getTranslate());\n      }\n    }\n    return a(c.prototype, {\n      connectorShapes: {\n        fixedOffset: function (t, e, i) {\n          let s = e.breakAt,\n            o = e.touchingSliceAt,\n            r = i.softConnector ? ["C", t.x + ("left" === t.alignment ? -5 : 5), t.y, 2 * s.x - o.x, 2 * s.y - o.y, s.x, s.y] : ["L", s.x, s.y];\n          return [["M", t.x, t.y], r, ["L", o.x, o.y]];\n        },\n        straight: function (t, e) {\n          let i = e.touchingSliceAt;\n          return [["M", t.x, t.y], ["L", i.x, i.y]];\n        },\n        crookedLine: function (t, e, i) {\n          let {\n              breakAt: s,\n              touchingSliceAt: o\n            } = e,\n            {\n              series: r\n            } = this,\n            [a, n, l] = r.center,\n            h = l / 2,\n            {\n              plotLeft: c,\n              plotWidth: p\n            } = r.chart,\n            u = "left" === t.alignment,\n            {\n              x: g,\n              y: f\n            } = t,\n            m = s.x;\n          if (i.crookDistance) {\n            let t = d(i.crookDistance, 1);\n            m = u ? a + h + (p + c - a - h) * (1 - t) : c + (a - h) * t;\n          } else m = a + (n - f) * Math.tan((this.angle || 0) - Math.PI / 2);\n          let x = [["M", g, f]];\n          return (u ? m <= g && m >= s.x : m >= g && m <= s.x) && x.push(["L", m, f]), x.push(["L", s.x, s.y], ["L", o.x, o.y]), x;\n        }\n      }\n    }), c;\n  }), i(e, "Series/Pie/PieSeriesDefaults.js", [], function () {\n    return {\n      borderRadius: 3,\n      center: [null, null],\n      clip: !1,\n      colorByPoint: !0,\n      dataLabels: {\n        connectorPadding: 5,\n        connectorShape: "crookedLine",\n        crookDistance: void 0,\n        distance: 30,\n        enabled: !0,\n        formatter: function () {\n          return this.point.isNull ? void 0 : this.point.name;\n        },\n        softConnector: !0,\n        x: 0\n      },\n      fillColor: void 0,\n      ignoreHiddenPoint: !0,\n      inactiveOtherPoints: !0,\n      legendType: "point",\n      marker: null,\n      size: null,\n      showInLegend: !1,\n      slicedOffset: 10,\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0\n      },\n      borderColor: "#ffffff",\n      borderWidth: 1,\n      lineWidth: void 0,\n      states: {\n        hover: {\n          brightness: .1\n        }\n      }\n    };\n  }), i(e, "Series/Pie/PieSeries.js", [e["Series/CenteredUtilities.js"], e["Series/Column/ColumnSeries.js"], e["Core/Globals.js"], e["Series/Pie/PiePoint.js"], e["Series/Pie/PieSeriesDefaults.js"], e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Renderer/SVG/Symbols.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, r, a, n, l) {\n    let {\n        getStartAndEndRadians: h\n      } = t,\n      {\n        noop: d\n      } = i,\n      {\n        clamp: c,\n        extend: p,\n        fireEvent: u,\n        merge: g,\n        pick: f,\n        relativeLength: m,\n        splat: x\n      } = l;\n    class y extends r {\n      animate(t) {\n        let e = this,\n          i = e.points,\n          s = e.startAngleRad;\n        t || i.forEach(function (t) {\n          let i = t.graphic,\n            o = t.shapeArgs;\n          i && o && (i.attr({\n            r: f(t.startR, e.center && e.center[3] / 2),\n            start: s,\n            end: s\n          }), i.animate({\n            r: o.r,\n            start: o.start,\n            end: o.end\n          }, e.options.animation));\n        });\n      }\n      drawEmpty() {\n        let t, e;\n        let i = this.startAngleRad,\n          s = this.endAngleRad,\n          o = this.options;\n        0 === this.total && this.center ? (t = this.center[0], e = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(t, e, this.center[1] / 2, 0, i, s).addClass("highcharts-empty-series").add(this.group)), this.graph.attr({\n          d: n.arc(t, e, this.center[2] / 2, 0, {\n            start: i,\n            end: s,\n            innerR: this.center[3] / 2\n          })\n        }), this.chart.styledMode || this.graph.attr({\n          "stroke-width": o.borderWidth,\n          fill: o.fillColor || "none",\n          stroke: o.color || "#cccccc"\n        })) : this.graph && (this.graph = this.graph.destroy());\n      }\n      drawPoints() {\n        let t = this.chart.renderer;\n        this.points.forEach(function (e) {\n          e.graphic && e.hasNewShapeType() && (e.graphic = e.graphic.destroy()), e.graphic || (e.graphic = t[e.shapeType](e.shapeArgs).add(e.series.group), e.delayedRendering = !0);\n        });\n      }\n      generatePoints() {\n        super.generatePoints(), this.updateTotals();\n      }\n      getX(t, e, i, s) {\n        let o = this.center,\n          r = this.radii ? this.radii[i.index] || 0 : o[2] / 2,\n          a = s.dataLabelPosition,\n          n = a?.distance || 0,\n          l = Math.asin(c((t - o[1]) / (r + n), -1, 1)),\n          h = o[0] + (e ? -1 : 1) * (Math.cos(l) * (r + n)) + (n > 0 ? (e ? -1 : 1) * (s.padding || 0) : 0);\n        return h;\n      }\n      hasData() {\n        return !!this.processedXData.length;\n      }\n      redrawPoints() {\n        let t, e, i, s;\n        let o = this,\n          r = o.chart;\n        this.drawEmpty(), o.group && !r.styledMode && o.group.shadow(o.options.shadow), o.points.forEach(function (a) {\n          let n = {};\n          e = a.graphic, !a.isNull && e ? (s = a.shapeArgs, t = a.getTranslate(), r.styledMode || (i = o.pointAttribs(a, a.selected && "select")), a.delayedRendering ? (e.setRadialReference(o.center).attr(s).attr(t), r.styledMode || e.attr(i).attr({\n            "stroke-linejoin": "round"\n          }), a.delayedRendering = !1) : (e.setRadialReference(o.center), r.styledMode || g(!0, n, i), g(!0, n, s, t), e.animate(n)), e.attr({\n            visibility: a.visible ? "inherit" : "hidden"\n          }), e.addClass(a.getClassName(), !0)) : e && (a.graphic = e.destroy());\n        });\n      }\n      sortByAngle(t, e) {\n        t.sort(function (t, i) {\n          return void 0 !== t.angle && (i.angle - t.angle) * e;\n        });\n      }\n      translate(t) {\n        u(this, "translate"), this.generatePoints();\n        let e = this.options,\n          i = e.slicedOffset,\n          s = h(e.startAngle, e.endAngle),\n          o = this.startAngleRad = s.start,\n          r = this.endAngleRad = s.end,\n          a = r - o,\n          n = this.points,\n          l = e.ignoreHiddenPoint,\n          d = n.length,\n          c,\n          p,\n          g,\n          f,\n          m,\n          x,\n          y,\n          b = 0;\n        for (t || (this.center = t = this.getCenter()), x = 0; x < d; x++) {\n          y = n[x], c = o + b * a, y.isValid() && (!l || y.visible) && (b += y.percentage / 100), p = o + b * a;\n          let e = {\n            x: t[0],\n            y: t[1],\n            r: t[2] / 2,\n            innerR: t[3] / 2,\n            start: Math.round(1e3 * c) / 1e3,\n            end: Math.round(1e3 * p) / 1e3\n          };\n          y.shapeType = "arc", y.shapeArgs = e, (g = (p + c) / 2) > 1.5 * Math.PI ? g -= 2 * Math.PI : g < -Math.PI / 2 && (g += 2 * Math.PI), y.slicedTranslation = {\n            translateX: Math.round(Math.cos(g) * i),\n            translateY: Math.round(Math.sin(g) * i)\n          }, f = Math.cos(g) * t[2] / 2, m = Math.sin(g) * t[2] / 2, y.tooltipPos = [t[0] + .7 * f, t[1] + .7 * m], y.half = g < -Math.PI / 2 || g > Math.PI / 2 ? 1 : 0, y.angle = g;\n        }\n        u(this, "afterTranslate");\n      }\n      updateTotals() {\n        let t = this.points,\n          e = t.length,\n          i = this.options.ignoreHiddenPoint,\n          s,\n          o,\n          r = 0;\n        for (s = 0; s < e; s++) (o = t[s]).isValid() && (!i || o.visible) && (r += o.y);\n        for (s = 0, this.total = r; s < e; s++) (o = t[s]).percentage = r > 0 && (o.visible || !i) ? o.y / r * 100 : 0, o.total = r;\n      }\n    }\n    return y.defaultOptions = g(r.defaultOptions, o), p(y.prototype, {\n      axisTypes: [],\n      directTouch: !0,\n      drawGraph: void 0,\n      drawTracker: e.prototype.drawTracker,\n      getCenter: t.getCenter,\n      getSymbol: d,\n      isCartesian: !1,\n      noSharedTooltip: !0,\n      pointAttribs: e.prototype.pointAttribs,\n      pointClass: s,\n      requireSorting: !1,\n      searchPoint: d,\n      trackerGroups: ["group", "dataLabelsGroup"]\n    }), a.registerSeriesType("pie", y), y;\n  }), i(e, "Series/Pie/PieDataLabel.js", [e["Core/Series/DataLabel.js"], e["Core/Globals.js"], e["Core/Renderer/RendererUtilities.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s, o) {\n    var r;\n    let {\n        composed: a,\n        noop: n\n      } = e,\n      {\n        distribute: l\n      } = i,\n      {\n        series: h\n      } = s,\n      {\n        arrayMax: d,\n        clamp: c,\n        defined: p,\n        pick: u,\n        pushUnique: g,\n        relativeLength: f\n      } = o;\n    return function (e) {\n      let i = {\n        radialDistributionY: function (t, e) {\n          return (e.dataLabelPosition?.top || 0) + t.distributeBox.pos;\n        },\n        radialDistributionX: function (t, e, i, s, o) {\n          let r = o.dataLabelPosition;\n          return t.getX(i < (r?.top || 0) + 2 || i > (r?.bottom || 0) - 2 ? s : i, e.half, e, o);\n        },\n        justify: function (t, e, i, s) {\n          return s[0] + (t.half ? -1 : 1) * (i + (e.dataLabelPosition?.distance || 0));\n        },\n        alignToPlotEdges: function (t, e, i, s) {\n          let o = t.getBBox().width;\n          return e ? o + s : i - o - s;\n        },\n        alignToConnectors: function (t, e, i, s) {\n          let o = 0,\n            r;\n          return t.forEach(function (t) {\n            (r = t.dataLabel.getBBox().width) > o && (o = r);\n          }), e ? o + s : i - o - s;\n        }\n      };\n      function s(t, e) {\n        let {\n            center: i,\n            options: s\n          } = this,\n          o = i[2] / 2,\n          r = t.angle || 0,\n          a = Math.cos(r),\n          n = Math.sin(r),\n          l = i[0] + a * o,\n          h = i[1] + n * o,\n          d = Math.min((s.slicedOffset || 0) + (s.borderWidth || 0), e / 5);\n        return {\n          natural: {\n            x: l + a * e,\n            y: h + n * e\n          },\n          computed: {},\n          alignment: e < 0 ? "center" : t.half ? "right" : "left",\n          connectorPosition: {\n            breakAt: {\n              x: l + a * d,\n              y: h + n * d\n            },\n            touchingSliceAt: {\n              x: l,\n              y: h\n            }\n          },\n          distance: e\n        };\n      }\n      function o() {\n        let t = this,\n          e = t.points,\n          i = t.chart,\n          s = i.plotWidth,\n          o = i.plotHeight,\n          r = i.plotLeft,\n          a = Math.round(i.chartWidth / 3),\n          n = t.center,\n          c = n[2] / 2,\n          g = n[1],\n          m = [[], []],\n          x = [0, 0, 0, 0],\n          y = t.dataLabelPositioners,\n          b,\n          v,\n          M,\n          S = 0;\n        t.visible && t.hasDataLabels?.() && (e.forEach(t => {\n          (t.dataLabels || []).forEach(t => {\n            t.shortened && (t.attr({\n              width: "auto"\n            }).css({\n              width: "auto",\n              textOverflow: "clip"\n            }), t.shortened = !1);\n          });\n        }), h.prototype.drawDataLabels.apply(t), e.forEach(t => {\n          (t.dataLabels || []).forEach((e, i) => {\n            let s = n[2] / 2,\n              o = e.options,\n              r = f(o?.distance || 0, s);\n            0 === i && m[t.half].push(t), !p(o?.style?.width) && e.getBBox().width > a && (e.css({\n              width: Math.round(.7 * a) + "px"\n            }), e.shortened = !0), e.dataLabelPosition = this.getDataLabelPosition(t, r), S = Math.max(S, r);\n          });\n        }), m.forEach((e, a) => {\n          let h = e.length,\n            d = [],\n            f,\n            m,\n            b = 0,\n            k;\n          h && (t.sortByAngle(e, a - .5), S > 0 && (f = Math.max(0, g - c - S), m = Math.min(g + c + S, i.plotHeight), e.forEach(t => {\n            (t.dataLabels || []).forEach((e, s) => {\n              let o = e.dataLabelPosition;\n              o && o.distance > 0 && (o.top = Math.max(0, g - c - o.distance), o.bottom = Math.min(g + c + o.distance, i.plotHeight), b = e.getBBox().height || 21, t.distributeBox = {\n                target: (e.dataLabelPosition?.natural.y || 0) - o.top + b / 2,\n                size: b,\n                rank: t.y\n              }, d.push(t.distributeBox));\n            });\n          }), l(d, k = m + b - f, k / 5)), e.forEach(i => {\n            (i.dataLabels || []).forEach(l => {\n              let h = l.options || {},\n                g = i.distributeBox,\n                f = l.dataLabelPosition,\n                m = f?.natural.y || 0,\n                b = h.connectorPadding || 0,\n                S = 0,\n                k = m,\n                C = "inherit";\n              if (f) {\n                if (d && p(g) && f.distance > 0 && (void 0 === g.pos ? C = "hidden" : (M = g.size, k = y.radialDistributionY(i, l))), h.justify) S = y.justify(i, l, c, n);else switch (h.alignTo) {\n                  case "connectors":\n                    S = y.alignToConnectors(e, a, s, r);\n                    break;\n                  case "plotEdges":\n                    S = y.alignToPlotEdges(l, a, s, r);\n                    break;\n                  default:\n                    S = y.radialDistributionX(t, i, k, m, l);\n                }\n                if (f.attribs = {\n                  visibility: C,\n                  align: f.alignment\n                }, f.posAttribs = {\n                  x: S + (h.x || 0) + ({\n                    left: b,\n                    right: -b\n                  }[f.alignment] || 0),\n                  y: k + (h.y || 0) - l.getBBox().height / 2\n                }, f.computed.x = S, f.computed.y = k, u(h.crop, !0)) {\n                  let t;\n                  S - (v = l.getBBox().width) < b && 1 === a ? (t = Math.round(v - S + b), x[3] = Math.max(t, x[3])) : S + v > s - b && 0 === a && (t = Math.round(S + v - s + b), x[1] = Math.max(t, x[1])), k - M / 2 < 0 ? x[0] = Math.max(Math.round(-k + M / 2), x[0]) : k + M / 2 > o && (x[2] = Math.max(Math.round(k + M / 2 - o), x[2])), f.sideOverflow = t;\n                }\n              }\n            });\n          }));\n        }), (0 === d(x) || this.verifyDataLabelOverflow(x)) && (this.placeDataLabels(), this.points.forEach(e => {\n          (e.dataLabels || []).forEach(s => {\n            let {\n                connectorColor: o,\n                connectorWidth: r = 1\n              } = s.options || {},\n              a = s.dataLabelPosition;\n            if (r) {\n              let n;\n              b = s.connector, a && a.distance > 0 ? (n = !b, b || (s.connector = b = i.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + e.colorIndex + (e.className ? " " + e.className : "")).add(t.dataLabelsGroup)), i.styledMode || b.attr({\n                "stroke-width": r,\n                stroke: o || e.color || "#666666"\n              }), b[n ? "attr" : "animate"]({\n                d: e.getConnectorPath(s)\n              }), b.attr({\n                visibility: a.attribs?.visibility\n              })) : b && (s.connector = b.destroy());\n            }\n          });\n        })));\n      }\n      function r() {\n        this.points.forEach(t => {\n          (t.dataLabels || []).forEach(t => {\n            let e = t.dataLabelPosition;\n            e ? (e.sideOverflow && (t.css({\n              width: Math.max(t.getBBox().width - e.sideOverflow, 0) + "px",\n              textOverflow: (t.options?.style || {}).textOverflow || "ellipsis"\n            }), t.shortened = !0), t.attr(e.attribs), t[t.moved ? "animate" : "attr"](e.posAttribs), t.moved = !0) : t && t.attr({\n              y: -9999\n            });\n          }), delete t.distributeBox;\n        }, this);\n      }\n      function m(t) {\n        let e = this.center,\n          i = this.options,\n          s = i.center,\n          o = i.minSize || 80,\n          r = o,\n          a = null !== i.size;\n        return !a && (null !== s[0] ? r = Math.max(e[2] - Math.max(t[1], t[3]), o) : (r = Math.max(e[2] - t[1] - t[3], o), e[0] += (t[3] - t[1]) / 2), null !== s[1] ? r = c(r, o, e[2] - Math.max(t[0], t[2])) : (r = c(r, o, e[2] - t[0] - t[2]), e[1] += (t[0] - t[2]) / 2), r < e[2] ? (e[2] = r, e[3] = Math.min(i.thickness ? Math.max(0, r - 2 * i.thickness) : Math.max(0, f(i.innerSize || 0, r)), r), this.translate(e), this.drawDataLabels && this.drawDataLabels()) : a = !0), a;\n      }\n      e.compose = function e(l) {\n        if (t.compose(h), g(a, e)) {\n          let t = l.prototype;\n          t.dataLabelPositioners = i, t.alignDataLabel = n, t.drawDataLabels = o, t.getDataLabelPosition = s, t.placeDataLabels = r, t.verifyDataLabelOverflow = m;\n        }\n      };\n    }(r || (r = {})), r;\n  }), i(e, "Extensions/OverlappingDataLabels.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e) {\n    let {\n        composed: i\n      } = t,\n      {\n        addEvent: s,\n        fireEvent: o,\n        isNumber: r,\n        objectEach: a,\n        pick: n,\n        pushUnique: l\n      } = e;\n    function h(t) {\n      let e = t.length,\n        i = this.renderer,\n        s = (t, e) => !(e.x >= t.x + t.width || e.x + e.width <= t.x || e.y >= t.y + t.height || e.y + e.height <= t.y),\n        a = t => {\n          let e = t.box ? 0 : t.padding || 0,\n            s,\n            o,\n            a,\n            n = 0,\n            l = 0,\n            h,\n            d;\n          if (t && (!t.alignAttr || t.placed)) return s = t.alignAttr || {\n            x: t.attr("x"),\n            y: t.attr("y")\n          }, o = t.parentGroup, t.width || (a = t.getBBox(), t.width = a.width, t.height = a.height, n = i.fontMetrics(t.element).h), h = t.width - 2 * e, (d = {\n            left: "0",\n            center: "0.5",\n            right: "1"\n          }[t.alignValue]) ? l = +d * h : r(t.x) && Math.round(t.x) !== t.translateX && (l = t.x - (t.translateX || 0)), {\n            x: s.x + (o.translateX || 0) + e - (l || 0),\n            y: s.y + (o.translateY || 0) + e - n,\n            width: t.width - 2 * e,\n            height: (t.height || 0) - 2 * e\n          };\n        },\n        n,\n        l,\n        h,\n        c,\n        p,\n        u = !1;\n      for (let i = 0; i < e; i++) (n = t[i]) && (n.oldOpacity = n.opacity, n.newOpacity = 1, n.absoluteBox = a(n));\n      t.sort((t, e) => (e.labelrank || 0) - (t.labelrank || 0));\n      for (let i = 0; i < e; ++i) {\n        c = (l = t[i]) && l.absoluteBox;\n        for (let o = i + 1; o < e; ++o) p = (h = t[o]) && h.absoluteBox, c && p && l !== h && 0 !== l.newOpacity && 0 !== h.newOpacity && "hidden" !== l.visibility && "hidden" !== h.visibility && s(c, p) && ((l.labelrank < h.labelrank ? l : h).newOpacity = 0);\n      }\n      for (let e of t) d(e, this) && (u = !0);\n      u && o(this, "afterHideAllOverlappingLabels");\n    }\n    function d(t, e) {\n      let i,\n        s = !1;\n      return t && (i = t.newOpacity, t.oldOpacity !== i && (t.hasClass("highcharts-data-label") ? (t[i ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), s = !0, t[t.isOld ? "animate" : "attr"]({\n        opacity: i\n      }, void 0, function () {\n        e.styledMode || t.css({\n          pointerEvents: i ? "auto" : "none"\n        });\n      }), o(e, "afterHideOverlappingLabel")) : t.attr({\n        opacity: i\n      })), t.isOld = !0), s;\n    }\n    function c() {\n      let t = this,\n        e = [];\n      for (let i of t.labelCollectors || []) e = e.concat(i());\n      for (let i of t.yAxis || []) i.stacking && i.options.stackLabels && !i.options.stackLabels.allowOverlap && a(i.stacking.stacks, t => {\n        a(t, t => {\n          t.label && e.push(t.label);\n        });\n      });\n      for (let i of t.series || []) if (i.visible && i.hasDataLabels?.()) {\n        let s = i => {\n          for (let s of i) s.visible && (s.dataLabels || []).forEach(i => {\n            let o = i.options || {};\n            i.labelrank = n(o.labelrank, s.labelrank, s.shapeArgs?.height), o.allowOverlap ?? Number(o.distance) > 0 ? (i.oldOpacity = i.opacity, i.newOpacity = 1, d(i, t)) : e.push(i);\n          });\n        };\n        s(i.nodes || []), s(i.points);\n      }\n      this.hideOverlappingLabels(e);\n    }\n    return {\n      compose: function t(e) {\n        if (l(i, t)) {\n          let t = e.prototype;\n          t.hideOverlappingLabels = h, s(e, "render", c);\n        }\n      }\n    };\n  }), i(e, "Extensions/BorderRadius.js", [e["Core/Defaults.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e, i) {\n    let {\n        defaultOptions: s\n      } = t,\n      {\n        composed: o,\n        noop: r\n      } = e,\n      {\n        addEvent: a,\n        extend: n,\n        isObject: l,\n        merge: h,\n        pushUnique: d,\n        relativeLength: c\n      } = i,\n      p = {\n        radius: 0,\n        scope: "stack",\n        where: void 0\n      },\n      u = r,\n      g = r;\n    function f(t, e, i, s, o = {}) {\n      let r = u(t, e, i, s, o),\n        {\n          innerR: a = 0,\n          r: n = i,\n          start: l = 0,\n          end: h = 0\n        } = o;\n      if (o.open || !o.borderRadius) return r;\n      let d = h - l,\n        p = Math.sin(d / 2),\n        g = Math.max(Math.min(c(o.borderRadius || 0, n - a), (n - a) / 2, n * p / (1 + p)), 0),\n        f = Math.min(g, 2 * (d / Math.PI) * a),\n        m = r.length - 1;\n      for (; m--;) !function (t, e, i) {\n        let s, o, r;\n        let a = t[e],\n          n = t[e + 1];\n        if ("Z" === n[0] && (n = t[0]), ("M" === a[0] || "L" === a[0]) && "A" === n[0] ? (s = a, o = n, r = !0) : "A" === a[0] && ("M" === n[0] || "L" === n[0]) && (s = n, o = a), s && o && o.params) {\n          let a = o[1],\n            n = o[5],\n            l = o.params,\n            {\n              start: h,\n              end: d,\n              cx: c,\n              cy: p\n            } = l,\n            u = n ? a - i : a + i,\n            g = u ? Math.asin(i / u) : 0,\n            f = n ? g : -g,\n            m = Math.cos(g) * u;\n          r ? (l.start = h + f, s[1] = c + m * Math.cos(h), s[2] = p + m * Math.sin(h), t.splice(e + 1, 0, ["A", i, i, 0, 0, 1, c + a * Math.cos(l.start), p + a * Math.sin(l.start)])) : (l.end = d - f, o[6] = c + a * Math.cos(l.end), o[7] = p + a * Math.sin(l.end), t.splice(e + 1, 0, ["A", i, i, 0, 0, 1, c + m * Math.cos(d), p + m * Math.sin(d)])), o[4] = Math.abs(l.end - l.start) < Math.PI ? 0 : 1;\n        }\n      }(r, m, m > 1 ? f : g);\n      return r;\n    }\n    function m() {\n      if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) {\n        let {\n            options: t,\n            yAxis: e\n          } = this,\n          i = "percent" === t.stacking,\n          o = s.plotOptions?.[this.type]?.borderRadius,\n          r = x(t.borderRadius, l(o) ? o : {}),\n          a = e.options.reversed;\n        for (let s of this.points) {\n          let {\n            shapeArgs: o\n          } = s;\n          if ("roundedRect" === s.shapeType && o) {\n            let {\n                width: l = 0,\n                height: h = 0,\n                y: d = 0\n              } = o,\n              p = d,\n              u = h;\n            if ("stack" === r.scope && s.stackTotal) {\n              let o = e.translate(i ? 100 : s.stackTotal, !1, !0, !1, !0),\n                r = e.translate(t.threshold || 0, !1, !0, !1, !0),\n                a = this.crispCol(0, Math.min(o, r), 0, Math.abs(o - r));\n              p = a.y, u = a.height;\n            }\n            let g = (s.negative ? -1 : 1) * (a ? -1 : 1) == -1,\n              f = r.where;\n            !f && this.is("waterfall") && Math.abs((s.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (f = "all"), f || (f = "end");\n            let m = Math.min(c(r.radius, l), l / 2, "all" === f ? h / 2 : 1 / 0) || 0;\n            "end" === f && (g && (p -= m), u += m), n(o, {\n              brBoxHeight: u,\n              brBoxY: p,\n              r: m\n            });\n          }\n        }\n      }\n    }\n    function x(t, e) {\n      return l(t) || (t = {\n        radius: t || 0\n      }), h(p, e, t);\n    }\n    function y() {\n      let t = x(this.options.borderRadius);\n      for (let e of this.points) {\n        let i = e.shapeArgs;\n        i && (i.borderRadius = c(t.radius, (i.r || 0) - (i.innerR || 0)));\n      }\n    }\n    function b(t, e, i, s, o = {}) {\n      let r = g(t, e, i, s, o),\n        {\n          r: a = 0,\n          brBoxHeight: n = s,\n          brBoxY: l = e\n        } = o,\n        h = e - l,\n        d = l + n - (e + s),\n        c = h - a > -.1 ? 0 : a,\n        p = d - a > -.1 ? 0 : a,\n        u = Math.max(c && h, 0),\n        f = Math.max(p && d, 0),\n        m = [t + c, e],\n        x = [t + i - c, e],\n        y = [t + i, e + c],\n        b = [t + i, e + s - p],\n        v = [t + i - p, e + s],\n        M = [t + p, e + s],\n        S = [t, e + s - p],\n        k = [t, e + c],\n        C = (t, e) => Math.sqrt(Math.pow(t, 2) - Math.pow(e, 2));\n      if (u) {\n        let t = C(c, c - u);\n        m[0] -= t, x[0] += t, y[1] = k[1] = e + c - u;\n      }\n      if (s < c - u) {\n        let o = C(c, c - u - s);\n        y[0] = b[0] = t + i - c + o, v[0] = Math.min(y[0], v[0]), M[0] = Math.max(b[0], M[0]), S[0] = k[0] = t + c - o, y[1] = k[1] = e + s;\n      }\n      if (f) {\n        let t = C(p, p - f);\n        v[0] += t, M[0] -= t, b[1] = S[1] = e + s - p + f;\n      }\n      if (s < p - f) {\n        let o = C(p, p - f - s);\n        y[0] = b[0] = t + i - p + o, x[0] = Math.min(y[0], x[0]), m[0] = Math.max(b[0], m[0]), S[0] = k[0] = t + p - o, b[1] = S[1] = e;\n      }\n      return r.length = 0, r.push(["M", ...m], ["L", ...x], ["A", c, c, 0, 0, 1, ...y], ["L", ...b], ["A", p, p, 0, 0, 1, ...v], ["L", ...M], ["A", p, p, 0, 0, 1, ...S], ["L", ...k], ["A", c, c, 0, 0, 1, ...m], ["Z"]), r;\n    }\n    return {\n      compose: function t(e, i, s, r) {\n        if (d(o, t)) {\n          let t = r.prototype.symbols;\n          a(e, "afterColumnTranslate", m, {\n            order: 9\n          }), a(i, "afterTranslate", y), s.symbolCustomAttribs.push("borderRadius", "brBoxHeight", "brBoxY"), u = t.arc, g = t.roundedRect, t.arc = f, t.roundedRect = b;\n        }\n      },\n      optionsToObject: x\n    };\n  }), i(e, "Core/Responsive.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e) {\n    var i;\n    let {\n        composed: s\n      } = t,\n      {\n        diffObjects: o,\n        extend: r,\n        find: a,\n        merge: n,\n        pick: l,\n        pushUnique: h,\n        uniqueKey: d\n      } = e;\n    return function (t) {\n      function e(t, e) {\n        let i = t.condition,\n          s = i.callback || function () {\n            return this.chartWidth <= l(i.maxWidth, Number.MAX_VALUE) && this.chartHeight <= l(i.maxHeight, Number.MAX_VALUE) && this.chartWidth >= l(i.minWidth, 0) && this.chartHeight >= l(i.minHeight, 0);\n          };\n        s.call(this) && e.push(t._id);\n      }\n      function i(t, e) {\n        let i = this.options.responsive,\n          s = this.currentResponsive,\n          r = [],\n          l;\n        !e && i && i.rules && i.rules.forEach(t => {\n          void 0 === t._id && (t._id = d()), this.matchResponsiveRule(t, r);\n        }, this);\n        let h = n(...r.map(t => a((i || {}).rules || [], e => e._id === t)).map(t => t && t.chartOptions));\n        h.isResponsiveOptions = !0, r = r.toString() || void 0;\n        let c = s && s.ruleIds;\n        r !== c && (s && this.update(s.undoOptions, t, !0), r ? ((l = o(h, this.options, !0, this.collectionsWithUpdate)).isResponsiveOptions = !0, this.currentResponsive = {\n          ruleIds: r,\n          mergedOptions: h,\n          undoOptions: l\n        }, this.update(h, t, !0)) : this.currentResponsive = void 0);\n      }\n      t.compose = function t(o) {\n        return h(s, t) && r(o.prototype, {\n          matchResponsiveRule: e,\n          setResponsive: i\n        }), o;\n      };\n    }(i || (i = {})), i;\n  }), i(e, "masters/highcharts.src.js", [e["Core/Globals.js"], e["Core/Utilities.js"], e["Core/Defaults.js"], e["Core/Animation/Fx.js"], e["Core/Animation/AnimationUtilities.js"], e["Core/Renderer/HTML/AST.js"], e["Core/Templating.js"], e["Core/Renderer/RendererUtilities.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Renderer/SVG/SVGRenderer.js"], e["Core/Renderer/HTML/HTMLElement.js"], e["Core/Renderer/HTML/HTMLRenderer.js"], e["Core/Axis/Axis.js"], e["Core/Axis/DateTimeAxis.js"], e["Core/Axis/LogarithmicAxis.js"], e["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], e["Core/Axis/Tick.js"], e["Core/Tooltip.js"], e["Core/Series/Point.js"], e["Core/Pointer.js"], e["Core/Legend/Legend.js"], e["Core/Chart/Chart.js"], e["Extensions/ScrollablePlotArea.js"], e["Core/Axis/Stacking/StackingAxis.js"], e["Core/Axis/Stacking/StackItem.js"], e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Series/Column/ColumnSeries.js"], e["Series/Column/ColumnDataLabel.js"], e["Series/Pie/PieSeries.js"], e["Series/Pie/PieDataLabel.js"], e["Core/Series/DataLabel.js"], e["Extensions/OverlappingDataLabels.js"], e["Extensions/BorderRadius.js"], e["Core/Responsive.js"], e["Core/Color/Color.js"], e["Core/Time.js"]], function (t, e, i, s, o, r, a, n, l, h, d, c, p, u, g, f, m, x, y, b, v, M, S, k, C, A, w, T, P, L, D, O, E, B, j, I, R) {\n    return t.animate = o.animate, t.animObject = o.animObject, t.getDeferredAnimation = o.getDeferredAnimation, t.setAnimation = o.setAnimation, t.stop = o.stop, t.timers = s.timers, t.AST = r, t.Axis = p, t.Chart = M, t.chart = M.chart, t.Fx = s, t.Legend = v, t.PlotLineOrBand = f, t.Point = y, t.Pointer = b, t.Series = A, t.StackItem = C, t.SVGElement = l, t.SVGRenderer = h, t.Templating = a, t.Tick = m, t.Time = R, t.Tooltip = x, t.Color = I, t.color = I.parse, c.compose(h), d.compose(l), b.compose(M), v.compose(M), t.defaultOptions = i.defaultOptions, t.getOptions = i.getOptions, t.time = i.defaultTime, t.setOptions = i.setOptions, t.dateFormat = a.dateFormat, t.format = a.format, t.numberFormat = a.numberFormat, e.extend(t, e), t.distribute = n.distribute, t.seriesType = w.seriesType, P.compose(T), B.compose(A, L, l, h), O.compose(A), u.compose(p), g.compose(p), E.compose(M), D.compose(L), f.compose(p), j.compose(M), S.compose(p, M, A), k.compose(p, M, A), x.compose(b), t;\n  }), i(e, "Core/Axis/BrokenAxis.js", [e["Core/Globals.js"], e["Core/Axis/Stacking/StackItem.js"], e["Core/Utilities.js"]], function (t, e, i) {\n    var s;\n    let {\n        composed: o\n      } = t,\n      {\n        addEvent: r,\n        find: a,\n        fireEvent: n,\n        isArray: l,\n        isNumber: h,\n        pick: d,\n        pushUnique: c\n      } = i;\n    return function (t) {\n      function i() {\n        void 0 !== this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, !1);\n      }\n      function s() {\n        this.brokenAxis?.hasBreaks && (this.options.ordinal = !1);\n      }\n      function p() {\n        let t = this.brokenAxis;\n        if (t?.hasBreaks) {\n          let e = this.tickPositions,\n            i = this.tickPositions.info,\n            s = [];\n          for (let i = 0; i < e.length; i++) t.isInAnyBreak(e[i]) || s.push(e[i]);\n          this.tickPositions = s, this.tickPositions.info = i;\n        }\n      }\n      function u() {\n        this.brokenAxis || (this.brokenAxis = new y(this));\n      }\n      function g() {\n        let {\n          isDirty: t,\n          options: {\n            connectNulls: e\n          },\n          points: i,\n          xAxis: s,\n          yAxis: o\n        } = this;\n        if (t) {\n          let t = i.length;\n          for (; t--;) {\n            let r = i[t],\n              a = null === r.y && !1 === e,\n              n = !a && (s?.brokenAxis?.isInAnyBreak(r.x, !0) || o?.brokenAxis?.isInAnyBreak(r.y, !0));\n            r.visible = !n && !1 !== r.options.visible;\n          }\n        }\n      }\n      function f() {\n        this.drawBreaks(this.xAxis, ["x"]), this.drawBreaks(this.yAxis, d(this.pointArrayMap, ["y"]));\n      }\n      function m(t, e) {\n        let i, s, o;\n        let r = this,\n          a = r.points;\n        if (t?.brokenAxis?.hasBreaks) {\n          let l = t.brokenAxis;\n          e.forEach(function (e) {\n            i = l?.breakArray || [], s = t.isXAxis ? t.min : d(r.options.threshold, t.min);\n            let c = t?.options?.breaks?.filter(function (t) {\n              let e = !0;\n              for (let s = 0; s < i.length; s++) {\n                let o = i[s];\n                if (o.from === t.from && o.to === t.to) {\n                  e = !1;\n                  break;\n                }\n              }\n              return e;\n            });\n            a.forEach(function (r) {\n              o = d(r["stack" + e.toUpperCase()], r[e]), i.forEach(function (e) {\n                if (h(s) && h(o)) {\n                  let i = "";\n                  s < e.from && o > e.to || s > e.from && o < e.from ? i = "pointBreak" : (s < e.from && o > e.from && o < e.to || s > e.from && o > e.to && o < e.from) && (i = "pointInBreak"), i && n(t, i, {\n                    point: r,\n                    brk: e\n                  });\n                }\n              }), c?.forEach(function (e) {\n                n(t, "pointOutsideOfBreak", {\n                  point: r,\n                  brk: e\n                });\n              });\n            });\n          });\n        }\n      }\n      function x() {\n        let t = this.currentDataGrouping,\n          i = t?.gapSize,\n          s = this.points.slice(),\n          o = this.yAxis,\n          r = this.options.gapSize,\n          a = s.length - 1;\n        if (r && a > 0) {\n          let t, n;\n          for ("value" !== this.options.gapUnit && (r *= this.basePointRange), i && i > r && i >= this.basePointRange && (r = i); a--;) if (n && !1 !== n.visible || (n = s[a + 1]), t = s[a], !1 !== n.visible && !1 !== t.visible) {\n            if (n.x - t.x > r) {\n              let i = (t.x + n.x) / 2;\n              s.splice(a + 1, 0, {\n                isNull: !0,\n                x: i\n              }), o.stacking && this.options.stacking && ((o.stacking.stacks[this.stackKey][i] = new e(o, o.options.stackLabels, !1, i, this.stack)).total = 0);\n            }\n            n = t;\n          }\n        }\n        return this.getGraphPath(s);\n      }\n      t.compose = function t(e, a) {\n        if (c(o, t)) {\n          e.keepProps.push("brokenAxis"), r(e, "init", u), r(e, "afterInit", i), r(e, "afterSetTickPositions", p), r(e, "afterSetOptions", s);\n          let t = a.prototype;\n          t.drawBreaks = m, t.gappedPath = x, r(a, "afterGeneratePoints", g), r(a, "afterRender", f);\n        }\n        return e;\n      };\n      class y {\n        static isInBreak(t, e) {\n          let i = t.repeat || 1 / 0,\n            s = t.from,\n            o = t.to - t.from,\n            r = e >= s ? (e - s) % i : i - (s - e) % i;\n          return t.inclusive ? r <= o : r < o && 0 !== r;\n        }\n        static lin2Val(t) {\n          let e = this.brokenAxis,\n            i = e && e.breakArray;\n          if (!i || !h(t)) return t;\n          let s = t,\n            o,\n            r;\n          for (r = 0; r < i.length && !((o = i[r]).from >= s); r++) o.to < s ? s += o.len : y.isInBreak(o, s) && (s += o.len);\n          return s;\n        }\n        static val2Lin(t) {\n          let e = this.brokenAxis,\n            i = e && e.breakArray;\n          if (!i || !h(t)) return t;\n          let s = t,\n            o,\n            r;\n          for (r = 0; r < i.length; r++) if ((o = i[r]).to <= t) s -= o.len;else if (o.from >= t) break;else if (y.isInBreak(o, t)) {\n            s -= t - o.from;\n            break;\n          }\n          return s;\n        }\n        constructor(t) {\n          this.hasBreaks = !1, this.axis = t;\n        }\n        findBreakAt(t, e) {\n          return a(e, function (e) {\n            return e.from < t && t < e.to;\n          });\n        }\n        isInAnyBreak(t, e) {\n          let i = this.axis,\n            s = i.options.breaks || [],\n            o = s.length,\n            r,\n            a,\n            n;\n          if (o && h(t)) {\n            for (; o--;) y.isInBreak(s[o], t) && (r = !0, a || (a = d(s[o].showPoints, !i.isXAxis)));\n            n = r && e ? r && !a : r;\n          }\n          return n;\n        }\n        setBreaks(t, e) {\n          let i = this,\n            s = i.axis,\n            o = l(t) && !!t.length && !!Object.keys(t[0]).length;\n          s.isDirty = i.hasBreaks !== o, i.hasBreaks = o, t !== s.options.breaks && (s.options.breaks = s.userOptions.breaks = t), s.forceRedraw = !0, s.series.forEach(function (t) {\n            t.isDirty = !0;\n          }), o || s.val2lin !== y.val2Lin || (delete s.val2lin, delete s.lin2val), o && (s.userOptions.ordinal = !1, s.lin2val = y.lin2Val, s.val2lin = y.val2Lin, s.setExtremes = function (t, e, o, r, a) {\n            if (i.hasBreaks) {\n              let s;\n              let o = this.options.breaks || [];\n              for (; s = i.findBreakAt(t, o);) t = s.to;\n              for (; s = i.findBreakAt(e, o);) e = s.from;\n              e < t && (e = t);\n            }\n            s.constructor.prototype.setExtremes.call(this, t, e, o, r, a);\n          }, s.setAxisTranslation = function () {\n            if (s.constructor.prototype.setAxisTranslation.call(this), i.unitLength = void 0, i.hasBreaks) {\n              let t = s.options.breaks || [],\n                e = [],\n                o = [],\n                r = d(s.pointRangePadding, 0),\n                a = 0,\n                l,\n                c,\n                p = s.userMin || s.min,\n                u = s.userMax || s.max,\n                g,\n                f;\n              t.forEach(function (t) {\n                c = t.repeat || 1 / 0, h(p) && h(u) && (y.isInBreak(t, p) && (p += t.to % c - p % c), y.isInBreak(t, u) && (u -= u % c - t.from % c));\n              }), t.forEach(function (t) {\n                if (g = t.from, c = t.repeat || 1 / 0, h(p) && h(u)) {\n                  for (; g - c > p;) g -= c;\n                  for (; g < p;) g += c;\n                  for (f = g; f < u; f += c) e.push({\n                    value: f,\n                    move: "in"\n                  }), e.push({\n                    value: f + t.to - t.from,\n                    move: "out",\n                    size: t.breakSize\n                  });\n                }\n              }), e.sort(function (t, e) {\n                return t.value === e.value ? ("in" === t.move ? 0 : 1) - ("in" === e.move ? 0 : 1) : t.value - e.value;\n              }), l = 0, g = p, e.forEach(function (t) {\n                1 === (l += "in" === t.move ? 1 : -1) && "in" === t.move && (g = t.value), 0 === l && h(g) && (o.push({\n                  from: g,\n                  to: t.value,\n                  len: t.value - g - (t.size || 0)\n                }), a += t.value - g - (t.size || 0));\n              }), i.breakArray = o, h(p) && h(u) && h(s.min) && (i.unitLength = u - p - a + r, n(s, "afterBreaks"), s.staticScale ? s.transA = s.staticScale : i.unitLength && (s.transA *= (u - s.min + r) / i.unitLength), r && (s.minPixelPadding = s.transA * (s.minPointOffset || 0)), s.min = p, s.max = u);\n            }\n          }), d(e, !0) && s.chart.redraw();\n        }\n      }\n      t.Additions = y;\n    }(s || (s = {})), s;\n  }), i(e, "masters/modules/broken-axis.src.js", [e["Core/Globals.js"], e["Core/Axis/BrokenAxis.js"]], function (t, e) {\n    e.compose(t.Axis, t.Series);\n  }), i(e, "Extensions/DataGrouping/ApproximationRegistry.js", [], function () {\n    return {};\n  }), i(e, "Extensions/DataGrouping/ApproximationDefaults.js", [e["Extensions/DataGrouping/ApproximationRegistry.js"], e["Core/Utilities.js"]], function (t, e) {\n    let {\n      arrayMax: i,\n      arrayMin: s,\n      correctFloat: o,\n      extend: r,\n      isNumber: a\n    } = e;\n    function n(t) {\n      let e = t.length,\n        i = l(t);\n      return a(i) && e && (i = o(i / e)), i;\n    }\n    function l(t) {\n      let e = t.length,\n        i;\n      if (!e && t.hasNulls) i = null;else if (e) for (i = 0; e--;) i += t[e];\n      return i;\n    }\n    let h = {\n      average: n,\n      averages: function () {\n        let t = [];\n        return [].forEach.call(arguments, function (e) {\n          t.push(n(e));\n        }), void 0 === t[0] ? void 0 : t;\n      },\n      close: function (t) {\n        return t.length ? t[t.length - 1] : t.hasNulls ? null : void 0;\n      },\n      high: function (t) {\n        return t.length ? i(t) : t.hasNulls ? null : void 0;\n      },\n      hlc: function (e, i, s) {\n        if (e = t.high(e), i = t.low(i), s = t.close(s), a(e) || a(i) || a(s)) return [e, i, s];\n      },\n      low: function (t) {\n        return t.length ? s(t) : t.hasNulls ? null : void 0;\n      },\n      ohlc: function (e, i, s, o) {\n        if (e = t.open(e), i = t.high(i), s = t.low(s), o = t.close(o), a(e) || a(i) || a(s) || a(o)) return [e, i, s, o];\n      },\n      open: function (t) {\n        return t.length ? t[0] : t.hasNulls ? null : void 0;\n      },\n      range: function (e, i) {\n        return (e = t.low(e), i = t.high(i), a(e) || a(i)) ? [e, i] : null === e && null === i ? null : void 0;\n      },\n      sum: l\n    };\n    return r(t, h), h;\n  }), i(e, "Extensions/DataGrouping/DataGroupingDefaults.js", [], function () {\n    return {\n      common: {\n        groupPixelWidth: 2,\n        dateTimeLabelFormats: {\n          millisecond: ["%A, %e %b, %H:%M:%S.%L", "%A, %e %b, %H:%M:%S.%L", "-%H:%M:%S.%L"],\n          second: ["%A, %e %b, %H:%M:%S", "%A, %e %b, %H:%M:%S", "-%H:%M:%S"],\n          minute: ["%A, %e %b, %H:%M", "%A, %e %b, %H:%M", "-%H:%M"],\n          hour: ["%A, %e %b, %H:%M", "%A, %e %b, %H:%M", "-%H:%M"],\n          day: ["%A, %e %b %Y", "%A, %e %b", "-%A, %e %b %Y"],\n          week: ["Week from %A, %e %b %Y", "%A, %e %b", "-%A, %e %b %Y"],\n          month: ["%B %Y", "%B", "-%B %Y"],\n          year: ["%Y", "%Y", "-%Y"]\n        }\n      },\n      seriesSpecific: {\n        line: {},\n        spline: {},\n        area: {},\n        areaspline: {},\n        arearange: {},\n        column: {\n          groupPixelWidth: 10\n        },\n        columnrange: {\n          groupPixelWidth: 10\n        },\n        candlestick: {\n          groupPixelWidth: 10\n        },\n        ohlc: {\n          groupPixelWidth: 5\n        },\n        hlc: {\n          groupPixelWidth: 5\n        },\n        heikinashi: {\n          groupPixelWidth: 10\n        }\n      },\n      units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1]], ["week", [1]], ["month", [1, 3, 6]], ["year", null]]\n    };\n  }), i(e, "Extensions/DataGrouping/DataGroupingAxisComposition.js", [e["Extensions/DataGrouping/DataGroupingDefaults.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e, i) {\n    let s;\n    let {\n        composed: o\n      } = e,\n      {\n        addEvent: r,\n        extend: a,\n        merge: n,\n        pick: l,\n        pushUnique: h\n      } = i;\n    function d(t) {\n      let e = this,\n        i = e.series;\n      i.forEach(function (t) {\n        t.groupPixelWidth = void 0;\n      }), i.forEach(function (i) {\n        i.groupPixelWidth = e.getGroupPixelWidth && e.getGroupPixelWidth(), i.groupPixelWidth && (i.hasProcessed = !0), i.applyGrouping(!!t.hasExtremesChanged);\n      });\n    }\n    function c() {\n      let e = this.series,\n        i = e.length,\n        s = 0,\n        o = !1,\n        r,\n        a;\n      for (; i--;) (a = e[i].options.dataGrouping) && (s = Math.max(s, l(a.groupPixelWidth, t.common.groupPixelWidth)), r = (e[i].processedXData || e[i].data).length, (e[i].groupPixelWidth || r > this.chart.plotSizeX / s || r && a.forced) && (o = !0));\n      return o ? s : 0;\n    }\n    function p() {\n      this.series.forEach(function (t) {\n        t.hasProcessed = !1;\n      });\n    }\n    function u(t, e) {\n      let i;\n      if (e = l(e, !0), t || (t = {\n        forced: !1,\n        units: null\n      }), this instanceof s) for (i = this.series.length; i--;) this.series[i].update({\n        dataGrouping: t\n      }, !1);else this.chart.options.series.forEach(function (e) {\n        e.dataGrouping = "boolean" == typeof t ? t : n(t, e.dataGrouping);\n      });\n      this.ordinal && (this.ordinal.slope = void 0), e && this.chart.redraw();\n    }\n    return {\n      compose: function t(e) {\n        s = e, h(o, t) && (r(e, "afterSetScale", p), r(e, "postProcessData", d), a(e.prototype, {\n          applyGrouping: d,\n          getGroupPixelWidth: c,\n          setDataGrouping: u\n        }));\n      }\n    };\n  }), i(e, "Extensions/DataGrouping/DataGroupingSeriesComposition.js", [e["Extensions/DataGrouping/ApproximationRegistry.js"], e["Extensions/DataGrouping/DataGroupingDefaults.js"], e["Core/Axis/DateTimeAxis.js"], e["Core/Defaults.js"], e["Core/Globals.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, r, a) {\n    let {\n        composed: n\n      } = o,\n      {\n        series: {\n          prototype: l\n        }\n      } = r,\n      {\n        addEvent: h,\n        defined: d,\n        error: c,\n        extend: p,\n        isNumber: u,\n        merge: g,\n        pick: f,\n        pushUnique: m\n      } = a,\n      x = l.generatePoints;\n    function y(t) {\n      var s;\n      let o, r;\n      let a = this.chart,\n        n = this.options,\n        h = n.dataGrouping,\n        p = !1 !== this.allowDG && h && f(h.enabled, a.options.isStock),\n        g = this.reserveSpace(),\n        m = this.currentDataGrouping,\n        x,\n        y,\n        b = !1;\n      p && !this.requireSorting && (this.requireSorting = b = !0);\n      let v = !1 == !(this.isCartesian && !this.isDirty && !this.xAxis.isDirty && !this.yAxis.isDirty && !t) || !p;\n      if (b && (this.requireSorting = !1), v) return;\n      this.destroyGroupedData();\n      let M = h.groupAll ? this.xData : this.processedXData,\n        S = h.groupAll ? this.yData : this.processedYData,\n        k = a.plotSizeX,\n        C = this.xAxis,\n        A = C.options.ordinal,\n        w = this.groupPixelWidth;\n      if (w && M && M.length && k) {\n        r = !0, this.isDirty = !0, this.points = null;\n        let t = C.getExtremes(),\n          n = t.min,\n          p = t.max,\n          f = A && C.ordinal && C.ordinal.getGroupIntervalFactor(n, p, this) || 1,\n          m = w * (p - n) / k * f,\n          b = C.getTimeTicks(i.Additions.prototype.normalizeTimeTickInterval(m, h.units || e.units), Math.min(n, M[0]), Math.max(p, M[M.length - 1]), C.options.startOfWeek, M, this.closestPointRange),\n          v = l.groupData.apply(this, [M, S, b, h.approximation]),\n          T = v.groupedXData,\n          P = v.groupedYData,\n          L = 0;\n        for (h && h.smoothed && T.length && (h.firstAnchor = "firstPoint", h.anchor = "middle", h.lastAnchor = "lastPoint", c(32, !1, a, {\n          "dataGrouping.smoothed": "use dataGrouping.anchor"\n        })), o = 1; o < b.length; o++) b.info.segmentStarts && -1 !== b.info.segmentStarts.indexOf(o) || (L = Math.max(b[o] - b[o - 1], L));\n        (x = b.info).gapSize = L, this.closestPointRange = b.info.totalRange, this.groupMap = v.groupMap, this.currentDataGrouping = x, function (t, e, i) {\n          let s = t.options,\n            o = s.dataGrouping,\n            r = t.currentDataGrouping && t.currentDataGrouping.gapSize;\n          if (!(o && t.xData && r && t.groupMap)) return;\n          let a = e.length - 1,\n            n = o.anchor,\n            l = o.firstAnchor,\n            h = o.lastAnchor,\n            d = e.length - 1,\n            c = 0;\n          if (l && t.xData[0] >= e[0]) {\n            let i;\n            c++;\n            let s = t.groupMap[0].start,\n              o = t.groupMap[0].length;\n            u(s) && u(o) && (i = s + (o - 1)), e[0] = {\n              start: e[0],\n              middle: e[0] + .5 * r,\n              end: e[0] + r,\n              firstPoint: t.xData[0],\n              lastPoint: i && t.xData[i]\n            }[l];\n          }\n          if (a > 0 && h && r && e[a] >= i - r) {\n            d--;\n            let i = t.groupMap[t.groupMap.length - 1].start;\n            e[a] = {\n              start: e[a],\n              middle: e[a] + .5 * r,\n              end: e[a] + r,\n              firstPoint: i && t.xData[i],\n              lastPoint: t.xData[t.xData.length - 1]\n            }[h];\n          }\n          if (n && "start" !== n) {\n            let t = r * {\n              middle: .5,\n              end: 1\n            }[n];\n            for (; d >= c;) e[d] += t, d--;\n          }\n        }(this, T, p), g && (d((s = T)[0]) && u(C.min) && u(C.dataMin) && s[0] < C.min && ((!d(C.options.min) && C.min <= C.dataMin || C.min === C.dataMin) && (C.min = Math.min(s[0], C.min)), C.dataMin = Math.min(s[0], C.dataMin)), d(s[s.length - 1]) && u(C.max) && u(C.dataMax) && s[s.length - 1] > C.max && ((!d(C.options.max) && u(C.dataMax) && C.max >= C.dataMax || C.max === C.dataMax) && (C.max = Math.max(s[s.length - 1], C.max)), C.dataMax = Math.max(s[s.length - 1], C.dataMax))), h.groupAll && (this.allGroupedData = P, T = (y = this.cropData(T, P, C.min, C.max)).xData, P = y.yData, this.cropStart = y.start), this.processedXData = T, this.processedYData = P;\n      } else this.groupMap = null;\n      this.hasGroupedData = r, this.preventGraphAnimation = (m && m.totalRange) !== (x && x.totalRange);\n    }\n    function b() {\n      this.groupedData && (this.groupedData.forEach(function (t, e) {\n        t && (this.groupedData[e] = t.destroy ? t.destroy() : null);\n      }, this), this.groupedData.length = 0, delete this.allGroupedData);\n    }\n    function v() {\n      x.apply(this), this.destroyGroupedData(), this.groupedData = this.hasGroupedData ? this.points : null;\n    }\n    function M() {\n      return this.is("arearange") ? "range" : this.is("ohlc") ? "ohlc" : this.is("hlc") ? "hlc" : this.is("column") || this.options.cumulative ? "sum" : "average";\n    }\n    function S(e, i, s, o) {\n      let r = this,\n        a = r.data,\n        n = r.options && r.options.data,\n        l = [],\n        h = [],\n        c = [],\n        p = e.length,\n        f = !!i,\n        m = [],\n        x = r.pointArrayMap,\n        y = x && x.length,\n        b = ["x"].concat(x || ["y"]),\n        v = this.options.dataGrouping && this.options.dataGrouping.groupAll,\n        M,\n        S,\n        k,\n        C = 0,\n        A = 0,\n        w = "function" == typeof o ? o : o && t[o] ? t[o] : t[r.getDGApproximation && r.getDGApproximation() || "average"];\n      if (y) {\n        let t = x.length;\n        for (; t--;) m.push([]);\n      } else m.push([]);\n      let T = y || 1;\n      for (let t = 0; t <= p; t++) if (!(e[t] < s[0])) {\n        for (; void 0 !== s[C + 1] && e[t] >= s[C + 1] || t === p;) {\n          M = s[C], r.dataGroupInfo = {\n            start: v ? A : r.cropStart + A,\n            length: m[0].length,\n            groupStart: M\n          }, k = w.apply(r, m), r.pointClass && !d(r.dataGroupInfo.options) && (r.dataGroupInfo.options = g(r.pointClass.prototype.optionsToObject.call({\n            series: r\n          }, r.options.data[r.cropStart + A])), b.forEach(function (t) {\n            delete r.dataGroupInfo.options[t];\n          })), void 0 !== k && (l.push(M), h.push(k), c.push(r.dataGroupInfo)), A = t;\n          for (let t = 0; t < T; t++) m[t].length = 0, m[t].hasNulls = !1;\n          if (C += 1, t === p) break;\n        }\n        if (t === p) break;\n        if (x) {\n          let e;\n          let i = r.options.dataGrouping && r.options.dataGrouping.groupAll ? t : r.cropStart + t,\n            s = a && a[i] || r.pointClass.prototype.applyOptions.apply({\n              series: r\n            }, [n[i]]);\n          for (let t = 0; t < y; t++) u(e = s[x[t]]) ? m[t].push(e) : null === e && (m[t].hasNulls = !0);\n        } else u(S = f ? i[t] : null) ? m[0].push(S) : null === S && (m[0].hasNulls = !0);\n      }\n      return {\n        groupedXData: l,\n        groupedYData: h,\n        groupMap: c\n      };\n    }\n    function k(t) {\n      let i = t.options,\n        o = this.type,\n        r = this.chart.options.plotOptions,\n        a = this.useCommonDataGrouping && e.common,\n        n = e.seriesSpecific,\n        l = s.defaultOptions.plotOptions[o].dataGrouping;\n      if (r && (n[o] || a)) {\n        let t = this.chart.rangeSelector;\n        l || (l = g(e.common, n[o])), i.dataGrouping = g(a, l, r.series && r.series.dataGrouping, r[o].dataGrouping, this.userOptions.dataGrouping, !i.isInternal && t && u(t.selected) && t.buttonOptions[t.selected].dataGrouping);\n      }\n    }\n    return {\n      compose: function t(e) {\n        let i = e.prototype.pointClass;\n        m(n, t) && (h(i, "update", function () {\n          if (this.dataGroup) return c(24, !1, this.series.chart), !1;\n        }), h(e, "afterSetOptions", k), h(e, "destroy", b), p(e.prototype, {\n          applyGrouping: y,\n          destroyGroupedData: b,\n          generatePoints: v,\n          getDGApproximation: M,\n          groupData: S\n        }));\n      },\n      groupData: S\n    };\n  }), i(e, "Extensions/DataGrouping/DataGrouping.js", [e["Extensions/DataGrouping/DataGroupingAxisComposition.js"], e["Extensions/DataGrouping/DataGroupingDefaults.js"], e["Extensions/DataGrouping/DataGroupingSeriesComposition.js"], e["Core/Templating.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, r) {\n    let {\n        format: a\n      } = s,\n      {\n        composed: n\n      } = o,\n      {\n        addEvent: l,\n        extend: h,\n        isNumber: d,\n        pick: c,\n        pushUnique: p\n      } = r;\n    function u(t) {\n      let i = this.chart,\n        s = i.time,\n        o = t.labelConfig,\n        r = o.series,\n        n = o.point,\n        l = r.options,\n        p = r.tooltipOptions,\n        u = l.dataGrouping,\n        g = r.xAxis,\n        f = p.xDateFormat,\n        m,\n        x,\n        y,\n        b,\n        v,\n        M = p[t.isFooter ? "footerFormat" : "headerFormat"];\n      if (g && "datetime" === g.options.type && u && d(o.key)) {\n        x = r.currentDataGrouping, y = u.dateTimeLabelFormats || e.common.dateTimeLabelFormats, x ? (b = y[x.unitName], 1 === x.count ? f = b[0] : (f = b[1], m = b[2])) : !f && y && g.dateTime && (f = g.dateTime.getXDateFormat(o.x, p.dateTimeLabelFormats));\n        let l = c(r.groupMap?.[n.index].groupStart, o.key),\n          d = l + x?.totalRange - 1;\n        v = s.dateFormat(f, l), m && (v += s.dateFormat(m, d)), r.chart.styledMode && (M = this.styledModeFormat(M)), t.text = a(M, {\n          point: h(o.point, {\n            key: v\n          }),\n          series: r\n        }, i), t.preventDefault();\n      }\n    }\n    let g = {\n      compose: function e(s, o, r) {\n        t.compose(s), i.compose(o), r && p(n, e) && l(r, "headerFormatter", u);\n      },\n      groupData: i.groupData\n    };\n    return g;\n  }), i(e, "masters/modules/datagrouping.src.js", [e["Core/Globals.js"], e["Extensions/DataGrouping/ApproximationDefaults.js"], e["Extensions/DataGrouping/ApproximationRegistry.js"], e["Extensions/DataGrouping/DataGrouping.js"]], function (t, e, i, s) {\n    t.dataGrouping = {\n      approximationDefaults: e,\n      approximations: i\n    }, s.compose(t.Axis, t.Series, t.Tooltip);\n  }), i(e, "Extensions/Annotations/NavigationBindingsUtilities.js", [e["Core/Utilities.js"]], function (t) {\n    let {\n        defined: e,\n        isNumber: i,\n        pick: s\n      } = t,\n      o = {\n        backgroundColor: "string",\n        borderColor: "string",\n        borderRadius: "string",\n        color: "string",\n        fill: "string",\n        fontSize: "string",\n        labels: "string",\n        name: "string",\n        stroke: "string",\n        title: "string"\n      };\n    return {\n      annotationsFieldsTypes: o,\n      getAssignedAxis: function (t) {\n        return t.filter(t => {\n          let e = t.axis.getExtremes(),\n            o = e.min,\n            r = e.max,\n            a = s(t.axis.minPointOffset, 0);\n          return i(o) && i(r) && t.value >= o - a && t.value <= r + a && !t.axis.options.isInternal;\n        })[0];\n      },\n      getFieldType: function (t, i) {\n        let s = o[t],\n          r = typeof i;\n        return e(s) && (r = s), {\n          string: "text",\n          number: "number",\n          boolean: "checkbox"\n        }[r];\n      }\n    };\n  }), i(e, "Extensions/MouseWheelZoom/MouseWheelZoom.js", [e["Core/Utilities.js"], e["Extensions/Annotations/NavigationBindingsUtilities.js"]], function (t, e) {\n    let i, s, o;\n    let {\n        addEvent: r,\n        isObject: a,\n        pick: n,\n        defined: l,\n        merge: h,\n        isNumber: d\n      } = t,\n      {\n        getAssignedAxis: c\n      } = e,\n      p = [],\n      u = {\n        enabled: !0,\n        sensitivity: 1.1\n      },\n      g = t => a(t) ? h(u, t) : h(u, {\n        enabled: !l(t) || t\n      }),\n      f = (t, e, i, s) => (i + s > t + e && (s > e ? (s = e, i = t) : i = t + e - s), s > e && (s = e), i < t && (i = t), {\n        rangeStart: i,\n        rangeWidth: s\n      }),\n      m = function (t) {\n        let e = t.options;\n        l(i) && clearTimeout(i), l(s) || (s = e.startOnTick, o = e.endOnTick), (s || o) && (e.startOnTick = !1, e.endOnTick = !1), i = setTimeout(() => {\n          if (l(s) && l(o)) {\n            e.startOnTick = s, e.endOnTick = o;\n            let {\n              min: i,\n              max: r\n            } = t.getExtremes();\n            t.forceRedraw = !0, t.setExtremes(i, r), s = o = void 0;\n          }\n        }, 400);\n      },\n      x = function (t, e, i) {\n        if (!l(i)) return .5;\n        let s = (i - e.minPixelPadding - e.pos) / (e.len - 2 * e.minPixelPadding),\n          o = e.isXAxis;\n        return o && !e.reversed != !t.inverted || !o && e.reversed ? 1 - s : s;\n      },\n      y = function (t, e, i, s, o) {\n        let r = e.isXAxis,\n          a = !1;\n        if (l(e.max) && l(e.min) && l(e.dataMax) && l(e.dataMin)) {\n          r || m(e);\n          let h = e.max - e.min,\n            c = d(o) ? o : e.min + h / 2,\n            p = x(t, e, i),\n            u = h * s,\n            g = c - u * p,\n            y = n(e.options.max, e.dataMax) - n(e.options.min, e.dataMin),\n            b = e.options.min ? 0 : y * e.options.minPadding,\n            v = e.options.max ? 0 : y * e.options.maxPadding,\n            M = n(e.options.min, e.dataMin) - b,\n            S = y + v + b,\n            k = f(M, S, g, u),\n            C = k.rangeStart < n(e.options.min, M) || k.rangeStart === e.min && k.rangeWidth > S && k.rangeStart + k.rangeWidth < n(e.options.max, Number.MIN_VALUE) || k.rangeWidth === e.max - e.min;\n          l(s) && !C ? (e.setExtremes(k.rangeStart, k.rangeStart + k.rangeWidth, !1), a = !0) : e.setExtremes(void 0, void 0, !1);\n        }\n        return a;\n      },\n      b = function (t, e, i, s, o, r, a) {\n        let l = n(a.type, t.zooming.type, ""),\n          h = /x/.test(l),\n          d = /y/.test(l),\n          c = i.toValue(o),\n          p = s.toValue(r);\n        if (t.inverted) {\n          let t = s.pos + s.len;\n          c = i.toValue(r), p = s.toValue(o);\n          let e = o;\n          o = r, r = t - e + s.pos;\n        }\n        let u = h && y(t, i, o, e, c),\n          g = d && y(t, s, r, e, p),\n          f = u || g;\n        return f && t.redraw(!1), f;\n      };\n    function v() {\n      let t = this,\n        e = g(t.zooming.mouseWheel);\n      e.enabled && r(this.container, "wheel", i => {\n        i = this.pointer.normalize(i);\n        let s = !t.pointer.inClass(i.target, "highcharts-no-mousewheel");\n        if (t.isInsidePlot(i.chartX - t.plotLeft, i.chartY - t.plotTop) && s) {\n          let s = e.sensitivity || 1.1,\n            o = i.detail || (i.deltaY || 0) / 120,\n            r = c(this.pointer.getCoordinates(i).xAxis),\n            a = c(this.pointer.getCoordinates(i).yAxis),\n            n = b(t, Math.pow(s, o), r ? r.axis : t.xAxis[0], a ? a.axis : t.yAxis[0], i.chartX, i.chartY, e);\n          n && i.preventDefault && i.preventDefault();\n        }\n      });\n    }\n    return {\n      compose: function (t) {\n        -1 === p.indexOf(t) && (p.push(t), r(t, "afterGetContainer", v));\n      }\n    };\n  }), i(e, "masters/modules/mouse-wheel-zoom.src.js", [e["Core/Globals.js"], e["Extensions/MouseWheelZoom/MouseWheelZoom.js"]], function (t, e) {\n    e.compose(t.Chart);\n  }), i(e, "Series/DataModifyComposition.js", [e["Core/Axis/Axis.js"], e["Core/Globals.js"], e["Core/Series/Point.js"], e["Core/Series/Series.js"], e["Core/Utilities.js"]], function (t, e, i, s, o) {\n    var r;\n    let {\n        composed: a\n      } = e,\n      {\n        tooltipFormatter: n\n      } = i.prototype,\n      {\n        addEvent: l,\n        arrayMax: h,\n        arrayMin: d,\n        correctFloat: c,\n        defined: p,\n        isArray: u,\n        isNumber: g,\n        isString: f,\n        pick: m,\n        pushUnique: x\n      } = o;\n    return function (t) {\n      function e(t, e, i) {\n        !this.isXAxis && (this.series.forEach(function (i) {\n          "compare" === t && "boolean" != typeof e ? i.setCompare(e, !1) : "cumulative" !== t || f(e) || i.setCumulative(e, !1);\n        }), m(i, !0) && this.chart.redraw());\n      }\n      function i(t) {\n        let e = this,\n          {\n            numberFormatter: i\n          } = e.series.chart,\n          s = function (s) {\n            t = t.replace("{point." + s + "}", (e[s] > 0 && "change" === s ? "+" : "") + i(e[s], m(e.series.tooltipOptions.changeDecimals, 2)));\n          };\n        return p(e.change) && s("change"), p(e.cumulativeSum) && s("cumulativeSum"), n.apply(this, [t]);\n      }\n      function s() {\n        let t;\n        let e = this.options.compare;\n        ("percent" === e || "value" === e || this.options.cumulative) && (t = new S(this), "percent" === e || "value" === e ? t.initCompare(e) : t.initCumulative()), this.dataModify = t;\n      }\n      function o(t) {\n        let e = t.dataExtremes,\n          i = e.activeYData;\n        if (this.dataModify && e) {\n          let t;\n          this.options.compare ? t = [this.dataModify.modifyValue(e.dataMin), this.dataModify.modifyValue(e.dataMax)] : this.options.cumulative && u(i) && i.length >= 2 && (t = S.getCumulativeExtremes(i)), t && (e.dataMin = d(t), e.dataMax = h(t));\n        }\n      }\n      function r(t, e) {\n        this.options.compare = this.userOptions.compare = t, this.update({}, m(e, !0)), this.dataModify && ("value" === t || "percent" === t) ? this.dataModify.initCompare(t) : this.points.forEach(t => {\n          delete t.change;\n        });\n      }\n      function y() {\n        if (this.xAxis && this.processedYData && this.dataModify) {\n          let t = this.processedXData,\n            e = this.processedYData,\n            i = e.length,\n            s = !0 === this.options.compareStart ? 0 : 1,\n            o = -1,\n            r;\n          for (this.pointArrayMap && (o = this.pointArrayMap.indexOf(this.options.pointValKey || this.pointValKey || "y")), r = 0; r < i - s; r++) {\n            let i = e[r] && o > -1 ? e[r][o] : e[r];\n            if (g(i) && 0 !== i && t[r + s] >= (this.xAxis.min || 0)) {\n              this.dataModify.compareValue = i;\n              break;\n            }\n          }\n        }\n      }\n      function b(t, e) {\n        this.setModifier("compare", t, e);\n      }\n      function v(t, e) {\n        t = m(t, !1), this.options.cumulative = this.userOptions.cumulative = t, this.update({}, m(e, !0)), this.dataModify ? this.dataModify.initCumulative() : this.points.forEach(t => {\n          delete t.cumulativeSum;\n        });\n      }\n      function M(t, e) {\n        this.setModifier("cumulative", t, e);\n      }\n      t.compose = function t(n, h, d) {\n        if (x(a, t)) {\n          let t = h.prototype,\n            a = d.prototype,\n            c = n.prototype;\n          c.setCompare = r, c.setCumulative = v, l(n, "afterInit", s), l(n, "afterGetExtremes", o), l(n, "afterProcessData", y), t.setCompare = b, t.setModifier = e, t.setCumulative = M, a.tooltipFormatter = i;\n        }\n        return n;\n      };\n      class S {\n        constructor(t) {\n          this.series = t;\n        }\n        modifyValue() {\n          return 0;\n        }\n        static getCumulativeExtremes(t) {\n          let e = 1 / 0,\n            i = -1 / 0;\n          return t.reduce((t, s) => {\n            let o = t + s;\n            return e = Math.min(e, o, t), i = Math.max(i, o, t), o;\n          }), [e, i];\n        }\n        initCompare(t) {\n          this.modifyValue = function (e, i) {\n            null === e && (e = 0);\n            let s = this.compareValue;\n            if (void 0 !== e && void 0 !== s) {\n              if ("value" === t) e -= s;else {\n                let t = this.series.options.compareBase;\n                e = 100 * (e / s) - (100 === t ? 0 : 100);\n              }\n              if (void 0 !== i) {\n                let t = this.series.points[i];\n                t && (t.change = e);\n              }\n              return e;\n            }\n            return 0;\n          };\n        }\n        initCumulative() {\n          this.modifyValue = function (t, e) {\n            if (null === t && (t = 0), void 0 !== t && void 0 !== e) {\n              let i = e > 0 ? this.series.points[e - 1] : null;\n              i && i.cumulativeSum && (t = c(i.cumulativeSum + t));\n              let s = this.series.points[e];\n              return s && (s.cumulativeSum = t), t;\n            }\n            return 0;\n          };\n        }\n      }\n      t.Additions = S;\n    }(r || (r = {})), r;\n  }), i(e, "Core/Axis/NavigatorAxisComposition.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e) {\n    let {\n        composed: i,\n        isTouchDevice: s\n      } = t,\n      {\n        addEvent: o,\n        correctFloat: r,\n        defined: a,\n        isNumber: n,\n        pick: l,\n        pushUnique: h\n      } = e;\n    function d() {\n      this.navigatorAxis || (this.navigatorAxis = new p(this));\n    }\n    function c(t) {\n      let e = this.chart,\n        i = e.options,\n        o = i.navigator,\n        r = this.navigatorAxis,\n        n = e.zooming.pinchType,\n        l = i.rangeSelector,\n        h = e.zooming.type;\n      if (this.isXAxis && (o && o.enabled || l && l.enabled)) {\n        if ("y" === h) t.zoomed = !1;else if ((!s && "xy" === h || s && "xy" === n) && this.options.range) {\n          let e = r.previousZoom;\n          a(t.newMin) ? r.previousZoom = [this.min, this.max] : e && (t.newMin = e[0], t.newMax = e[1], r.previousZoom = void 0);\n        }\n      }\n      void 0 !== t.zoomed && t.preventDefault();\n    }\n    class p {\n      static compose(t) {\n        h(i, this.compose) && (t.keepProps.push("navigatorAxis"), o(t, "init", d), o(t, "zoom", c));\n      }\n      constructor(t) {\n        this.axis = t;\n      }\n      destroy() {\n        this.axis = void 0;\n      }\n      toFixedRange(t, e, i, s) {\n        let o = this.axis,\n          h = o.chart,\n          d = l(i, o.translate(t, !0, !o.horiz)),\n          c = l(s, o.translate(e, !0, !o.horiz)),\n          p = h && h.fixedRange,\n          u = (o.pointRange || 0) / 2;\n        return a(i) || (d = r(d + u)), a(s) || (c = r(c - u)), p && o.dataMin && o.dataMax && (c >= o.dataMax && (d = r(o.dataMax - p)), d <= o.dataMin && (c = r(o.dataMin + p))), n(d) && n(c) || (d = c = void 0), {\n          min: d,\n          max: c\n        };\n      }\n    }\n    return p;\n  }), i(e, "Stock/Navigator/NavigatorDefaults.js", [e["Core/Color/Color.js"], e["Core/Series/SeriesRegistry.js"]], function (t, e) {\n    let {\n        parse: i\n      } = t,\n      {\n        seriesTypes: s\n      } = e,\n      o = {\n        height: 40,\n        margin: 25,\n        maskInside: !0,\n        handles: {\n          width: 7,\n          height: 15,\n          symbols: ["navigator-handle", "navigator-handle"],\n          enabled: !0,\n          lineWidth: 1,\n          backgroundColor: "#f2f2f2",\n          borderColor: "#999999"\n        },\n        maskFill: i("#667aff").setOpacity(.3).get(),\n        outlineColor: "#999999",\n        outlineWidth: 1,\n        series: {\n          type: void 0 === s.areaspline ? "line" : "areaspline",\n          fillOpacity: .05,\n          lineWidth: 1,\n          compare: null,\n          sonification: {\n            enabled: !1\n          },\n          dataGrouping: {\n            approximation: "average",\n            enabled: !0,\n            groupPixelWidth: 2,\n            firstAnchor: "firstPoint",\n            anchor: "middle",\n            lastAnchor: "lastPoint",\n            units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2, 3, 4]], ["week", [1, 2, 3]], ["month", [1, 3, 6]], ["year", null]]\n          },\n          dataLabels: {\n            enabled: !1,\n            zIndex: 2\n          },\n          id: "highcharts-navigator-series",\n          className: "highcharts-navigator-series",\n          lineColor: null,\n          marker: {\n            enabled: !1\n          },\n          threshold: null\n        },\n        xAxis: {\n          overscroll: 0,\n          className: "highcharts-navigator-xaxis",\n          tickLength: 0,\n          lineWidth: 0,\n          gridLineColor: "#e6e6e6",\n          gridLineWidth: 1,\n          tickPixelInterval: 200,\n          labels: {\n            align: "left",\n            style: {\n              color: "#000000",\n              fontSize: "0.7em",\n              opacity: .6,\n              textOutline: "2px contrast"\n            },\n            x: 3,\n            y: -4\n          },\n          crosshair: !1\n        },\n        yAxis: {\n          className: "highcharts-navigator-yaxis",\n          gridLineWidth: 0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: .1,\n          maxPadding: .1,\n          labels: {\n            enabled: !1\n          },\n          crosshair: !1,\n          title: {\n            text: null\n          },\n          tickLength: 0,\n          tickWidth: 0\n        }\n      };\n    return o;\n  }), i(e, "Stock/Navigator/NavigatorSymbols.js", [], function () {\n    return {\n      "navigator-handle": function (t, e, i, s, o = {}) {\n        let r = o.width ? o.width / 2 : i,\n          a = Math.round(r / 3) + .5;\n        return [["M", -r - 1, .5], ["L", r, .5], ["L", r, (s = o.height || s) + .5], ["L", -r - 1, s + .5], ["L", -r - 1, .5], ["M", -a, 4], ["L", -a, s - 3], ["M", a - 1, 4], ["L", a - 1, s - 3]];\n      }\n    };\n  }), i(e, "Stock/Navigator/NavigatorComposition.js", [e["Core/Defaults.js"], e["Core/Globals.js"], e["Core/Axis/NavigatorAxisComposition.js"], e["Stock/Navigator/NavigatorDefaults.js"], e["Stock/Navigator/NavigatorSymbols.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, r, a) {\n    let n;\n    let {\n        defaultOptions: l,\n        setOptions: h\n      } = t,\n      {\n        composed: d,\n        isTouchDevice: c\n      } = e,\n      {\n        getRendererType: p\n      } = r,\n      {\n        addEvent: u,\n        extend: g,\n        merge: f,\n        pick: m,\n        pushUnique: x\n      } = a;\n    function y() {\n      this.navigator && this.navigator.setBaseSeries(null, !1);\n    }\n    function b() {\n      let t, e, i;\n      let s = this.legend,\n        o = this.navigator;\n      if (o) {\n        t = s && s.options, e = o.xAxis, i = o.yAxis;\n        let {\n          scrollbarHeight: r,\n          scrollButtonSize: a\n        } = o;\n        this.inverted ? (o.left = o.opposite ? this.chartWidth - r - o.height : this.spacing[3] + r, o.top = this.plotTop + a) : (o.left = m(e.left, this.plotLeft + a), o.top = o.navigatorOptions.top || this.chartHeight - o.height - r - (this.scrollbar?.options.margin || 0) - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (t && "bottom" === t.verticalAlign && "proximate" !== t.layout && t.enabled && !t.floating ? s.legendHeight + m(t.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0)), e && i && (this.inverted ? e.options.left = i.options.left = o.left : e.options.top = i.options.top = o.top, e.setAxisSize(), i.setAxisSize());\n      }\n    }\n    function v(t) {\n      !this.navigator && !this.scroller && (this.options.navigator.enabled || this.options.scrollbar.enabled) && (this.scroller = this.navigator = new n(this), m(t.redraw, !0) && this.redraw(t.animation));\n    }\n    function M() {\n      let t = this.options;\n      (t.navigator.enabled || t.scrollbar.enabled) && (this.scroller = this.navigator = new n(this));\n    }\n    function S() {\n      let t = this.options,\n        e = t.navigator,\n        i = t.rangeSelector;\n      if ((e && e.enabled || i && i.enabled) && (!c && "x" === this.zooming.type || c && "x" === this.zooming.pinchType)) return !1;\n    }\n    function k(t) {\n      let e = t.navigator;\n      if (e && t.xAxis[0]) {\n        let i = t.xAxis[0].getExtremes();\n        e.render(i.min, i.max);\n      }\n    }\n    function C(t) {\n      let e = t.options.navigator || {},\n        i = t.options.scrollbar || {};\n      !this.navigator && !this.scroller && (e.enabled || i.enabled) && (f(!0, this.options.navigator, e), f(!0, this.options.scrollbar, i), delete t.options.navigator, delete t.options.scrollbar);\n    }\n    function A() {\n      this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1);\n    }\n    return {\n      compose: function t(e, r, a, h) {\n        if (i.compose(e), n = a, x(d, t)) {\n          let t = r.prototype;\n          t.callbacks.push(k), u(r, "afterAddSeries", y), u(r, "afterSetChartSize", b), u(r, "afterUpdate", v), u(r, "beforeRender", M), u(r, "beforeShowResetZoom", S), u(r, "update", C), u(h, "afterUpdate", A), g(p().prototype.symbols, o), g(l, {\n            navigator: s\n          });\n        }\n      }\n    };\n  }), i(e, "Core/Axis/ScrollbarAxis.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e) {\n    var i;\n    let {\n        composed: s\n      } = t,\n      {\n        addEvent: o,\n        defined: r,\n        pick: a,\n        pushUnique: n\n      } = e;\n    return function (t) {\n      let e;\n      function i(t) {\n        let e = a(t.options && t.options.min, t.min),\n          i = a(t.options && t.options.max, t.max);\n        return {\n          axisMin: e,\n          axisMax: i,\n          scrollMin: r(t.dataMin) ? Math.min(e, t.min, t.dataMin, a(t.threshold, 1 / 0)) : e,\n          scrollMax: r(t.dataMax) ? Math.max(i, t.max, t.dataMax, a(t.threshold, -1 / 0)) : i\n        };\n      }\n      function l() {\n        let t = this.scrollbar,\n          e = t && !t.options.opposite,\n          i = this.horiz ? 2 : e ? 3 : 1;\n        t && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[i] += t.size + (t.options.margin || 0));\n      }\n      function h() {\n        let t = this;\n        t.options && t.options.scrollbar && t.options.scrollbar.enabled && (t.options.scrollbar.vertical = !t.horiz, t.options.startOnTick = t.options.endOnTick = !1, t.scrollbar = new e(t.chart.renderer, t.options.scrollbar, t.chart), o(t.scrollbar, "changed", function (e) {\n          let s, o;\n          let {\n              axisMin: a,\n              axisMax: n,\n              scrollMin: l,\n              scrollMax: h\n            } = i(t),\n            d = h - l;\n          if (r(a) && r(n)) {\n            if (t.horiz && !t.reversed || !t.horiz && t.reversed ? (s = l + d * this.to, o = l + d * this.from) : (s = l + d * (1 - this.from), o = l + d * (1 - this.to)), this.shouldUpdateExtremes(e.DOMType)) {\n              let i = "mousemove" !== e.DOMType && "touchmove" !== e.DOMType && void 0;\n              t.setExtremes(o, s, !0, i, e);\n            } else this.setRange(this.from, this.to);\n          }\n        }));\n      }\n      function d() {\n        let t, e, s;\n        let {\n            scrollMin: o,\n            scrollMax: a\n          } = i(this),\n          n = this.scrollbar,\n          l = this.axisTitleMargin + (this.titleOffset || 0),\n          h = this.chart.scrollbarsOffsets,\n          d = this.options.margin || 0;\n        if (n && h) {\n          if (this.horiz) this.opposite || (h[1] += l), n.position(this.left, this.top + this.height + 2 + h[1] - (this.opposite ? d : 0), this.width, this.height), this.opposite || (h[1] += d), t = 1;else {\n            let e;\n            this.opposite && (h[0] += l), e = n.options.opposite ? this.left + this.width + 2 + h[0] - (this.opposite ? 0 : d) : this.opposite ? 0 : d, n.position(e, this.top, this.width, this.height), this.opposite && (h[0] += d), t = 0;\n          }\n          h[t] += n.size + (n.options.margin || 0), isNaN(o) || isNaN(a) || !r(this.min) || !r(this.max) || this.min === this.max ? n.setRange(0, 1) : (e = (this.min - o) / (a - o), s = (this.max - o) / (a - o), this.horiz && !this.reversed || !this.horiz && this.reversed ? n.setRange(e, s) : n.setRange(1 - s, 1 - e));\n        }\n      }\n      t.compose = function t(i, r) {\n        n(s, t) && (e = r, o(i, "afterGetOffset", l), o(i, "afterInit", h), o(i, "afterRender", d));\n      };\n    }(i || (i = {})), i;\n  }), i(e, "Stock/Scrollbar/ScrollbarDefaults.js", [e["Core/Globals.js"]], function (t) {\n    let {\n      isTouchDevice: e\n    } = t;\n    return {\n      height: 10,\n      barBorderRadius: 5,\n      buttonBorderRadius: 0,\n      buttonsEnabled: !1,\n      liveRedraw: void 0,\n      margin: void 0,\n      minWidth: 6,\n      opposite: !0,\n      step: .2,\n      zIndex: 3,\n      barBackgroundColor: "#cccccc",\n      barBorderWidth: 0,\n      barBorderColor: "#cccccc",\n      buttonArrowColor: "#333333",\n      buttonBackgroundColor: "#e6e6e6",\n      buttonBorderColor: "#cccccc",\n      buttonBorderWidth: 1,\n      rifleColor: "none",\n      trackBackgroundColor: "rgba(255, 255, 255, 0.001)",\n      trackBorderColor: "#cccccc",\n      trackBorderRadius: 5,\n      trackBorderWidth: 1\n    };\n  }), i(e, "Stock/Scrollbar/Scrollbar.js", [e["Core/Defaults.js"], e["Core/Globals.js"], e["Core/Axis/ScrollbarAxis.js"], e["Stock/Scrollbar/ScrollbarDefaults.js"], e["Core/Utilities.js"]], function (t, e, i, s, o) {\n    let {\n        defaultOptions: r\n      } = t,\n      {\n        addEvent: a,\n        correctFloat: n,\n        defined: l,\n        destroyObjectProperties: h,\n        fireEvent: d,\n        merge: c,\n        pick: p,\n        removeEvent: u\n      } = o;\n    class g {\n      static compose(t) {\n        i.compose(t, g);\n      }\n      static swapXY(t, e) {\n        return e && t.forEach(t => {\n          let e;\n          let i = t.length;\n          for (let s = 0; s < i; s += 2) "number" == typeof (e = t[s + 1]) && (t[s + 1] = t[s + 2], t[s + 2] = e);\n        }), t;\n      }\n      constructor(t, e, i) {\n        this._events = [], this.chartX = 0, this.chartY = 0, this.from = 0, this.scrollbarButtons = [], this.scrollbarLeft = 0, this.scrollbarStrokeWidth = 1, this.scrollbarTop = 0, this.size = 0, this.to = 0, this.trackBorderWidth = 1, this.x = 0, this.y = 0, this.init(t, e, i);\n      }\n      addEvents() {\n        let t = this.options.inverted ? [1, 0] : [0, 1],\n          i = this.scrollbarButtons,\n          s = this.scrollbarGroup.element,\n          o = this.track.element,\n          r = this.mouseDownHandler.bind(this),\n          n = this.mouseMoveHandler.bind(this),\n          l = this.mouseUpHandler.bind(this),\n          h = [[i[t[0]].element, "click", this.buttonToMinClick.bind(this)], [i[t[1]].element, "click", this.buttonToMaxClick.bind(this)], [o, "click", this.trackClick.bind(this)], [s, "mousedown", r], [s.ownerDocument, "mousemove", n], [s.ownerDocument, "mouseup", l]];\n        e.hasTouch && h.push([s, "touchstart", r], [s.ownerDocument, "touchmove", n], [s.ownerDocument, "touchend", l]), h.forEach(function (t) {\n          a.apply(null, t);\n        }), this._events = h;\n      }\n      buttonToMaxClick(t) {\n        let e = (this.to - this.from) * p(this.options.step, .2);\n        this.updatePosition(this.from + e, this.to + e), d(this, "changed", {\n          from: this.from,\n          to: this.to,\n          trigger: "scrollbar",\n          DOMEvent: t\n        });\n      }\n      buttonToMinClick(t) {\n        let e = n(this.to - this.from) * p(this.options.step, .2);\n        this.updatePosition(n(this.from - e), n(this.to - e)), d(this, "changed", {\n          from: this.from,\n          to: this.to,\n          trigger: "scrollbar",\n          DOMEvent: t\n        });\n      }\n      cursorToScrollbarPosition(t) {\n        let e = this.options,\n          i = e.minWidth > this.calculatedWidth ? e.minWidth : 0;\n        return {\n          chartX: (t.chartX - this.x - this.xOffset) / (this.barWidth - i),\n          chartY: (t.chartY - this.y - this.yOffset) / (this.barWidth - i)\n        };\n      }\n      destroy() {\n        let t = this,\n          e = t.chart.scroller;\n        t.removeEvents(), ["track", "scrollbarRifles", "scrollbar", "scrollbarGroup", "group"].forEach(function (e) {\n          t[e] && t[e].destroy && (t[e] = t[e].destroy());\n        }), e && t === e.scrollbar && (e.scrollbar = null, h(e.scrollbarButtons));\n      }\n      drawScrollbarButton(t) {\n        let e = this.renderer,\n          i = this.scrollbarButtons,\n          s = this.options,\n          o = this.size,\n          r = e.g().add(this.group);\n        if (i.push(r), s.buttonsEnabled) {\n          let a = e.rect().addClass("highcharts-scrollbar-button").add(r);\n          this.chart.styledMode || a.attr({\n            stroke: s.buttonBorderColor,\n            "stroke-width": s.buttonBorderWidth,\n            fill: s.buttonBackgroundColor\n          }), a.attr(a.crisp({\n            x: -.5,\n            y: -.5,\n            width: o + 1,\n            height: o + 1,\n            r: s.buttonBorderRadius\n          }, a.strokeWidth()));\n          let n = e.path(g.swapXY([["M", o / 2 + (t ? -1 : 1), o / 2 - 3], ["L", o / 2 + (t ? -1 : 1), o / 2 + 3], ["L", o / 2 + (t ? 2 : -2), o / 2]], s.vertical)).addClass("highcharts-scrollbar-arrow").add(i[t]);\n          this.chart.styledMode || n.attr({\n            fill: s.buttonArrowColor\n          });\n        }\n      }\n      init(t, e, i) {\n        this.scrollbarButtons = [], this.renderer = t, this.userOptions = e, this.options = c(s, r.scrollbar, e), this.options.margin = p(this.options.margin, 10), this.chart = i, this.size = p(this.options.size, this.options.height), e.enabled && (this.render(), this.addEvents());\n      }\n      mouseDownHandler(t) {\n        let e = this.chart.pointer.normalize(t),\n          i = this.cursorToScrollbarPosition(e);\n        this.chartX = i.chartX, this.chartY = i.chartY, this.initPositions = [this.from, this.to], this.grabbedCenter = !0;\n      }\n      mouseMoveHandler(t) {\n        let e;\n        let i = this.chart.pointer.normalize(t),\n          s = this.options,\n          o = s.vertical ? "chartY" : "chartX",\n          r = this.initPositions || [];\n        this.grabbedCenter && (!t.touches || 0 !== t.touches[0][o]) && (e = this.cursorToScrollbarPosition(i)[o] - this[o], this.hasDragged = !0, this.updatePosition(r[0] + e, r[1] + e), this.hasDragged && d(this, "changed", {\n          from: this.from,\n          to: this.to,\n          trigger: "scrollbar",\n          DOMType: t.type,\n          DOMEvent: t\n        }));\n      }\n      mouseUpHandler(t) {\n        this.hasDragged && d(this, "changed", {\n          from: this.from,\n          to: this.to,\n          trigger: "scrollbar",\n          DOMType: t.type,\n          DOMEvent: t\n        }), this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;\n      }\n      position(t, e, i, s) {\n        let o = this.options,\n          {\n            buttonsEnabled: r,\n            margin: a = 0,\n            vertical: n\n          } = o,\n          l = this.rendered ? "animate" : "attr",\n          h = s,\n          d = 0;\n        this.group.show(), this.x = t, this.y = e + this.trackBorderWidth, this.width = i, this.height = s, this.xOffset = h, this.yOffset = d, n ? (this.width = this.yOffset = i = d = this.size, this.xOffset = h = 0, this.yOffset = d = r ? this.size : 0, this.barWidth = s - (r ? 2 * i : 0), this.x = t += a) : (this.height = s = this.size, this.xOffset = h = r ? this.size : 0, this.barWidth = i - (r ? 2 * s : 0), this.y = this.y + a), this.group[l]({\n          translateX: t,\n          translateY: this.y\n        }), this.track[l]({\n          width: i,\n          height: s\n        }), this.scrollbarButtons[1][l]({\n          translateX: n ? 0 : i - h,\n          translateY: n ? s - d : 0\n        });\n      }\n      removeEvents() {\n        this._events.forEach(function (t) {\n          u.apply(null, t);\n        }), this._events.length = 0;\n      }\n      render() {\n        let t = this.renderer,\n          e = this.options,\n          i = this.size,\n          s = this.chart.styledMode,\n          o = t.g("scrollbar").attr({\n            zIndex: e.zIndex\n          }).hide().add();\n        this.group = o, this.track = t.rect().addClass("highcharts-scrollbar-track").attr({\n          r: e.trackBorderRadius || 0,\n          height: i,\n          width: i\n        }).add(o), s || this.track.attr({\n          fill: e.trackBackgroundColor,\n          stroke: e.trackBorderColor,\n          "stroke-width": e.trackBorderWidth\n        });\n        let r = this.trackBorderWidth = this.track.strokeWidth();\n        this.track.attr({\n          x: -r % 2 / 2,\n          y: -r % 2 / 2\n        }), this.scrollbarGroup = t.g().add(o), this.scrollbar = t.rect().addClass("highcharts-scrollbar-thumb").attr({\n          height: i - r,\n          width: i - r,\n          r: e.barBorderRadius || 0\n        }).add(this.scrollbarGroup), this.scrollbarRifles = t.path(g.swapXY([["M", -3, i / 4], ["L", -3, 2 * i / 3], ["M", 0, i / 4], ["L", 0, 2 * i / 3], ["M", 3, i / 4], ["L", 3, 2 * i / 3]], e.vertical)).addClass("highcharts-scrollbar-rifles").add(this.scrollbarGroup), s || (this.scrollbar.attr({\n          fill: e.barBackgroundColor,\n          stroke: e.barBorderColor,\n          "stroke-width": e.barBorderWidth\n        }), this.scrollbarRifles.attr({\n          stroke: e.rifleColor,\n          "stroke-width": 1\n        })), this.scrollbarStrokeWidth = this.scrollbar.strokeWidth(), this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2), this.drawScrollbarButton(0), this.drawScrollbarButton(1);\n      }\n      setRange(t, e) {\n        let i, s;\n        let o = this.options,\n          r = o.vertical,\n          a = o.minWidth,\n          h = this.barWidth,\n          d = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? "attr" : "animate";\n        if (!l(h)) return;\n        let c = h * Math.min(e, 1);\n        i = Math.ceil(h * (t = Math.max(t, 0))), this.calculatedWidth = s = n(c - i), s < a && (i = (h - a + s) * t, s = a);\n        let p = Math.floor(i + this.xOffset + this.yOffset),\n          u = s / 2 - .5;\n        this.from = t, this.to = e, r ? (this.scrollbarGroup[d]({\n          translateY: p\n        }), this.scrollbar[d]({\n          height: s\n        }), this.scrollbarRifles[d]({\n          translateY: u\n        }), this.scrollbarTop = p, this.scrollbarLeft = 0) : (this.scrollbarGroup[d]({\n          translateX: p\n        }), this.scrollbar[d]({\n          width: s\n        }), this.scrollbarRifles[d]({\n          translateX: u\n        }), this.scrollbarLeft = p, this.scrollbarTop = 0), s <= 12 ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(), !1 === o.showFull && (t <= 0 && e >= 1 ? this.group.hide() : this.group.show()), this.rendered = !0;\n      }\n      shouldUpdateExtremes(t) {\n        return p(this.options.liveRedraw, e.svg && !e.isTouchDevice && !this.chart.boosted) || "mouseup" === t || "touchend" === t || !l(t);\n      }\n      trackClick(t) {\n        let e = this.chart.pointer.normalize(t),\n          i = this.to - this.from,\n          s = this.y + this.scrollbarTop,\n          o = this.x + this.scrollbarLeft;\n        this.options.vertical && e.chartY > s || !this.options.vertical && e.chartX > o ? this.updatePosition(this.from + i, this.to + i) : this.updatePosition(this.from - i, this.to - i), d(this, "changed", {\n          from: this.from,\n          to: this.to,\n          trigger: "scrollbar",\n          DOMEvent: t\n        });\n      }\n      update(t) {\n        this.destroy(), this.init(this.chart.renderer, c(!0, this.options, t), this.chart);\n      }\n      updatePosition(t, e) {\n        e > 1 && (t = n(1 - n(e - t)), e = 1), t < 0 && (e = n(e - t), t = 0), this.from = t, this.to = e;\n      }\n    }\n    return g.defaultOptions = s, r.scrollbar = c(!0, g.defaultOptions, r.scrollbar), g;\n  }), i(e, "Stock/Navigator/Navigator.js", [e["Core/Axis/Axis.js"], e["Core/Defaults.js"], e["Core/Globals.js"], e["Core/Axis/NavigatorAxisComposition.js"], e["Stock/Navigator/NavigatorComposition.js"], e["Stock/Scrollbar/Scrollbar.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, r, a) {\n    let {\n        defaultOptions: n\n      } = e,\n      {\n        hasTouch: l,\n        isTouchDevice: h\n      } = i,\n      {\n        addEvent: d,\n        clamp: c,\n        correctFloat: p,\n        defined: u,\n        destroyObjectProperties: g,\n        erase: f,\n        extend: m,\n        find: x,\n        fireEvent: y,\n        isArray: b,\n        isNumber: v,\n        merge: M,\n        pick: S,\n        removeEvent: k,\n        splat: C\n      } = a;\n    function A(t, ...e) {\n      let i = [].filter.call(e, v);\n      if (i.length) return Math[t].apply(0, i);\n    }\n    class w {\n      static compose(t, e, i) {\n        o.compose(t, e, w, i);\n      }\n      constructor(t) {\n        this.scrollbarHeight = 0, this.init(t);\n      }\n      drawHandle(t, e, i, s) {\n        let o = this.navigatorOptions.handles.height;\n        this.handles[e][s](i ? {\n          translateX: Math.round(this.left + this.height / 2),\n          translateY: Math.round(this.top + parseInt(t, 10) + .5 - o)\n        } : {\n          translateX: Math.round(this.left + parseInt(t, 10)),\n          translateY: Math.round(this.top + this.height / 2 - o / 2 - 1)\n        });\n      }\n      drawOutline(t, e, i, s) {\n        let o = this.navigatorOptions.maskInside,\n          r = this.outline.strokeWidth(),\n          a = r / 2,\n          n = r % 2 / 2,\n          l = this.scrollButtonSize,\n          h = this.size,\n          d = this.top,\n          c = this.height,\n          p = d - a,\n          u = d + c,\n          g = this.left,\n          f,\n          m;\n        i ? (f = d + e + n, e = d + t + n, m = [["M", g + c, d - l - n], ["L", g + c, f], ["L", g, f], ["M", g, e], ["L", g + c, e], ["L", g + c, d + h + l]], o && m.push(["M", g + c, f - a], ["L", g + c, e + a])) : (g -= l, t += g + l - n, e += g + l - n, m = [["M", g, p], ["L", t, p], ["L", t, u], ["M", e, u], ["L", e, p], ["L", g + h + 2 * l, d + a]], o && m.push(["M", t - a, p], ["L", e + a, p])), this.outline[s]({\n          d: m\n        });\n      }\n      drawMasks(t, e, i, s) {\n        let o, r, a, n;\n        let l = this.left,\n          h = this.top,\n          d = this.height;\n        i ? (a = [l, l, l], n = [h, h + t, h + e], r = [d, d, d], o = [t, e - t, this.size - e]) : (a = [l, l + t, l + e], n = [h, h, h], r = [t, e - t, this.size - e], o = [d, d, d]), this.shades.forEach((t, e) => {\n          t[s]({\n            x: a[e],\n            y: n[e],\n            width: r[e],\n            height: o[e]\n          });\n        });\n      }\n      renderElements() {\n        let t = this,\n          e = t.navigatorOptions,\n          i = e.maskInside,\n          s = t.chart,\n          o = s.inverted,\n          r = s.renderer,\n          a = {\n            cursor: o ? "ns-resize" : "ew-resize"\n          },\n          n = t.navigatorGroup = r.g("navigator").attr({\n            zIndex: 8,\n            visibility: "hidden"\n          }).add();\n        if ([!i, i, !i].forEach((i, o) => {\n          let l = r.rect().addClass("highcharts-navigator-mask" + (1 === o ? "-inside" : "-outside")).add(n);\n          s.styledMode || (l.attr({\n            fill: i ? e.maskFill : "rgba(0,0,0,0)"\n          }), 1 === o && l.css(a)), t.shades[o] = l;\n        }), t.outline = r.path().addClass("highcharts-navigator-outline").add(n), s.styledMode || t.outline.attr({\n          "stroke-width": e.outlineWidth,\n          stroke: e.outlineColor\n        }), e.handles && e.handles.enabled) {\n          let i = e.handles,\n            {\n              height: o,\n              width: l\n            } = i;\n          [0, 1].forEach(e => {\n            t.handles[e] = r.symbol(i.symbols[e], -l / 2 - 1, 0, l, o, i), s.inverted && t.handles[e].attr({\n              rotation: 90,\n              rotationOriginX: Math.floor(-l / 2),\n              rotationOriginY: (o + l) / 2\n            }), t.handles[e].attr({\n              zIndex: 7 - e\n            }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + ["left", "right"][e]).add(n), s.styledMode || t.handles[e].attr({\n              fill: i.backgroundColor,\n              stroke: i.borderColor,\n              "stroke-width": i.lineWidth\n            }).css(a);\n          });\n        }\n      }\n      update(t) {\n        (this.series || []).forEach(t => {\n          t.baseSeries && delete t.baseSeries.navigatorSeries;\n        }), this.destroy();\n        let e = this.chart.options;\n        M(!0, e.navigator, t), this.init(this.chart);\n      }\n      render(t, e, i, s) {\n        let o = this.chart,\n          r = this.xAxis,\n          a = r.pointRange || 0,\n          n = r.navigatorAxis.fake ? o.xAxis[0] : r,\n          l = this.navigatorEnabled,\n          h = this.rendered,\n          d = o.inverted,\n          g = o.xAxis[0].minRange,\n          f = o.xAxis[0].options.maxRange,\n          m = this.scrollButtonSize,\n          x,\n          b,\n          M,\n          k = this.scrollbarHeight,\n          C,\n          A;\n        if (this.hasDragged && !u(i)) return;\n        if (t = p(t - a / 2), e = p(e + a / 2), !v(t) || !v(e)) {\n          if (!h) return;\n          i = 0, s = S(r.width, n.width);\n        }\n        this.left = S(r.left, o.plotLeft + m + (d ? o.plotWidth : 0));\n        let w = this.size = C = S(r.len, (d ? o.plotHeight : o.plotWidth) - 2 * m);\n        x = d ? k : C + 2 * m, i = S(i, r.toPixels(t, !0)), s = S(s, r.toPixels(e, !0)), v(i) && Math.abs(i) !== 1 / 0 || (i = 0, s = x);\n        let T = r.toValue(i, !0),\n          P = r.toValue(s, !0),\n          L = Math.abs(p(P - T));\n        L < g ? this.grabbedLeft ? i = r.toPixels(P - g - a, !0) : this.grabbedRight && (s = r.toPixels(T + g + a, !0)) : u(f) && p(L - a) > f && (this.grabbedLeft ? i = r.toPixels(P - f - a, !0) : this.grabbedRight && (s = r.toPixels(T + f + a, !0))), this.zoomedMax = c(Math.max(i, s), 0, w), this.zoomedMin = c(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(i, s), 0, w), this.range = this.zoomedMax - this.zoomedMin, w = Math.round(this.zoomedMax);\n        let D = Math.round(this.zoomedMin);\n        l && (this.navigatorGroup.attr({\n          visibility: "inherit"\n        }), A = h && !this.hasDragged ? "animate" : "attr", this.drawMasks(D, w, d, A), this.drawOutline(D, w, d, A), this.navigatorOptions.handles.enabled && (this.drawHandle(D, 0, d, A), this.drawHandle(w, 1, d, A))), this.scrollbar && (d ? (M = this.top - m, b = this.left - k + (l || !n.opposite ? 0 : (n.titleOffset || 0) + n.axisTitleMargin), k = C + 2 * m) : (M = this.top + (l ? this.height : -k), b = this.left - m), this.scrollbar.position(b, M, x, k), this.scrollbar.setRange(this.zoomedMin / (C || 1), this.zoomedMax / (C || 1))), this.rendered = !0, y(this, "afterRender");\n      }\n      addMouseEvents() {\n        let t = this,\n          e = t.chart,\n          i = e.container,\n          s = [],\n          o,\n          r;\n        t.mouseMoveHandler = o = function (e) {\n          t.onMouseMove(e);\n        }, t.mouseUpHandler = r = function (e) {\n          t.onMouseUp(e);\n        }, (s = t.getPartsEvents("mousedown")).push(d(e.renderTo, "mousemove", o), d(i.ownerDocument, "mouseup", r)), l && (s.push(d(e.renderTo, "touchmove", o), d(i.ownerDocument, "touchend", r)), s.concat(t.getPartsEvents("touchstart"))), t.eventsToUnbind = s, t.series && t.series[0] && s.push(d(t.series[0].xAxis, "foundExtremes", function () {\n          e.navigator.modifyNavigatorAxisExtremes();\n        }));\n      }\n      getPartsEvents(t) {\n        let e = this,\n          i = [];\n        return ["shades", "handles"].forEach(function (s) {\n          e[s].forEach(function (o, r) {\n            i.push(d(o.element, t, function (t) {\n              e[s + "Mousedown"](t, r);\n            }));\n          });\n        }), i;\n      }\n      shadesMousedown(t, e) {\n        t = this.chart.pointer.normalize(t);\n        let i = this.chart,\n          s = this.xAxis,\n          o = this.zoomedMin,\n          r = this.size,\n          a = this.range,\n          n = this.left,\n          l = t.chartX,\n          h,\n          d,\n          c,\n          p;\n        i.inverted && (l = t.chartY, n = this.top), 1 === e ? (this.grabbedCenter = l, this.fixedWidth = a, this.dragOffset = l - o) : (p = l - n - a / 2, 0 === e ? p = Math.max(0, p) : 2 === e && p + a >= r && (p = r - a, this.reversedExtremes ? (p -= a, d = this.getUnionExtremes().dataMin) : h = this.getUnionExtremes().dataMax), p !== o && (this.fixedWidth = a, u((c = s.navigatorAxis.toFixedRange(p, p + a, d, h)).min) && i.xAxis[0].setExtremes(Math.min(c.min, c.max), Math.max(c.min, c.max), !0, null, {\n          trigger: "navigator"\n        })));\n      }\n      handlesMousedown(t, e) {\n        t = this.chart.pointer.normalize(t);\n        let i = this.chart,\n          s = i.xAxis[0],\n          o = this.reversedExtremes;\n        0 === e ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = o ? s.min : s.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = o ? s.max : s.min), i.fixedRange = null;\n      }\n      onMouseMove(t) {\n        let e = this,\n          i = e.chart,\n          s = e.navigatorSize,\n          o = e.range,\n          r = e.dragOffset,\n          a = i.inverted,\n          n = e.left,\n          l;\n        (!t.touches || 0 !== t.touches[0].pageX) && (l = (t = i.pointer.normalize(t)).chartX, a && (n = e.top, l = t.chartY), e.grabbedLeft ? (e.hasDragged = !0, e.render(0, 0, l - n, e.otherHandlePos)) : e.grabbedRight ? (e.hasDragged = !0, e.render(0, 0, e.otherHandlePos, l - n)) : e.grabbedCenter && (e.hasDragged = !0, l < r ? l = r : l > s + r - o && (l = s + r - o), e.render(0, 0, l - r, l - r + o)), e.hasDragged && e.scrollbar && S(e.scrollbar.options.liveRedraw, !h && !this.chart.boosted) && (t.DOMType = t.type, setTimeout(function () {\n          e.onMouseUp(t);\n        }, 0)));\n      }\n      onMouseUp(t) {\n        let e, i, s, o, r, a;\n        let n = this.chart,\n          l = this.xAxis,\n          h = this.scrollbar,\n          d = t.DOMEvent || t,\n          c = n.inverted,\n          p = this.rendered && !this.hasDragged ? "animate" : "attr";\n        (this.hasDragged && (!h || !h.hasDragged) || "scrollbar" === t.trigger) && (s = this.getUnionExtremes(), this.zoomedMin === this.otherHandlePos ? o = this.fixedExtreme : this.zoomedMax === this.otherHandlePos && (r = this.fixedExtreme), this.zoomedMax === this.size && (r = this.reversedExtremes ? s.dataMin : s.dataMax), 0 === this.zoomedMin && (o = this.reversedExtremes ? s.dataMax : s.dataMin), u((a = l.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, o, r)).min) && n.xAxis[0].setExtremes(Math.min(a.min, a.max), Math.max(a.min, a.max), !0, !this.hasDragged && null, {\n          trigger: "navigator",\n          triggerOp: "navigator-drag",\n          DOMEvent: d\n        })), "mousemove" !== t.DOMType && "touchmove" !== t.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null), this.navigatorEnabled && v(this.zoomedMin) && v(this.zoomedMax) && (i = Math.round(this.zoomedMin), e = Math.round(this.zoomedMax), this.shades && this.drawMasks(i, e, c, p), this.outline && this.drawOutline(i, e, c, p), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(i, 0, c, p), this.drawHandle(e, 1, c, p)));\n      }\n      removeEvents() {\n        this.eventsToUnbind && (this.eventsToUnbind.forEach(function (t) {\n          t();\n        }), this.eventsToUnbind = void 0), this.removeBaseSeriesEvents();\n      }\n      removeBaseSeriesEvents() {\n        let t = this.baseSeries || [];\n        this.navigatorEnabled && t[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && t.forEach(function (t) {\n          k(t, "updatedData", this.updatedDataHandler);\n        }, this), t[0].xAxis && k(t[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));\n      }\n      init(e) {\n        let i = e.options,\n          o = i.navigator || {},\n          a = o.enabled,\n          n = i.scrollbar || {},\n          l = n.enabled,\n          h = a && o.height || 0,\n          c = l && n.height || 0,\n          p = n.buttonsEnabled && c || 0;\n        this.handles = [], this.shades = [], this.chart = e, this.setBaseSeries(), this.height = h, this.scrollbarHeight = c, this.scrollButtonSize = p, this.scrollbarEnabled = l, this.navigatorEnabled = a, this.navigatorOptions = o, this.scrollbarOptions = n, this.opposite = S(o.opposite, !!(!a && e.inverted));\n        let u = this,\n          g = u.baseSeries,\n          f = e.xAxis.length,\n          m = e.yAxis.length,\n          x = g && g[0] && g[0].xAxis || e.xAxis[0] || {\n            options: {}\n          };\n        if (e.isDirtyBox = !0, u.navigatorEnabled ? (u.xAxis = new t(e, M({\n          breaks: x.options.breaks,\n          ordinal: x.options.ordinal\n        }, o.xAxis, {\n          id: "navigator-x-axis",\n          yAxis: "navigator-y-axis",\n          type: "datetime",\n          index: f,\n          isInternal: !0,\n          offset: 0,\n          keepOrdinalPadding: !0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: 0,\n          maxPadding: 0,\n          zoomEnabled: !1\n        }, e.inverted ? {\n          offsets: [p, 0, -p, 0],\n          width: h\n        } : {\n          offsets: [0, -p, 0, p],\n          height: h\n        }), "xAxis"), u.yAxis = new t(e, M(o.yAxis, {\n          id: "navigator-y-axis",\n          alignTicks: !1,\n          offset: 0,\n          index: m,\n          isInternal: !0,\n          reversed: S(o.yAxis && o.yAxis.reversed, e.yAxis[0] && e.yAxis[0].reversed, !1),\n          zoomEnabled: !1\n        }, e.inverted ? {\n          width: h\n        } : {\n          height: h\n        }), "yAxis"), g || o.series.data ? u.updateNavigatorSeries(!1) : 0 === e.series.length && (u.unbindRedraw = d(e, "beforeRedraw", function () {\n          e.series.length > 0 && !u.series && (u.setBaseSeries(), u.unbindRedraw());\n        })), u.reversedExtremes = e.inverted && !u.xAxis.reversed || !e.inverted && u.xAxis.reversed, u.renderElements(), u.addMouseEvents()) : (u.xAxis = {\n          chart: e,\n          navigatorAxis: {\n            fake: !0\n          },\n          translate: function (t, i) {\n            let s = e.xAxis[0],\n              o = s.getExtremes(),\n              r = s.len - 2 * p,\n              a = A("min", s.options.min, o.dataMin),\n              n = A("max", s.options.max, o.dataMax) - a;\n            return i ? t * n / r + a : r * (t - a) / n;\n          },\n          toPixels: function (t) {\n            return this.translate(t);\n          },\n          toValue: function (t) {\n            return this.translate(t, !0);\n          }\n        }, u.xAxis.navigatorAxis.axis = u.xAxis, u.xAxis.navigatorAxis.toFixedRange = s.prototype.toFixedRange.bind(u.xAxis.navigatorAxis)), e.options.scrollbar.enabled) {\n          let t = M(e.options.scrollbar, {\n            vertical: e.inverted\n          });\n          !v(t.margin) && u.navigatorEnabled && (t.margin = e.inverted ? -3 : 3), e.scrollbar = u.scrollbar = new r(e.renderer, t, e), d(u.scrollbar, "changed", function (t) {\n            let e = u.size,\n              i = e * this.to,\n              s = e * this.from;\n            u.hasDragged = u.scrollbar.hasDragged, u.render(0, 0, s, i), this.shouldUpdateExtremes(t.DOMType) && setTimeout(function () {\n              u.onMouseUp(t);\n            });\n          });\n        }\n        u.addBaseSeriesEvents(), u.addChartEvents();\n      }\n      getUnionExtremes(t) {\n        let e;\n        let i = this.chart.xAxis[0],\n          s = this.xAxis,\n          o = s.options,\n          r = i.options;\n        return t && null === i.dataMin || (e = {\n          dataMin: S(o && o.min, A("min", r.min, i.dataMin, s.dataMin, s.min)),\n          dataMax: S(o && o.max, A("max", r.max, i.dataMax, s.dataMax, s.max))\n        }), e;\n      }\n      setBaseSeries(t, e) {\n        let i = this.chart,\n          s = this.baseSeries = [];\n        t = t || i.options && i.options.navigator.baseSeries || (i.series.length ? x(i.series, t => !t.options.isInternal).index : 0), (i.series || []).forEach((e, i) => {\n          !e.options.isInternal && (e.options.showInNavigator || (i === t || e.options.id === t) && !1 !== e.options.showInNavigator) && s.push(e);\n        }), this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(!0, e);\n      }\n      updateNavigatorSeries(t, e) {\n        let i = this,\n          s = i.chart,\n          o = i.baseSeries,\n          r = {\n            enableMouseTracking: !1,\n            index: null,\n            linkedTo: null,\n            group: "nav",\n            padXAxis: !1,\n            xAxis: "navigator-x-axis",\n            yAxis: "navigator-y-axis",\n            showInLegend: !1,\n            stacking: void 0,\n            isInternal: !0,\n            states: {\n              inactive: {\n                opacity: 1\n              }\n            }\n          },\n          a = i.series = (i.series || []).filter(t => {\n            let e = t.baseSeries;\n            return !(0 > o.indexOf(e)) || (e && (k(e, "updatedData", i.updatedDataHandler), delete e.navigatorSeries), t.chart && t.destroy(), !1);\n          }),\n          l,\n          h,\n          d = i.navigatorOptions.series,\n          c;\n        o && o.length && o.forEach(t => {\n          let p = t.navigatorSeries,\n            u = m({\n              color: t.color,\n              visible: t.visible\n            }, b(d) ? n.navigator.series : d);\n          if (p && !1 === i.navigatorOptions.adaptToUpdatedData) return;\n          r.name = "Navigator " + o.length, c = (l = t.options || {}).navigatorOptions || {}, u.dataLabels = C(u.dataLabels), (h = M(l, r, u, c)).pointRange = S(u.pointRange, c.pointRange, n.plotOptions[h.type || "line"].pointRange);\n          let g = c.data || u.data;\n          i.hasNavigatorData = i.hasNavigatorData || !!g, h.data = g || l.data && l.data.slice(0), p && p.options ? p.update(h, e) : (t.navigatorSeries = s.initSeries(h), t.navigatorSeries.baseSeries = t, a.push(t.navigatorSeries));\n        }), (d.data && !(o && o.length) || b(d)) && (i.hasNavigatorData = !1, (d = C(d)).forEach((t, e) => {\n          r.name = "Navigator " + (a.length + 1), (h = M(n.navigator.series, {\n            color: s.series[e] && !s.series[e].options.isInternal && s.series[e].color || s.options.colors[e] || s.options.colors[0]\n          }, r, t)).data = t.data, h.data && (i.hasNavigatorData = !0, a.push(s.initSeries(h)));\n        })), t && this.addBaseSeriesEvents();\n      }\n      addBaseSeriesEvents() {\n        let t = this,\n          e = t.baseSeries || [];\n        e[0] && e[0].xAxis && e[0].eventsToUnbind.push(d(e[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes)), e.forEach(e => {\n          e.eventsToUnbind.push(d(e, "show", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1);\n          })), e.eventsToUnbind.push(d(e, "hide", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1);\n          })), !1 !== this.navigatorOptions.adaptToUpdatedData && e.xAxis && e.eventsToUnbind.push(d(e, "updatedData", this.updatedDataHandler)), e.eventsToUnbind.push(d(e, "remove", function () {\n            this.navigatorSeries && (f(t.series, this.navigatorSeries), u(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries);\n          }));\n        });\n      }\n      getBaseSeriesMin(t) {\n        return this.baseSeries.reduce(function (t, e) {\n          return Math.min(t, e.xData && e.xData.length ? e.xData[0] : t);\n        }, t);\n      }\n      modifyNavigatorAxisExtremes() {\n        let t = this.xAxis;\n        if (void 0 !== t.getExtremes) {\n          let e = this.getUnionExtremes(!0);\n          e && (e.dataMin !== t.min || e.dataMax !== t.max) && (t.min = e.dataMin, t.max = e.dataMax);\n        }\n      }\n      modifyBaseAxisExtremes() {\n        let t, e;\n        let i = this.chart.navigator,\n          s = this.getExtremes(),\n          o = s.min,\n          r = s.max,\n          a = s.dataMin,\n          n = s.dataMax,\n          l = r - o,\n          h = i.stickToMin,\n          d = i.stickToMax,\n          c = S(this.options.overscroll, 0),\n          p = i.series && i.series[0],\n          u = !!this.setExtremes,\n          g = this.eventArgs && "rangeSelectorButton" === this.eventArgs.trigger;\n        !g && (h && (t = (e = a) + l), d && (t = n + c, h || (e = Math.max(a, t - l, i.getBaseSeriesMin(p && p.xData ? p.xData[0] : -Number.MAX_VALUE)))), u && (h || d) && v(e) && (this.min = this.userMin = e, this.max = this.userMax = t)), i.stickToMin = i.stickToMax = null;\n      }\n      updatedDataHandler() {\n        let t = this.chart.navigator,\n          e = this.navigatorSeries,\n          i = t.reversedExtremes ? 0 === Math.round(t.zoomedMin) : Math.round(t.zoomedMax) >= Math.round(t.size);\n        t.stickToMax = S(this.chart.options.navigator && this.chart.options.navigator.stickToMax, i), t.stickToMin = t.shouldStickToMin(this, t), e && !t.hasNavigatorData && (e.options.pointStart = this.xData[0], e.setData(this.options.data, !1, null, !1));\n      }\n      shouldStickToMin(t, e) {\n        let i = e.getBaseSeriesMin(t.xData[0]),\n          s = t.xAxis,\n          o = s.max,\n          r = s.min,\n          a = s.options.range;\n        return !!(v(o) && v(r)) && (a && o - i > 0 ? o - i < a : r <= i);\n      }\n      addChartEvents() {\n        this.eventsToUnbind || (this.eventsToUnbind = []), this.eventsToUnbind.push(d(this.chart, "redraw", function () {\n          let t = this.navigator,\n            e = t && (t.baseSeries && t.baseSeries[0] && t.baseSeries[0].xAxis || this.xAxis[0]);\n          e && t.render(e.min, e.max);\n        }), d(this.chart, "getMargins", function () {\n          let t = this.navigator,\n            e = t.opposite ? "plotTop" : "marginBottom";\n          this.inverted && (e = t.opposite ? "marginRight" : "plotLeft"), this[e] = (this[e] || 0) + (t.navigatorEnabled || !this.inverted ? t.height + t.scrollbarHeight : 0) + t.navigatorOptions.margin;\n        }));\n      }\n      destroy() {\n        this.removeEvents(), this.xAxis && (f(this.chart.xAxis, this.xAxis), f(this.chart.axes, this.xAxis)), this.yAxis && (f(this.chart.yAxis, this.yAxis), f(this.chart.axes, this.yAxis)), (this.series || []).forEach(t => {\n          t.destroy && t.destroy();\n        }), ["series", "xAxis", "yAxis", "shades", "outline", "scrollbarTrack", "scrollbarRifles", "scrollbarGroup", "scrollbar", "navigatorGroup", "rendered"].forEach(t => {\n          this[t] && this[t].destroy && this[t].destroy(), this[t] = null;\n        }), [this.handles].forEach(t => {\n          g(t);\n        });\n      }\n    }\n    return w;\n  }), i(e, "Stock/RangeSelector/RangeSelectorDefaults.js", [], function () {\n    return {\n      lang: {\n        rangeSelectorZoom: "Zoom",\n        rangeSelectorFrom: "",\n        rangeSelectorTo: "‚Üí"\n      },\n      rangeSelector: {\n        allButtonsEnabled: !1,\n        buttons: void 0,\n        buttonSpacing: 5,\n        dropdown: "responsive",\n        enabled: void 0,\n        verticalAlign: "top",\n        buttonTheme: {\n          width: 28,\n          height: 18,\n          padding: 2,\n          zIndex: 7\n        },\n        floating: !1,\n        x: 0,\n        y: 0,\n        height: void 0,\n        inputBoxBorderColor: "none",\n        inputBoxHeight: 17,\n        inputBoxWidth: void 0,\n        inputDateFormat: "%e %b %Y",\n        inputDateParser: void 0,\n        inputEditDateFormat: "%Y-%m-%d",\n        inputEnabled: !0,\n        inputPosition: {\n          align: "right",\n          x: 0,\n          y: 0\n        },\n        inputSpacing: 5,\n        selected: void 0,\n        buttonPosition: {\n          align: "left",\n          x: 0,\n          y: 0\n        },\n        inputStyle: {\n          color: "#334eff",\n          cursor: "pointer",\n          fontSize: "0.8em"\n        },\n        labelStyle: {\n          color: "#666666",\n          fontSize: "0.8em"\n        }\n      }\n    };\n  }), i(e, "Stock/RangeSelector/RangeSelectorComposition.js", [e["Core/Defaults.js"], e["Core/Globals.js"], e["Stock/RangeSelector/RangeSelectorDefaults.js"], e["Core/Utilities.js"]], function (t, e, i, s) {\n    let o;\n    let {\n        defaultOptions: r\n      } = t,\n      {\n        composed: a\n      } = e,\n      {\n        addEvent: n,\n        defined: l,\n        extend: h,\n        find: d,\n        isNumber: c,\n        merge: p,\n        pick: u,\n        pushUnique: g\n      } = s,\n      f = [];\n    function m() {\n      let t, e;\n      let i = this.range,\n        s = i.type,\n        o = this.max,\n        r = this.chart.time,\n        a = function (t, e) {\n          let i = "year" === s ? "FullYear" : "Month",\n            o = new r.Date(t),\n            a = r.get(i, o);\n          return r.set(i, o, a + e), a === r.get(i, o) && r.set("Date", o, 0), o.getTime() - t;\n        };\n      c(i) ? (t = o - i, e = i) : i && (t = o + a(o, -(i.count || 1)), this.chart && (this.chart.fixedRange = o - t));\n      let n = u(this.dataMin, Number.MIN_VALUE);\n      return c(t) || (t = n), t <= n && (t = n, void 0 === e && (e = a(t, i.count)), this.newMax = Math.min(t + e, u(this.dataMax, Number.MAX_VALUE))), c(o) ? !c(i) && i && i._offsetMin && (t += i._offsetMin) : t = void 0, t;\n    }\n    function x() {\n      this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new o(this));\n    }\n    function y() {\n      let t = this.axes,\n        e = this.rangeSelector;\n      if (e) {\n        c(e.deferredYTDClick) && (e.clickButton(e.deferredYTDClick), delete e.deferredYTDClick), t.forEach(t => {\n          t.updateNames(), t.setScale();\n        }), this.getAxisMargins(), e.render();\n        let i = e.options.verticalAlign;\n        e.options.floating || ("bottom" === i ? this.extraBottomMargin = !0 : "middle" === i || (this.extraTopMargin = !0));\n      }\n    }\n    function b(t) {\n      let e, i, s, o;\n      let r = t.rangeSelector,\n        a = () => {\n          r && (e = t.xAxis[0].getExtremes(), i = t.legend, o = r && r.options.verticalAlign, c(e.min) && r.render(e.min, e.max), i.display && "top" === o && o === i.options.verticalAlign && (s = p(t.spacingBox), "vertical" === i.options.layout ? s.y = t.plotTop : s.y += r.getHeight(), i.group.placed = !1, i.align(s)));\n        };\n      if (r) {\n        let e = d(f, e => e[0] === t);\n        e || f.push([t, [n(t.xAxis[0], "afterSetExtremes", function (t) {\n          r && r.render(t.min, t.max);\n        }), n(t, "redraw", a)]]), a();\n      }\n    }\n    function v() {\n      for (let t = 0, e = f.length; t < e; ++t) {\n        let e = f[t];\n        if (e[0] === this) {\n          e[1].forEach(t => t()), f.splice(t, 1);\n          return;\n        }\n      }\n    }\n    function M() {\n      let t = this.rangeSelector;\n      if (t) {\n        let e = t.getHeight();\n        this.extraTopMargin && (this.plotTop += e), this.extraBottomMargin && (this.marginBottom += e);\n      }\n    }\n    function S() {\n      let t = this.rangeSelector;\n      if (t && !t.options.floating) {\n        t.render();\n        let e = t.options.verticalAlign;\n        "bottom" === e ? this.extraBottomMargin = !0 : "middle" !== e && (this.extraTopMargin = !0);\n      }\n    }\n    function k(t) {\n      let e = t.options,\n        i = e.rangeSelector,\n        s = this.extraBottomMargin,\n        r = this.extraTopMargin,\n        a = this.rangeSelector;\n      if (i && i.enabled && !l(a) && this.options.rangeSelector && (this.options.rangeSelector.enabled = !0, this.rangeSelector = a = new o(this)), this.extraBottomMargin = !1, this.extraTopMargin = !1, a) {\n        b(this);\n        let t = i && i.verticalAlign || a.options && a.options.verticalAlign;\n        a.options.floating || ("bottom" === t ? this.extraBottomMargin = !0 : "middle" === t || (this.extraTopMargin = !0)), (this.extraBottomMargin !== s || this.extraTopMargin !== r) && (this.isDirtyBox = !0);\n      }\n    }\n    return {\n      compose: function t(e, s, l) {\n        if (o = l, g(a, t)) {\n          let t = s.prototype;\n          e.prototype.minFromRange = m, n(s, "afterGetContainer", x), n(s, "beforeRender", y), n(s, "destroy", v), n(s, "getMargins", M), n(s, "render", S), n(s, "update", k), t.callbacks.push(b), h(r, {\n            rangeSelector: i.rangeSelector\n          }), h(r.lang, i.lang);\n        }\n      }\n    };\n  }), i(e, "Stock/RangeSelector/RangeSelector.js", [e["Core/Axis/Axis.js"], e["Core/Defaults.js"], e["Core/Globals.js"], e["Stock/RangeSelector/RangeSelectorComposition.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Utilities.js"]], function (e, i, s, o, r, a) {\n    let {\n        defaultOptions: n\n      } = i,\n      {\n        addEvent: l,\n        createElement: h,\n        css: d,\n        defined: c,\n        destroyObjectProperties: p,\n        discardElement: u,\n        extend: g,\n        fireEvent: f,\n        isNumber: m,\n        merge: x,\n        objectEach: y,\n        pad: b,\n        pick: v,\n        pInt: M,\n        splat: S\n      } = a;\n    class k {\n      static compose(t, e) {\n        o.compose(t, e, k);\n      }\n      constructor(t) {\n        this.buttonOptions = k.prototype.defaultButtons, this.initialButtonGroupWidth = 0, this.chart = t, this.init(t);\n      }\n      clickButton(t, i) {\n        let s = this.chart,\n          o = this.buttonOptions[t],\n          r = s.xAxis[0],\n          a = s.scroller && s.scroller.getUnionExtremes() || r || {},\n          n = o.type,\n          h = o.dataGrouping,\n          d = a.dataMin,\n          p = a.dataMax,\n          u,\n          g = r && Math.round(Math.min(r.max, v(p, r.max))),\n          x,\n          y = o._range,\n          b,\n          M,\n          k,\n          C,\n          A,\n          w = !0;\n        if (null !== d && null !== p) {\n          if (s.fixedRange = y, this.setSelected(t), h && (this.forcedDataGrouping = !0, e.prototype.setDataGrouping.call(r || {\n            chart: this.chart\n          }, h, !1), this.frozenStates = o.preserveDataGrouping), "month" === n || "year" === n) r ? (C = {\n            range: o,\n            max: g,\n            chart: s,\n            dataMin: d,\n            dataMax: p\n          }, u = r.minFromRange.call(C), m(C.newMax) && (g = C.newMax), w = !1) : y = o;else if (y) g = Math.min((u = Math.max(g - y, d)) + y, p), w = !1;else if ("ytd" === n) {\n            if (r) (void 0 === p || void 0 === d) && (d = Number.MAX_VALUE, p = Number.MIN_VALUE, s.series.forEach(t => {\n              let e = t.xData;\n              e && (d = Math.min(e[0], d), p = Math.max(e[e.length - 1], p));\n            }), i = !1), u = b = (A = this.getYTDExtremes(p, d, s.time.useUTC)).min, g = A.max;else {\n              this.deferredYTDClick = t;\n              return;\n            }\n          } else "all" === n && r && (s.navigator && s.navigator.baseSeries[0] && (s.navigator.baseSeries[0].xAxis.options.range = void 0), u = d, g = p);\n          w && o._offsetMin && c(u) && (u += o._offsetMin), o._offsetMax && c(g) && (g += o._offsetMax), this.dropdown && (this.dropdown.selectedIndex = t + 1), r ? r.setExtremes(u, g, v(i, !0), void 0, {\n            trigger: "rangeSelectorButton",\n            rangeSelectorButton: o\n          }) : (k = (x = S(s.options.xAxis)[0]).range, x.range = y, M = x.min, x.min = b, l(s, "load", function () {\n            x.range = k, x.min = M;\n          })), f(this, "afterBtnClick");\n        }\n      }\n      setSelected(t) {\n        this.selected = this.options.selected = t;\n      }\n      init(t) {\n        let e = this,\n          i = t.options.rangeSelector,\n          s = i.buttons || e.defaultButtons.slice(),\n          o = i.selected,\n          r = function () {\n            let t = e.minInput,\n              i = e.maxInput;\n            t && t.blur && f(t, "blur"), i && i.blur && f(i, "blur");\n          };\n        e.chart = t, e.options = i, e.buttons = [], e.buttonOptions = s, this.eventsToUnbind = [], this.eventsToUnbind.push(l(t.container, "mousedown", r)), this.eventsToUnbind.push(l(t, "resize", r)), s.forEach(e.computeButtonRange), void 0 !== o && s[o] && this.clickButton(o, !1), this.eventsToUnbind.push(l(t, "load", function () {\n          t.xAxis && t.xAxis[0] && l(t.xAxis[0], "setExtremes", function (i) {\n            this.max - this.min !== t.fixedRange && "rangeSelectorButton" !== i.trigger && "updatedData" !== i.trigger && e.forcedDataGrouping && !e.frozenStates && this.setDataGrouping(!1, !1);\n          });\n        }));\n      }\n      updateButtonStates() {\n        let t = this,\n          e = this.chart,\n          i = this.dropdown,\n          s = e.xAxis[0],\n          o = Math.round(s.max - s.min),\n          r = !s.hasVisibleSeries,\n          a = 24 * 36e5,\n          n = e.scroller && e.scroller.getUnionExtremes() || s,\n          l = n.dataMin,\n          h = n.dataMax,\n          d = t.getYTDExtremes(h, l, e.time.useUTC),\n          p = d.min,\n          u = d.max,\n          g = t.selected,\n          f = t.options.allButtonsEnabled,\n          x = t.buttons,\n          y = m(g),\n          b = !1;\n        t.buttonOptions.forEach((e, n) => {\n          let d = e._range,\n            m = e.type,\n            v = e.count || 1,\n            M = x[n],\n            S = e._offsetMax - e._offsetMin,\n            k = n === g,\n            C = d > h - l,\n            A = d < s.minRange,\n            w = 0,\n            T = !1,\n            P = !1,\n            L = d === o;\n          k && C && (b = !0), ("month" === m || "year" === m) && o + 36e5 >= {\n            month: 28,\n            year: 365\n          }[m] * a * v - S && o - 36e5 <= {\n            month: 31,\n            year: 366\n          }[m] * a * v + S ? L = !0 : "ytd" === m ? (L = u - p + S === o, T = !k) : "all" === m && (L = s.max - s.min >= h - l, P = !k && y && L);\n          let D = !f && !(b && "all" === m) && (C || A || P || r),\n            O = b && "all" === m || k && L || L && !y && !T || k && t.frozenStates;\n          D ? w = 3 : O && (y = !0, w = 2), M.state !== w && (M.setState(w), i && (i.options[n + 1].disabled = D, 2 === w && (i.selectedIndex = n + 1)), 0 === w && g === n ? t.setSelected() : (2 === w && !c(g) || b) && t.setSelected(n));\n        });\n      }\n      computeButtonRange(t) {\n        let e = t.type,\n          i = t.count || 1,\n          s = {\n            millisecond: 1,\n            second: 1e3,\n            minute: 6e4,\n            hour: 36e5,\n            day: 864e5,\n            week: 6048e5\n          };\n        s[e] ? t._range = s[e] * i : ("month" === e || "year" === e) && (t._range = 24 * {\n          month: 30,\n          year: 365\n        }[e] * 36e5 * i), t._offsetMin = v(t.offsetMin, 0), t._offsetMax = v(t.offsetMax, 0), t._range += t._offsetMax - t._offsetMin;\n      }\n      getInputValue(t) {\n        let e = "min" === t ? this.minInput : this.maxInput,\n          i = this.chart.options.rangeSelector,\n          s = this.chart.time;\n        return e ? ("text" === e.type && i.inputDateParser || this.defaultInputDateParser)(e.value, s.useUTC, s) : 0;\n      }\n      setInputValue(t, e) {\n        let i = this.options,\n          s = this.chart.time,\n          o = "min" === t ? this.minInput : this.maxInput,\n          r = "min" === t ? this.minDateBox : this.maxDateBox;\n        if (o) {\n          let t = o.getAttribute("data-hc-time"),\n            a = c(t) ? Number(t) : void 0;\n          if (c(e)) {\n            let t = a;\n            c(t) && o.setAttribute("data-hc-time-previous", t), o.setAttribute("data-hc-time", e), a = e;\n          }\n          o.value = s.dateFormat(this.inputTypeFormats[o.type] || i.inputEditDateFormat, a), r && r.attr({\n            text: s.dateFormat(i.inputDateFormat, a)\n          });\n        }\n      }\n      setInputExtremes(t, e, i) {\n        let s = "min" === t ? this.minInput : this.maxInput;\n        if (s) {\n          let t = this.inputTypeFormats[s.type],\n            o = this.chart.time;\n          if (t) {\n            let r = o.dateFormat(t, e);\n            s.min !== r && (s.min = r);\n            let a = o.dateFormat(t, i);\n            s.max !== a && (s.max = a);\n          }\n        }\n      }\n      showInput(t) {\n        let e = "min" === t ? this.minDateBox : this.maxDateBox,\n          i = "min" === t ? this.minInput : this.maxInput;\n        if (i && e && this.inputGroup) {\n          let t = "text" === i.type,\n            {\n              translateX: s = 0,\n              translateY: o = 0\n            } = this.inputGroup,\n            {\n              x: r = 0,\n              width: a = 0,\n              height: n = 0\n            } = e,\n            {\n              inputBoxWidth: l\n            } = this.options;\n          d(i, {\n            width: t ? a + (l ? -2 : 20) + "px" : "auto",\n            height: n - 2 + "px",\n            border: "2px solid silver"\n          }), t && l ? d(i, {\n            left: s + r + "px",\n            top: o + "px"\n          }) : d(i, {\n            left: Math.min(Math.round(r + s - (i.offsetWidth - a) / 2), this.chart.chartWidth - i.offsetWidth) + "px",\n            top: o - (i.offsetHeight - n) / 2 + "px"\n          });\n        }\n      }\n      hideInput(t) {\n        let e = "min" === t ? this.minInput : this.maxInput;\n        e && d(e, {\n          top: "-9999em",\n          border: 0,\n          width: "1px",\n          height: "1px"\n        });\n      }\n      defaultInputDateParser(t, e, i) {\n        let o = t.split("/").join("-").split(" ").join("T");\n        if (-1 === o.indexOf("T") && (o += "T00:00"), e) o += "Z";else {\n          var r;\n          if (s.isSafari && (!((r = o).length > 6) || r.lastIndexOf("-") !== r.length - 6 && r.lastIndexOf("+") !== r.length - 6)) {\n            let t = new Date(o).getTimezoneOffset() / 60;\n            o += t <= 0 ? `+${b(-t)}:00` : `-${b(t)}:00`;\n          }\n        }\n        let a = Date.parse(o);\n        if (!m(a)) {\n          let e = t.split("-");\n          a = Date.UTC(M(e[0]), M(e[1]) - 1, M(e[2]));\n        }\n        return i && e && m(a) && (a += i.getTimezoneOffset(a)), a;\n      }\n      drawInput(t) {\n        let {\n            chart: e,\n            div: i,\n            inputGroup: o\n          } = this,\n          r = this,\n          a = e.renderer.style || {},\n          l = e.renderer,\n          c = e.options.rangeSelector,\n          p = n.lang,\n          u = "min" === t;\n        function f() {\n          let {\n              maxInput: i,\n              minInput: s\n            } = r,\n            o = e.xAxis[0],\n            a = e.scroller && e.scroller.getUnionExtremes() || o,\n            n = a.dataMin,\n            l = a.dataMax,\n            h = r.getInputValue(t);\n          h !== Number(M.getAttribute("data-hc-time-previous")) && m(h) && (M.setAttribute("data-hc-time-previous", h), u && i && m(n) ? h > Number(i.getAttribute("data-hc-time")) ? h = void 0 : h < n && (h = n) : s && m(l) && (h < Number(s.getAttribute("data-hc-time")) ? h = void 0 : h > l && (h = l)), void 0 !== h && o.setExtremes(u ? h : o.min, u ? o.max : h, void 0, void 0, {\n            trigger: "rangeSelectorInput"\n          }));\n        }\n        let y = p[u ? "rangeSelectorFrom" : "rangeSelectorTo"] || "",\n          b = l.label(y, 0).addClass("highcharts-range-label").attr({\n            padding: y ? 2 : 0,\n            height: y ? c.inputBoxHeight : 0\n          }).add(o),\n          v = l.label("", 0).addClass("highcharts-range-input").attr({\n            padding: 2,\n            width: c.inputBoxWidth,\n            height: c.inputBoxHeight,\n            "text-align": "center"\n          }).on("click", function () {\n            r.showInput(t), r[t + "Input"].focus();\n          });\n        e.styledMode || v.attr({\n          stroke: c.inputBoxBorderColor,\n          "stroke-width": 1\n        }), v.add(o);\n        let M = h("input", {\n          name: t,\n          className: "highcharts-range-selector"\n        }, void 0, i);\n        M.setAttribute("type", function (t) {\n          let e = -1 !== t.indexOf("%L");\n          if (e) return "text";\n          let i = ["a", "A", "d", "e", "w", "b", "B", "m", "o", "y", "Y"].some(e => -1 !== t.indexOf("%" + e)),\n            s = ["H", "k", "I", "l", "M", "S"].some(e => -1 !== t.indexOf("%" + e));\n          return i && s ? "datetime-local" : i ? "date" : s ? "time" : "text";\n        }(c.inputDateFormat || "%e %b %Y")), e.styledMode || (b.css(x(a, c.labelStyle)), v.css(x({\n          color: "#333333"\n        }, a, c.inputStyle)), d(M, g({\n          position: "absolute",\n          border: 0,\n          boxShadow: "0 0 15px rgba(0,0,0,0.3)",\n          width: "1px",\n          height: "1px",\n          padding: 0,\n          textAlign: "center",\n          fontSize: a.fontSize,\n          fontFamily: a.fontFamily,\n          top: "-9999em"\n        }, c.inputStyle))), M.onfocus = () => {\n          r.showInput(t);\n        }, M.onblur = () => {\n          M === s.doc.activeElement && f(), r.hideInput(t), r.setInputValue(t), M.blur();\n        };\n        let S = !1;\n        return M.onchange = () => {\n          S || (f(), r.hideInput(t), M.blur());\n        }, M.onkeypress = t => {\n          13 === t.keyCode && f();\n        }, M.onkeydown = t => {\n          S = !0, (38 === t.keyCode || 40 === t.keyCode) && f();\n        }, M.onkeyup = () => {\n          S = !1;\n        }, {\n          dateBox: v,\n          input: M,\n          label: b\n        };\n      }\n      getPosition() {\n        let t = this.chart,\n          e = t.options.rangeSelector,\n          i = "top" === e.verticalAlign ? t.plotTop - t.axisOffset[0] : 0;\n        return {\n          buttonTop: i + e.buttonPosition.y,\n          inputTop: i + e.inputPosition.y - 10\n        };\n      }\n      getYTDExtremes(t, e, i) {\n        let s = this.chart.time,\n          o = new s.Date(t),\n          r = s.get("FullYear", o),\n          a = i ? s.Date.UTC(r, 0, 1) : +new s.Date(r, 0, 1),\n          n = Math.max(e, a),\n          l = o.getTime();\n        return {\n          max: Math.min(t || l, l),\n          min: n\n        };\n      }\n      render(t, e) {\n        let i = this.chart,\n          s = i.renderer,\n          o = i.container,\n          r = i.options,\n          a = r.rangeSelector,\n          n = v(r.chart.style && r.chart.style.zIndex, 0) + 1,\n          l = a.inputEnabled,\n          d = this.rendered;\n        if (!1 !== a.enabled) {\n          if (!d && (this.group = s.g("range-selector-group").attr({\n            zIndex: 7\n          }).add(), this.div = h("div", void 0, {\n            position: "relative",\n            height: 0,\n            zIndex: n\n          }), this.buttonOptions.length && this.renderButtons(), o.parentNode && o.parentNode.insertBefore(this.div, o), l)) {\n            this.inputGroup = s.g("input-group").add(this.group);\n            let t = this.drawInput("min");\n            this.minDateBox = t.dateBox, this.minLabel = t.label, this.minInput = t.input;\n            let e = this.drawInput("max");\n            this.maxDateBox = e.dateBox, this.maxLabel = e.label, this.maxInput = e.input;\n          }\n          if (l) {\n            this.setInputValue("min", t), this.setInputValue("max", e);\n            let s = i.scroller && i.scroller.getUnionExtremes() || i.xAxis[0] || {};\n            if (c(s.dataMin) && c(s.dataMax)) {\n              let t = i.xAxis[0].minRange || 0;\n              this.setInputExtremes("min", s.dataMin, Math.min(s.dataMax, this.getInputValue("max")) - t), this.setInputExtremes("max", Math.max(s.dataMin, this.getInputValue("min")) + t, s.dataMax);\n            }\n            if (this.inputGroup) {\n              let t = 0;\n              [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach(e => {\n                if (e) {\n                  let {\n                    width: i\n                  } = e.getBBox();\n                  i && (e.attr({\n                    x: t\n                  }), t += i + a.inputSpacing);\n                }\n              });\n            }\n          }\n          this.alignElements(), this.rendered = !0;\n        }\n      }\n      renderButtons() {\n        let {\n            buttons: t,\n            chart: e,\n            options: i\n          } = this,\n          o = n.lang,\n          r = e.renderer,\n          a = x(i.buttonTheme),\n          d = a && a.states,\n          c = a.width || 28;\n        delete a.width, delete a.states, this.buttonGroup = r.g("range-selector-buttons").add(this.group);\n        let p = this.dropdown = h("select", void 0, {\n          position: "absolute",\n          width: "1px",\n          height: "1px",\n          padding: 0,\n          border: 0,\n          top: "-9999em",\n          cursor: "pointer",\n          opacity: 1e-4\n        }, this.div);\n        l(p, "touchstart", () => {\n          p.style.fontSize = "16px";\n        }), [[s.isMS ? "mouseover" : "mouseenter"], [s.isMS ? "mouseout" : "mouseleave"], ["change", "click"]].forEach(([e, i]) => {\n          l(p, e, () => {\n            let s = t[this.currentButtonIndex()];\n            s && f(s.element, i || e);\n          });\n        }), this.zoomText = r.label(o && o.rangeSelectorZoom || "", 0).attr({\n          padding: i.buttonTheme.padding,\n          height: i.buttonTheme.height,\n          paddingLeft: 0,\n          paddingRight: 0\n        }).add(this.buttonGroup), this.chart.styledMode || (this.zoomText.css(i.labelStyle), a["stroke-width"] = v(a["stroke-width"], 0)), h("option", {\n          textContent: this.zoomText.textStr,\n          disabled: !0\n        }, void 0, p), this.buttonOptions.forEach((e, i) => {\n          h("option", {\n            textContent: e.title || e.text\n          }, void 0, p), t[i] = r.button(e.text, 0, 0, t => {\n            let s;\n            let o = e.events && e.events.click;\n            o && (s = o.call(e, t)), !1 !== s && this.clickButton(i), this.isActive = !0;\n          }, a, d && d.hover, d && d.select, d && d.disabled).attr({\n            "text-align": "center",\n            width: c\n          }).add(this.buttonGroup), e.title && t[i].attr("title", e.title);\n        });\n      }\n      alignElements() {\n        let {\n            buttonGroup: t,\n            buttons: e,\n            chart: i,\n            group: s,\n            inputGroup: o,\n            options: r,\n            zoomText: a\n          } = this,\n          n = i.options,\n          l = n.exporting && !1 !== n.exporting.enabled && n.navigation && n.navigation.buttonOptions,\n          {\n            buttonPosition: h,\n            inputPosition: d,\n            verticalAlign: c\n          } = r,\n          p = (t, e) => l && this.titleCollision(i) && "top" === c && "right" === e.align && e.y - t.getBBox().height - 12 < (l.y || 0) + (l.height || 0) + i.spacing[0] ? -40 : 0,\n          u = i.plotLeft;\n        if (s && h && d) {\n          let n = h.x - i.spacing[3];\n          if (t) {\n            if (this.positionButtons(), !this.initialButtonGroupWidth) {\n              let t = 0;\n              a && (t += a.getBBox().width + 5), e.forEach((i, s) => {\n                t += i.width || 0, s !== e.length - 1 && (t += r.buttonSpacing);\n              }), this.initialButtonGroupWidth = t;\n            }\n            u -= i.spacing[3], this.updateButtonStates();\n            let o = p(t, h);\n            this.alignButtonGroup(o), s.placed = t.placed = i.hasLoaded;\n          }\n          let l = 0;\n          o && (l = p(o, d), "left" === d.align ? n = u : "right" === d.align && (n = -Math.max(i.axisOffset[1], -l)), o.align({\n            y: d.y,\n            width: o.getBBox().width,\n            align: d.align,\n            x: d.x + n - 2\n          }, !0, i.spacingBox), o.placed = i.hasLoaded), this.handleCollision(l), s.align({\n            verticalAlign: c\n          }, !0, i.spacingBox);\n          let g = s.alignAttr.translateY,\n            f = s.getBBox().height + 20,\n            m = 0;\n          if ("bottom" === c) {\n            let t = i.legend && i.legend.options,\n              e = t && "bottom" === t.verticalAlign && t.enabled && !t.floating ? i.legend.legendHeight + v(t.margin, 10) : 0;\n            m = g - (f = f + e - 20) - (r.floating ? 0 : r.y) - (i.titleOffset ? i.titleOffset[2] : 0) - 10;\n          }\n          "top" === c ? (r.floating && (m = 0), i.titleOffset && i.titleOffset[0] && (m = i.titleOffset[0]), m += i.margin[0] - i.spacing[0] || 0) : "middle" === c && (d.y === h.y ? m = g : (d.y || h.y) && (d.y < 0 || h.y < 0 ? m -= Math.min(d.y, h.y) : m = g - f)), s.translate(r.x, r.y + Math.floor(m));\n          let {\n            minInput: x,\n            maxInput: y,\n            dropdown: b\n          } = this;\n          r.inputEnabled && x && y && (x.style.marginTop = s.translateY + "px", y.style.marginTop = s.translateY + "px"), b && (b.style.marginTop = s.translateY + "px");\n        }\n      }\n      alignButtonGroup(t, e) {\n        let {\n            chart: i,\n            options: s,\n            buttonGroup: o,\n            buttons: r\n          } = this,\n          {\n            buttonPosition: a\n          } = s,\n          n = i.plotLeft - i.spacing[3],\n          l = a.x - i.spacing[3];\n        "right" === a.align ? l += t - n : "center" === a.align && (l -= n / 2), o && o.align({\n          y: a.y,\n          width: v(e, this.initialButtonGroupWidth),\n          align: a.align,\n          x: l\n        }, !0, i.spacingBox);\n      }\n      positionButtons() {\n        let {\n            buttons: t,\n            chart: e,\n            options: i,\n            zoomText: s\n          } = this,\n          o = e.hasLoaded ? "animate" : "attr",\n          {\n            buttonPosition: r\n          } = i,\n          a = e.plotLeft,\n          n = a;\n        s && "hidden" !== s.visibility && (s[o]({\n          x: v(a + r.x, a)\n        }), n += r.x + s.getBBox().width + 5);\n        for (let e = 0, s = this.buttonOptions.length; e < s; ++e) "hidden" !== t[e].visibility ? (t[e][o]({\n          x: n\n        }), n += (t[e].width || 0) + i.buttonSpacing) : t[e][o]({\n          x: a\n        });\n      }\n      handleCollision(t) {\n        let {\n            chart: e,\n            buttonGroup: i,\n            inputGroup: s\n          } = this,\n          {\n            buttonPosition: o,\n            dropdown: r,\n            inputPosition: a\n          } = this.options,\n          n = () => {\n            let t = 0;\n            return this.buttons.forEach(e => {\n              let i = e.getBBox();\n              i.width > t && (t = i.width);\n            }), t;\n          },\n          l = e => {\n            if (s && i) {\n              let r = s.alignAttr.translateX + s.alignOptions.x - t + s.getBBox().x + 2,\n                n = s.alignOptions.width,\n                l = i.alignAttr.translateX + i.getBBox().x;\n              return l + e > r && r + n > l && o.y < a.y + s.getBBox().height;\n            }\n            return !1;\n          },\n          h = () => {\n            s && i && s.attr({\n              translateX: s.alignAttr.translateX + (e.axisOffset[1] >= -t ? 0 : -t),\n              translateY: s.alignAttr.translateY + i.getBBox().height + 10\n            });\n          };\n        if (i) {\n          if ("always" === r) {\n            this.collapseButtons(t), l(n()) && h();\n            return;\n          }\n          "never" === r && this.expandButtons();\n        }\n        s && i ? a.align === o.align || l(this.initialButtonGroupWidth + 20) ? "responsive" === r ? (this.collapseButtons(t), l(n()) && h()) : h() : "responsive" === r && this.expandButtons() : i && "responsive" === r && (this.initialButtonGroupWidth > e.plotWidth ? this.collapseButtons(t) : this.expandButtons());\n      }\n      collapseButtons(t) {\n        let {\n          buttons: e,\n          buttonOptions: i,\n          chart: s,\n          dropdown: o,\n          options: r,\n          zoomText: a\n        } = this;\n        if (!0 === this.isCollapsed) return;\n        this.isCollapsed = !0;\n        let n = s.userOptions.rangeSelector && s.userOptions.rangeSelector.buttonTheme || {},\n          l = t => ({\n            text: t ? `${t} ‚ñæ` : "‚ñæ",\n            width: "auto",\n            paddingLeft: v(r.buttonTheme.paddingLeft, n.padding, 8),\n            paddingRight: v(r.buttonTheme.paddingRight, n.padding, 8)\n          });\n        a && a.hide();\n        let h = !1;\n        i.forEach((t, i) => {\n          let s = e[i];\n          2 !== s.state ? s.hide() : (s.show(), s.attr(l(t.text)), h = !0);\n        }), h || (o && (o.selectedIndex = 0), e[0].show(), e[0].attr(l(this.zoomText && this.zoomText.textStr)));\n        let {\n          align: d\n        } = r.buttonPosition;\n        this.positionButtons(), ("right" === d || "center" === d) && this.alignButtonGroup(t, e[this.currentButtonIndex()].getBBox().width), this.showDropdown();\n      }\n      expandButtons() {\n        let {\n          buttons: t,\n          buttonOptions: e,\n          options: i,\n          zoomText: s\n        } = this;\n        this.hideDropdown(), !1 !== this.isCollapsed && (this.isCollapsed = !1, s && s.show(), e.forEach((e, s) => {\n          let o = t[s];\n          o.show(), o.attr({\n            text: e.text,\n            width: i.buttonTheme.width || 28,\n            paddingLeft: v(i.buttonTheme.paddingLeft, "unset"),\n            paddingRight: v(i.buttonTheme.paddingRight, "unset")\n          }), o.state < 2 && o.setState(0);\n        }), this.positionButtons());\n      }\n      currentButtonIndex() {\n        let {\n          dropdown: t\n        } = this;\n        return t && t.selectedIndex > 0 ? t.selectedIndex - 1 : 0;\n      }\n      showDropdown() {\n        let {\n          buttonGroup: t,\n          buttons: e,\n          chart: i,\n          dropdown: s\n        } = this;\n        if (t && s) {\n          let {\n              translateX: o = 0,\n              translateY: r = 0\n            } = t,\n            a = e[this.currentButtonIndex()].getBBox();\n          d(s, {\n            left: i.plotLeft + o + "px",\n            top: r + .5 + "px",\n            width: a.width + "px",\n            height: a.height + "px"\n          }), this.hasVisibleDropdown = !0;\n        }\n      }\n      hideDropdown() {\n        let {\n          dropdown: t\n        } = this;\n        t && (d(t, {\n          top: "-9999em",\n          width: "1px",\n          height: "1px"\n        }), this.hasVisibleDropdown = !1);\n      }\n      getHeight() {\n        let t = this.options,\n          e = this.group,\n          i = t.inputPosition,\n          s = t.buttonPosition,\n          o = t.y,\n          r = s.y,\n          a = i.y,\n          n = 0;\n        if (t.height) return t.height;\n        this.alignElements(), n = e ? e.getBBox(!0).height + 13 + o : 0;\n        let l = Math.min(a, r);\n        return (a < 0 && r < 0 || a > 0 && r > 0) && (n += Math.abs(l)), n;\n      }\n      titleCollision(t) {\n        return !(t.options.title.text || t.options.subtitle.text);\n      }\n      update(t) {\n        let e = this.chart;\n        x(!0, e.options.rangeSelector, t), this.destroy(), this.init(e), this.render();\n      }\n      destroy() {\n        let e = this,\n          i = e.minInput,\n          s = e.maxInput;\n        e.eventsToUnbind && (e.eventsToUnbind.forEach(t => t()), e.eventsToUnbind = void 0), p(e.buttons), i && (i.onfocus = i.onblur = i.onchange = null), s && (s.onfocus = s.onblur = s.onchange = null), y(e, function (i, s) {\n          i && "chart" !== s && (i instanceof r ? i.destroy() : i instanceof t.HTMLElement && u(i)), i !== k.prototype[s] && (e[s] = null);\n        }, this);\n      }\n    }\n    return g(k.prototype, {\n      defaultButtons: [{\n        type: "month",\n        count: 1,\n        text: "1m",\n        title: "View 1 month"\n      }, {\n        type: "month",\n        count: 3,\n        text: "3m",\n        title: "View 3 months"\n      }, {\n        type: "month",\n        count: 6,\n        text: "6m",\n        title: "View 6 months"\n      }, {\n        type: "ytd",\n        text: "YTD",\n        title: "View year to date"\n      }, {\n        type: "year",\n        count: 1,\n        text: "1y",\n        title: "View 1 year"\n      }, {\n        type: "all",\n        text: "All",\n        title: "View all"\n      }],\n      inputTypeFormats: {\n        "datetime-local": "%Y-%m-%dT%H:%M:%S",\n        date: "%Y-%m-%d",\n        time: "%H:%M:%S"\n      }\n    }), k;\n  }), i(e, "Core/Axis/OrdinalAxis.js", [e["Core/Axis/Axis.js"], e["Core/Globals.js"], e["Core/Series/Series.js"], e["Core/Utilities.js"]], function (t, e, i, s) {\n    var o;\n    let {\n        composed: r\n      } = e,\n      {\n        addEvent: a,\n        correctFloat: n,\n        css: l,\n        defined: h,\n        error: d,\n        pick: c,\n        pushUnique: p,\n        timeUnits: u\n      } = s;\n    return function (t) {\n      function s(t, e, i, s, o = [], r = 0, a) {\n        let n = {},\n          l = this.options.tickPixelInterval,\n          c = this.chart.time,\n          p = [],\n          g,\n          f,\n          m,\n          x,\n          y,\n          b = 0,\n          v = [],\n          M = -Number.MAX_VALUE;\n        if (!this.options.ordinal && !this.options.breaks || !o || o.length < 3 || void 0 === e) return c.getTimeTicks.apply(c, arguments);\n        let S = o.length;\n        for (g = 0; g < S; g++) {\n          if (y = g && o[g - 1] > i, o[g] < e && (b = g), g === S - 1 || o[g + 1] - o[g] > 5 * r || y) {\n            if (o[g] > M) {\n              for (f = c.getTimeTicks(t, o[b], o[g], s); f.length && f[0] <= M;) f.shift();\n              f.length && (M = f[f.length - 1]), p.push(v.length), v = v.concat(f);\n            }\n            b = g + 1;\n          }\n          if (y) break;\n        }\n        if (f) {\n          if (x = f.info, a && x.unitRange <= u.hour) {\n            for (b = 1, g = v.length - 1; b < g; b++) c.dateFormat("%d", v[b]) !== c.dateFormat("%d", v[b - 1]) && (n[v[b]] = "day", m = !0);\n            m && (n[v[0]] = "day"), x.higherRanks = n;\n          }\n          x.segmentStarts = p, v.info = x;\n        } else d(12, !1, this.chart);\n        if (a && h(l)) {\n          let t = v.length,\n            e = [],\n            s = [],\n            o,\n            r,\n            a,\n            h,\n            d,\n            c = t;\n          for (; c--;) r = this.translate(v[c]), a && (s[c] = a - r), e[c] = a = r;\n          for (s.sort(), (h = s[Math.floor(s.length / 2)]) < .6 * l && (h = null), c = v[t - 1] > i ? t - 1 : t, a = void 0; c--;) d = Math.abs(a - (r = e[c])), a && d < .8 * l && (null === h || d < .8 * h) ? (n[v[c]] && !n[v[c + 1]] ? (o = c + 1, a = r) : o = c, v.splice(o, 1)) : a = r;\n        }\n        return v;\n      }\n      function o(t) {\n        let e = this.ordinal,\n          i = e.positions;\n        if (!i) return t;\n        let s = i.length - 1,\n          o;\n        return (t < 0 ? t = i[0] : t > s ? t = i[s] : (s = Math.floor(t), o = t - s), void 0 !== o && void 0 !== i[s]) ? i[s] + (o ? o * (i[s + 1] - i[s]) : 0) : t;\n      }\n      function g(t) {\n        let e = this.ordinal,\n          i = this.old ? this.old.min : this.min,\n          s = this.old ? this.old.transA : this.transA,\n          o = e.getExtendedPositions();\n        if (o.length) {\n          let r = n((t - i) * s + this.minPixelPadding),\n            a = n(e.getIndexOfPoint(r, o)),\n            l = n(a % 1);\n          if (a >= 0 && a <= o.length - 1) {\n            let t = o[Math.floor(a)],\n              e = o[Math.ceil(a)];\n            return o[Math.floor(a)] + l * (e - t);\n          }\n        }\n        return t;\n      }\n      function f(e, i) {\n        let s = t.Additions.findIndexOf(e, i, !0);\n        if (e[s] === i) return s;\n        let o = (i - e[s]) / (e[s + 1] - e[s]);\n        return s + o;\n      }\n      function m() {\n        this.ordinal || (this.ordinal = new t.Additions(this));\n      }\n      function x() {\n        this.isXAxis && h(this.options.overscroll) && this.max === this.dataMax && (!this.chart.mouseIsDown || this.isInternal) && (!this.eventArgs || this.eventArgs && "navigator" !== this.eventArgs.trigger) && (this.max += this.options.overscroll, !this.isInternal && h(this.userMin) && (this.min += this.options.overscroll));\n      }\n      function y() {\n        this.horiz && !this.isDirty && (this.isDirty = this.isOrdinal && this.chart.navigator && !this.chart.navigator.adaptToUpdatedData);\n      }\n      function b() {\n        this.ordinal && (this.ordinal.beforeSetTickPositions(), this.tickInterval = this.ordinal.postProcessTickInterval(this.tickInterval));\n      }\n      function v(t) {\n        let e = this.xAxis[0],\n          i = e.options.overscroll,\n          s = t.originalEvent.chartX,\n          o = this.options.chart.panning,\n          r = !1;\n        if (o && "y" !== o.type && e.options.ordinal && e.series.length) {\n          let t, o, a, n;\n          let h = this.mouseDownX,\n            d = e.getExtremes(),\n            c = d.dataMax,\n            p = d.min,\n            u = d.max,\n            g = this.hoverPoints,\n            f = e.closestPointRange || e.ordinal && e.ordinal.overscrollPointsRange,\n            m = e.translationSlope * (e.ordinal.slope || f),\n            x = Math.round((h - s) / m),\n            y = e.ordinal.getExtendedPositions(),\n            b = {\n              ordinal: {\n                positions: y,\n                extendedOrdinalPositions: y\n              }\n            },\n            v = e.index2val,\n            M = e.val2lin;\n          b.ordinal.positions ? Math.abs(x) > 1 && (g && g.forEach(function (t) {\n            t.setState();\n          }), x < 0 ? (a = b, n = e.ordinal.positions ? e : b) : (a = e.ordinal.positions ? e : b, n = b), c > (o = n.ordinal.positions)[o.length - 1] && o.push(c), this.fixedRange = u - p, (t = e.navigatorAxis.toFixedRange(void 0, void 0, v.apply(a, [M.apply(a, [p, !0]) + x]), v.apply(n, [M.apply(n, [u, !0]) + x]))).min >= Math.min(d.dataMin, p) && t.max <= Math.max(c, u) + i && e.setExtremes(t.min, t.max, !0, !1, {\n            trigger: "pan"\n          }), this.mouseDownX = s, l(this.container, {\n            cursor: "move"\n          })) : r = !0;\n        } else r = !0;\n        r || o && /y/.test(o.type) ? i && (e.max = e.dataMax + i) : t.preventDefault();\n      }\n      function M() {\n        let t = this.xAxis;\n        t && t.options.ordinal && delete t.ordinal.index;\n      }\n      function S(t, e) {\n        let i;\n        let s = this.ordinal,\n          o = s.positions,\n          r = s.slope,\n          a;\n        if (!o) return t;\n        let n = o.length;\n        if (o[0] <= t && o[n - 1] >= t) i = f(o, t);else {\n          if (!((a = s.getExtendedPositions && s.getExtendedPositions()) && a.length)) return t;\n          let n = a.length;\n          r || (r = (a[n - 1] - a[0]) / n);\n          let l = f(a, o[0]);\n          if (t >= a[0] && t <= a[n - 1]) i = f(a, t) - l;else {\n            if (!e) return t;\n            if (t < a[0]) {\n              let e = a[0] - t,\n                s = e / r;\n              i = -l - s;\n            } else {\n              let e = t - a[n - 1],\n                s = e / r;\n              i = s + n - l;\n            }\n          }\n        }\n        return e ? i : r * (i || 0) + s.offset;\n      }\n      t.compose = function t(e, i, n) {\n        if (p(r, t)) {\n          let t = e.prototype;\n          t.getTimeTicks = s, t.index2val = o, t.lin2val = g, t.val2lin = S, t.ordinal2lin = t.val2lin, a(e, "afterInit", m), a(e, "foundExtremes", x), a(e, "afterSetScale", y), a(e, "initialAxisTranslation", b), a(n, "pan", v), a(i, "updatedData", M);\n        }\n        return e;\n      };\n      class k {\n        constructor(t) {\n          this.index = {}, this.axis = t;\n        }\n        beforeSetTickPositions() {\n          let t = this.axis,\n            e = t.ordinal,\n            i = t.getExtremes(),\n            s = i.min,\n            o = i.max,\n            r = t.brokenAxis?.hasBreaks,\n            a = t.options.ordinal,\n            n,\n            l,\n            h,\n            d,\n            p,\n            u,\n            g,\n            f = [],\n            m = Number.MAX_VALUE,\n            x = !1,\n            y = !1,\n            b = !1;\n          if (a || r) {\n            let i = 0;\n            if (t.series.forEach(function (t, e) {\n              if (l = [], e > 0 && "highcharts-navigator-series" !== t.options.id && t.processedXData.length > 1 && (y = i !== t.processedXData[1] - t.processedXData[0]), i = t.processedXData[1] - t.processedXData[0], t.boosted && (b = t.boosted), t.reserveSpace() && (!1 !== t.takeOrdinalPosition || r) && (n = (f = f.concat(t.processedXData)).length, f.sort(function (t, e) {\n                return t - e;\n              }), m = Math.min(m, c(t.closestPointRange, m)), n)) {\n                for (e = 0; e < n - 1;) f[e] !== f[e + 1] && l.push(f[e + 1]), e++;\n                l[0] !== f[0] && l.unshift(f[0]), f = l;\n              }\n            }), y && b && (f.pop(), f.shift()), (n = f.length) > 2) {\n              for (h = f[1] - f[0], g = n - 1; g-- && !x;) f[g + 1] - f[g] !== h && (x = !0);\n              !t.options.keepOrdinalPadding && (f[0] - s > h || o - f[f.length - 1] > h) && (x = !0);\n            } else t.options.overscroll && (2 === n ? m = f[1] - f[0] : 1 === n ? (m = t.options.overscroll, f = [f[0], f[0] + m]) : m = e.overscrollPointsRange);\n            x || t.forceOrdinal ? (t.options.overscroll && (e.overscrollPointsRange = m, f = f.concat(e.getOverscrollPositions())), e.positions = f, d = t.ordinal2lin(Math.max(s, f[0]), !0), p = Math.max(t.ordinal2lin(Math.min(o, f[f.length - 1]), !0), 1), e.slope = u = (o - s) / (p - d), e.offset = s - d * u) : (e.overscrollPointsRange = c(t.closestPointRange, e.overscrollPointsRange), e.positions = t.ordinal.slope = e.offset = void 0);\n          }\n          t.isOrdinal = a && x, e.groupIntervalFactor = null;\n        }\n        static findIndexOf(t, e, i) {\n          let s = 0,\n            o = t.length - 1,\n            r;\n          for (; s < o;) t[r = Math.ceil((s + o) / 2)] <= e ? s = r : o = r - 1;\n          return t[s] === e ? s : i ? s : -1;\n        }\n        getExtendedPositions() {\n          let t = this,\n            s = t.axis,\n            o = s.constructor.prototype,\n            r = s.chart,\n            a = s.series[0].currentDataGrouping,\n            n = a ? a.count + a.unitName : "raw",\n            l = s.options.overscroll,\n            h = s.getExtremes(),\n            d,\n            c,\n            p = t.index;\n          return p || (p = t.index = {}), p[n] || ((d = {\n            series: [],\n            chart: r,\n            forceOrdinal: !1,\n            getExtremes: function () {\n              return {\n                min: h.dataMin,\n                max: h.dataMax + l\n              };\n            },\n            applyGrouping: o.applyGrouping,\n            getGroupPixelWidth: o.getGroupPixelWidth,\n            getTimeTicks: o.getTimeTicks,\n            options: {\n              ordinal: !0\n            },\n            ordinal: {\n              getGroupIntervalFactor: this.getGroupIntervalFactor\n            },\n            ordinal2lin: o.ordinal2lin,\n            getIndexOfPoint: o.getIndexOfPoint,\n            val2lin: o.val2lin\n          }).ordinal.axis = d, s.series.forEach(function (s) {\n            (c = {\n              xAxis: d,\n              xData: s.xData.slice(),\n              chart: r,\n              groupPixelWidth: s.groupPixelWidth,\n              destroyGroupedData: e.noop,\n              getProcessedData: i.prototype.getProcessedData,\n              applyGrouping: i.prototype.applyGrouping,\n              reserveSpace: i.prototype.reserveSpace,\n              visible: s.visible\n            }).xData = c.xData.concat(t.getOverscrollPositions()), c.options = {\n              dataGrouping: a ? {\n                firstAnchor: "firstPoint",\n                anchor: "middle",\n                lastAnchor: "lastPoint",\n                enabled: !0,\n                forced: !0,\n                approximation: "open",\n                units: [[a.unitName, [a.count]]]\n              } : {\n                enabled: !1\n              }\n            }, d.series.push(c), s.processData.apply(c);\n          }), d.applyGrouping({\n            hasExtremesChanged: !0\n          }), c.closestPointRange !== c.basePointRange && c.currentDataGrouping && (d.forceOrdinal = !0), s.ordinal.beforeSetTickPositions.apply({\n            axis: d\n          }), p[n] = d.ordinal.positions), p[n];\n        }\n        getGroupIntervalFactor(t, e, i) {\n          this.axis;\n          let s = i.processedXData,\n            o = s.length,\n            r = [],\n            a,\n            n,\n            l = this.groupIntervalFactor;\n          if (!l) {\n            for (n = 0; n < o - 1; n++) r[n] = s[n + 1] - s[n];\n            r.sort(function (t, e) {\n              return t - e;\n            }), a = r[Math.floor(o / 2)], t = Math.max(t, s[0]), e = Math.min(e, s[o - 1]), this.groupIntervalFactor = l = o * a / (e - t);\n          }\n          return l;\n        }\n        getIndexOfPoint(t, e) {\n          let i;\n          let s = this.axis,\n            o = 0,\n            r = function (t) {\n              let {\n                min: e,\n                max: i\n              } = s;\n              return !!(h(e) && h(i)) && t.points.some(t => t.x >= e && t.x <= i);\n            };\n          s.series.forEach(t => {\n            let e = t.points?.[0];\n            h(e?.plotX) && (e.plotX < i || !h(i)) && r(t) && (i = e.plotX, o = e.x);\n          }), i ?? (i = s.minPixelPadding);\n          let a = s.translationSlope * (this.slope || s.closestPointRange || this.overscrollPointsRange),\n            l = n((t - i) / a);\n          return k.findIndexOf(e, o, !0) + l;\n        }\n        getOverscrollPositions() {\n          let t = this.axis,\n            e = t.options.overscroll,\n            i = this.overscrollPointsRange,\n            s = [],\n            o = t.dataMax;\n          if (h(i)) for (; o <= t.dataMax + e;) s.push(o += i);\n          return s;\n        }\n        postProcessTickInterval(t) {\n          let e = this.axis,\n            i = this.slope;\n          return i ? e.options.breaks ? e.closestPointRange || t : t / (i / e.closestPointRange) : t;\n        }\n      }\n      t.Additions = k;\n    }(o || (o = {})), o;\n  }), i(e, "Series/HLC/HLCPoint.js", [e["Core/Series/SeriesRegistry.js"]], function (t) {\n    let {\n      column: {\n        prototype: {\n          pointClass: e\n        }\n      }\n    } = t.seriesTypes;\n    return class extends e {};\n  }), i(e, "Series/HLC/HLCSeriesDefaults.js", [], function () {\n    return {\n      lineWidth: 1,\n      tooltip: {\n        pointFormat: \'<span style="color:{point.color}">‚óè</span> <b> {series.name}</b><br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>\'\n      },\n      threshold: null,\n      states: {\n        hover: {\n          lineWidth: 3\n        }\n      },\n      stickyTracking: !0\n    };\n  }), i(e, "Series/HLC/HLCSeries.js", [e["Series/HLC/HLCPoint.js"], e["Series/HLC/HLCSeriesDefaults.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s) {\n    let {\n        column: o\n      } = i.seriesTypes,\n      {\n        extend: r,\n        merge: a\n      } = s;\n    class n extends o {\n      extendStem(t, e, i) {\n        let s = t[0],\n          o = t[1];\n        "number" == typeof s[2] && (s[2] = Math.max(i + e, s[2])), "number" == typeof o[2] && (o[2] = Math.min(i - e, o[2]));\n      }\n      getPointPath(t, e) {\n        let i = e.strokeWidth(),\n          s = t.series,\n          o = i % 2 / 2,\n          r = Math.round(t.plotX) - o,\n          a = Math.round(t.shapeArgs.width / 2),\n          n = t.plotClose,\n          l = [["M", r, Math.round(t.yBottom)], ["L", r, Math.round(t.plotHigh)]];\n        return null !== t.close && (n = Math.round(t.plotClose) + o, l.push(["M", r, n], ["L", r + a, n]), s.extendStem(l, i / 2, n)), l;\n      }\n      drawSinglePoint(t) {\n        let e = t.series,\n          i = e.chart,\n          s,\n          o = t.graphic;\n        void 0 !== t.plotY && (o || (t.graphic = o = i.renderer.path().add(e.group)), i.styledMode || o.attr(e.pointAttribs(t, t.selected && "select")), s = e.getPointPath(t, o), o[o ? "animate" : "attr"]({\n          d: s\n        }).addClass(t.getClassName(), !0));\n      }\n      drawPoints() {\n        this.points.forEach(this.drawSinglePoint);\n      }\n      init() {\n        super.init.apply(this, arguments), this.options.stacking = void 0;\n      }\n      pointAttribs(t, e) {\n        let i = super.pointAttribs.call(this, t, e);\n        return delete i.fill, i;\n      }\n      toYData(t) {\n        return [t.high, t.low, t.close];\n      }\n      translate() {\n        let t = this,\n          e = t.yAxis,\n          i = this.pointArrayMap && this.pointArrayMap.slice() || [],\n          s = i.map(t => `plot${t.charAt(0).toUpperCase() + t.slice(1)}`);\n        s.push("yBottom"), i.push("low"), super.translate.apply(t), t.points.forEach(function (o) {\n          i.forEach(function (i, r) {\n            let a = o[i];\n            null !== a && (t.dataModify && (a = t.dataModify.modifyValue(a)), o[s[r]] = e.toPixels(a, !0));\n          }), o.tooltipPos[1] = o.plotHigh + e.pos - t.chart.plotTop;\n        });\n      }\n    }\n    return n.defaultOptions = a(o.defaultOptions, e), r(n.prototype, {\n      pointClass: t,\n      animate: null,\n      directTouch: !1,\n      pointArrayMap: ["high", "low", "close"],\n      pointAttrToOptions: {\n        stroke: "color",\n        "stroke-width": "lineWidth"\n      },\n      pointValKey: "close"\n    }), i.registerSeriesType("hlc", n), n;\n  }), i(e, "Series/OHLC/OHLCPoint.js", [e["Core/Series/SeriesRegistry.js"]], function (t) {\n    let {\n      seriesTypes: {\n        hlc: e\n      }\n    } = t;\n    class i extends e.prototype.pointClass {\n      getClassName() {\n        return super.getClassName.call(this) + (this.open < this.close ? " highcharts-point-up" : " highcharts-point-down");\n      }\n      resolveUpColor() {\n        this.open < this.close && !this.options.color && this.series.options.upColor && (this.color = this.series.options.upColor);\n      }\n      resolveColor() {\n        super.resolveColor(), this.series.is("heikinashi") || this.resolveUpColor();\n      }\n      getZone() {\n        let t = super.getZone();\n        return this.resolveUpColor(), t;\n      }\n      applyOptions() {\n        return super.applyOptions.apply(this, arguments), this.resolveColor && this.resolveColor(), this;\n      }\n    }\n    return i;\n  }), i(e, "Series/OHLC/OHLCSeriesDefaults.js", [], function () {\n    return {\n      tooltip: {\n        pointFormat: \'<span style="color:{point.color}">‚óè</span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>\'\n      }\n    };\n  }), i(e, "Series/OHLC/OHLCSeries.js", [e["Core/Globals.js"], e["Series/OHLC/OHLCPoint.js"], e["Series/OHLC/OHLCSeriesDefaults.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s, o) {\n    let {\n        composed: r\n      } = t,\n      {\n        hlc: a\n      } = s.seriesTypes,\n      {\n        addEvent: n,\n        extend: l,\n        merge: h,\n        pushUnique: d\n      } = o;\n    function c(t) {\n      let e = t.options,\n        i = e.dataGrouping;\n      i && e.useOhlcData && "highcharts-navigator-series" !== e.id && (i.approximation = "ohlc");\n    }\n    function p(t) {\n      let e = t.options;\n      e.useOhlcData && "highcharts-navigator-series" !== e.id && l(this, {\n        pointValKey: u.prototype.pointValKey,\n        pointArrayMap: u.prototype.pointArrayMap,\n        toYData: u.prototype.toYData\n      });\n    }\n    class u extends a {\n      static compose(t, ...e) {\n        d(r, this.compose) && (n(t, "afterSetOptions", c), n(t, "init", p));\n      }\n      getPointPath(t, e) {\n        let i = super.getPointPath(t, e),\n          s = e.strokeWidth(),\n          o = s % 2 / 2,\n          r = Math.round(t.plotX) - o,\n          a = Math.round(t.shapeArgs.width / 2),\n          n = t.plotOpen;\n        return null !== t.open && (n = Math.round(t.plotOpen) + o, i.push(["M", r, n], ["L", r - a, n]), super.extendStem(i, s / 2, n)), i;\n      }\n      pointAttribs(t, e) {\n        let i = super.pointAttribs.call(this, t, e),\n          s = this.options;\n        return delete i.fill, !t.options.color && s.upColor && t.open < t.close && (i.stroke = s.upColor), i;\n      }\n      toYData(t) {\n        return [t.open, t.high, t.low, t.close];\n      }\n    }\n    return u.defaultOptions = h(a.defaultOptions, i), l(u.prototype, {\n      pointClass: e,\n      pointArrayMap: ["open", "high", "low", "close"]\n    }), s.registerSeriesType("ohlc", u), u;\n  }), i(e, "Series/Candlestick/CandlestickSeriesDefaults.js", [e["Core/Defaults.js"], e["Core/Utilities.js"]], function (t, e) {\n    let {\n        defaultOptions: i\n      } = t,\n      {\n        merge: s\n      } = e;\n    return {\n      states: {\n        hover: {\n          lineWidth: 2\n        }\n      },\n      threshold: null,\n      lineColor: "#000000",\n      lineWidth: 1,\n      upColor: "#ffffff",\n      stickyTracking: !0\n    };\n  }), i(e, "Series/Candlestick/CandlestickSeries.js", [e["Series/Candlestick/CandlestickSeriesDefaults.js"], e["Core/Defaults.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s) {\n    let {\n        defaultOptions: o\n      } = e,\n      {\n        column: r,\n        ohlc: a\n      } = i.seriesTypes,\n      {\n        merge: n\n      } = s;\n    class l extends a {\n      pointAttribs(t, e) {\n        let i = r.prototype.pointAttribs.call(this, t, e),\n          s = this.options,\n          o = t.open < t.close,\n          a = s.lineColor || this.color,\n          n = t.color || this.color;\n        if (i["stroke-width"] = s.lineWidth, i.fill = t.options.color || o && s.upColor || n, i.stroke = t.options.lineColor || o && s.upLineColor || a, e) {\n          let t = s.states[e];\n          i.fill = t.color || i.fill, i.stroke = t.lineColor || i.stroke, i["stroke-width"] = t.lineWidth || i["stroke-width"];\n        }\n        return i;\n      }\n      drawPoints() {\n        let t = this.points,\n          e = this.chart,\n          i = this.yAxis.reversed;\n        for (let s of t) {\n          let t = s.graphic,\n            o,\n            r,\n            a,\n            n,\n            l,\n            h,\n            d,\n            c,\n            p,\n            u,\n            g = !t;\n          void 0 !== s.plotY && (t || (s.graphic = t = e.renderer.path().add(this.group)), this.chart.styledMode || t.attr(this.pointAttribs(s, s.selected && "select")).shadow(this.options.shadow), d = t.strokeWidth() % 2 / 2, c = Math.round(s.plotX) - d, a = Math.min(o = s.plotOpen, r = s.plotClose), n = Math.max(o, r), u = Math.round(s.shapeArgs.width / 2), l = i ? n !== s.yBottom : Math.round(a) !== Math.round(s.plotHigh), h = i ? Math.round(a) !== Math.round(s.plotHigh) : n !== s.yBottom, a = Math.round(a) + d, n = Math.round(n) + d, (p = []).push(["M", c - u, n], ["L", c - u, a], ["L", c + u, a], ["L", c + u, n], ["Z"], ["M", c, a], ["L", c, l ? Math.round(i ? s.yBottom : s.plotHigh) : a], ["M", c, n], ["L", c, h ? Math.round(i ? s.plotHigh : s.yBottom) : n]), t[g ? "attr" : "animate"]({\n            d: p\n          }).addClass(s.getClassName(), !0));\n        }\n      }\n    }\n    return l.defaultOptions = n(a.defaultOptions, o.plotOptions, {\n      tooltip: a.defaultOptions.tooltip\n    }, t), i.registerSeriesType("candlestick", l), l;\n  }), i(e, "Series/Flags/FlagsPoint.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e) {\n    let {\n        column: {\n          prototype: {\n            pointClass: i\n          }\n        }\n      } = t.seriesTypes,\n      {\n        isNumber: s\n      } = e;\n    return class extends i {\n      constructor() {\n        super(...arguments), this.ttBelow = !1;\n      }\n      isValid() {\n        return s(this.y) || void 0 === this.y;\n      }\n      hasNewShapeType() {\n        let t = this.options.shape || this.series.options.shape;\n        return this.graphic && t && t !== this.graphic.symbolKey;\n      }\n    };\n  }), i(e, "Series/Flags/FlagsSeriesDefaults.js", [], function () {\n    return {\n      pointRange: 0,\n      allowOverlapX: !1,\n      shape: "flag",\n      stackDistance: 12,\n      textAlign: "center",\n      tooltip: {\n        pointFormat: "{point.text}"\n      },\n      threshold: null,\n      y: -30,\n      fillColor: "#ffffff",\n      lineWidth: 1,\n      states: {\n        hover: {\n          lineColor: "#000000",\n          fillColor: "#ccd3ff"\n        }\n      },\n      style: {\n        fontSize: "0.7em",\n        fontWeight: "bold"\n      }\n    };\n  }), i(e, "Series/Flags/FlagsSymbols.js", [e["Core/Renderer/RendererRegistry.js"]], function (t) {\n    var e;\n    return function (e) {\n      let i = [];\n      function s(t, e, i, s, o) {\n        let r = o && o.anchorX || t,\n          a = o && o.anchorY || e,\n          n = this.circle(r - 1, a - 1, 2, 2);\n        return n.push(["M", r, a], ["L", t, e + s], ["L", t, e], ["L", t + i, e], ["L", t + i, e + s], ["L", t, e + s], ["Z"]), n;\n      }\n      function o(t, e) {\n        t[e + "pin"] = function (i, s, o, r, a) {\n          let n;\n          let l = a && a.anchorX,\n            h = a && a.anchorY;\n          if ("circle" === e && r > o && (i -= Math.round((r - o) / 2), o = r), n = t[e](i, s, o, r), l && h) {\n            let a = l;\n            if ("circle" === e) a = i + o / 2;else {\n              let t = n[0],\n                e = n[1];\n              "M" === t[0] && "L" === e[0] && (a = (t[1] + e[1]) / 2);\n            }\n            let d = s > h ? s : s + r;\n            n.push(["M", a, d], ["L", l, h]), n = n.concat(t.circle(l - 1, h - 1, 2, 2));\n          }\n          return n;\n        };\n      }\n      e.compose = function (e) {\n        if (-1 === i.indexOf(e)) {\n          i.push(e);\n          let t = e.prototype.symbols;\n          t.flag = s, o(t, "circle"), o(t, "square");\n        }\n        let r = t.getRendererType();\n        i.indexOf(r) && i.push(r);\n      };\n    }(e || (e = {})), e;\n  }), i(e, "Series/OnSeriesComposition.js", [e["Series/Column/ColumnSeries.js"], e["Core/Globals.js"], e["Core/Series/Series.js"], e["Core/Utilities.js"]], function (t, e, i, s) {\n    var o;\n    let {\n        composed: r\n      } = e,\n      {\n        prototype: a\n      } = t,\n      {\n        prototype: n\n      } = i,\n      {\n        defined: l,\n        pushUnique: h,\n        stableSort: d\n      } = s;\n    return function (t) {\n      function e(t) {\n        return n.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this, t);\n      }\n      function i() {\n        a.translate.apply(this);\n        let t = this,\n          e = t.options,\n          i = t.chart,\n          s = t.points,\n          o = e.onSeries,\n          r = o && i.get(o),\n          n = r && r.options.step,\n          h = r && r.points,\n          c = i.inverted,\n          p = t.xAxis,\n          u = t.yAxis,\n          g = s.length - 1,\n          f,\n          m,\n          x = e.onKey || "y",\n          y = h && h.length,\n          b = 0,\n          v,\n          M,\n          S,\n          k,\n          C;\n        if (r && r.visible && y) {\n          for (b = (r.pointXOffset || 0) + (r.barW || 0) / 2, k = r.currentDataGrouping, M = h[y - 1].x + (k ? k.totalRange : 0), d(s, (t, e) => t.x - e.x), x = "plot" + x[0].toUpperCase() + x.substr(1); y-- && s[g];) if (v = h[y], (f = s[g]).y = v.y, v.x <= f.x && void 0 !== v[x]) {\n            if (f.x <= M && (f.plotY = v[x], v.x < f.x && !n && (S = h[y + 1]) && void 0 !== S[x])) {\n              if (l(f.plotX) && r.is("spline")) {\n                let t = [v.plotX || 0, v.plotY || 0],\n                  e = [S.plotX || 0, S.plotY || 0],\n                  i = v.controlPoints?.high || t,\n                  s = S.controlPoints?.low || e,\n                  o = (o, r) => Math.pow(1 - o, 3) * t[r] + 3 * (1 - o) * (1 - o) * o * i[r] + 3 * (1 - o) * o * o * s[r] + o * o * o * e[r],\n                  r = 0,\n                  a = 1,\n                  n;\n                for (let t = 0; t < 100; t++) {\n                  let t = (r + a) / 2,\n                    e = o(t, 0);\n                  if (null === e) break;\n                  if (.25 > Math.abs(e - f.plotX)) {\n                    n = t;\n                    break;\n                  }\n                  e < f.plotX ? r = t : a = t;\n                }\n                l(n) && (f.plotY = o(n, 1), f.y = u.toValue(f.plotY, !0));\n              } else C = (f.x - v.x) / (S.x - v.x), f.plotY += C * (S[x] - v[x]), f.y += C * (S.y - v.y);\n            }\n            if (g--, y++, g < 0) break;\n          }\n        }\n        s.forEach((e, i) => {\n          let o;\n          e.plotX += b, (void 0 === e.plotY || c) && (e.plotX >= 0 && e.plotX <= p.len ? c ? (e.plotY = p.translate(e.x, 0, 1, 0, 1), e.plotX = l(e.y) ? u.translate(e.y, 0, 0, 0, 1) : 0) : e.plotY = (p.opposite ? 0 : t.yAxis.len) + p.offset : e.shapeArgs = {}), (m = s[i - 1]) && m.plotX === e.plotX && (void 0 === m.stackIndex && (m.stackIndex = 0), o = m.stackIndex + 1), e.stackIndex = o;\n        }), this.onSeries = r;\n      }\n      t.compose = function t(s) {\n        if (h(r, t)) {\n          let t = s.prototype;\n          t.getPlotBox = e, t.translate = i;\n        }\n        return s;\n      }, t.getPlotBox = e, t.translate = i;\n    }(o || (o = {})), o;\n  }), i(e, "Series/Flags/FlagsSeries.js", [e["Series/Flags/FlagsPoint.js"], e["Series/Flags/FlagsSeriesDefaults.js"], e["Series/Flags/FlagsSymbols.js"], e["Core/Globals.js"], e["Series/OnSeriesComposition.js"], e["Core/Renderer/RendererUtilities.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, r, a, n, l) {\n    let {\n        noop: h\n      } = s,\n      {\n        distribute: d\n      } = r,\n      {\n        series: c,\n        seriesTypes: {\n          column: p\n        }\n      } = a,\n      {\n        addEvent: u,\n        defined: g,\n        extend: f,\n        merge: m,\n        objectEach: x,\n        wrap: y\n      } = l;\n    class b extends p {\n      animate(t) {\n        t && this.setClip();\n      }\n      drawPoints() {\n        let t, e, i, s, o, r, a, l, h, c, p;\n        let u = this.points,\n          f = this.chart,\n          b = f.renderer,\n          v = f.inverted,\n          M = this.options,\n          S = M.y,\n          k = this.yAxis,\n          C = {},\n          A = [];\n        for (s = u.length; s--;) o = u[s], c = (v ? o.plotY : o.plotX) > this.xAxis.len, t = o.plotX, a = o.stackIndex, i = o.options.shape || M.shape, void 0 !== (e = o.plotY) && (e = o.plotY + S - (void 0 !== a && a * M.stackDistance)), o.anchorX = a ? void 0 : o.plotX, l = a ? void 0 : o.plotY, p = "flag" !== i, r = o.graphic, void 0 !== e && t >= 0 && !c ? (r && o.hasNewShapeType() && (r = r.destroy()), r || (r = o.graphic = b.label("", null, null, i, null, null, M.useHTML).addClass("highcharts-point").add(this.markerGroup), o.graphic.div && (o.graphic.div.point = o), r.isNew = !0), r.attr({\n          align: p ? "center" : "left",\n          width: M.width,\n          height: M.height,\n          "text-align": M.textAlign\n        }), f.styledMode || r.attr(this.pointAttribs(o)).css(m(M.style, o.style)).shadow(M.shadow), t > 0 && (t -= r.strokeWidth() % 2), h = {\n          y: e,\n          anchorY: l\n        }, M.allowOverlapX && (h.x = t, h.anchorX = o.anchorX), r.attr({\n          text: o.options.title || M.title || "A"\n        })[r.isNew ? "attr" : "animate"](h), M.allowOverlapX || (C[o.plotX] ? C[o.plotX].size = Math.max(C[o.plotX].size, r.width || 0) : C[o.plotX] = {\n          align: p ? .5 : 0,\n          size: r.width || 0,\n          target: t,\n          anchorX: t\n        }), o.tooltipPos = [t, e + k.pos - f.plotTop]) : r && (o.graphic = r.destroy());\n        if (!M.allowOverlapX) {\n          let t = 100;\n          for (let e of (x(C, function (e) {\n            e.plotX = e.anchorX, A.push(e), t = Math.max(e.size, t);\n          }), d(A, v ? k.len : this.xAxis.len, t), u)) {\n            let t = e.plotX,\n              i = e.graphic,\n              s = i && C[t];\n            s && i && (g(s.pos) ? i[i.isNew ? "attr" : "animate"]({\n              x: s.pos + (s.align || 0) * s.size,\n              anchorX: e.anchorX\n            }).show().isNew = !1 : i.hide().isNew = !0);\n          }\n        }\n        M.useHTML && this.markerGroup && y(this.markerGroup, "on", function (t) {\n          return n.prototype.on.apply(t.apply(this, [].slice.call(arguments, 1)), [].slice.call(arguments, 1));\n        });\n      }\n      drawTracker() {\n        let t = this.points;\n        for (let e of (super.drawTracker(), t)) {\n          let i = e.graphic;\n          i && (e.unbindMouseOver && e.unbindMouseOver(), e.unbindMouseOver = u(i.element, "mouseover", function () {\n            for (let s of (e.stackIndex > 0 && !e.raised && (e._y = i.y, i.attr({\n              y: e._y - 8\n            }), e.raised = !0), t)) s !== e && s.raised && s.graphic && (s.graphic.attr({\n              y: s._y\n            }), s.raised = !1);\n          }));\n        }\n      }\n      pointAttribs(t, e) {\n        let i = this.options,\n          s = t && t.color || this.color,\n          o = i.lineColor,\n          r = t && t.lineWidth,\n          a = t && t.fillColor || i.fillColor;\n        return e && (a = i.states[e].fillColor, o = i.states[e].lineColor, r = i.states[e].lineWidth), {\n          fill: a || s,\n          stroke: o || s,\n          "stroke-width": r || i.lineWidth || 0\n        };\n      }\n      setClip() {\n        c.prototype.setClip.apply(this, arguments), !1 !== this.options.clip && this.sharedClipKey && this.markerGroup && this.markerGroup.clip(this.chart.sharedClips[this.sharedClipKey]);\n      }\n    }\n    return b.compose = i.compose, b.defaultOptions = m(p.defaultOptions, e), o.compose(b), f(b.prototype, {\n      allowDG: !1,\n      forceCrop: !0,\n      invertible: !1,\n      noSharedTooltip: !0,\n      pointClass: t,\n      sorted: !1,\n      takeOrdinalPosition: !1,\n      trackerGroups: ["markerGroup"],\n      buildKDTree: h,\n      init: c.prototype.init\n    }), a.registerSeriesType("flags", b), b;\n  }), i(e, "Core/Chart/StockChart.js", [e["Core/Chart/Chart.js"], e["Core/Templating.js"], e["Core/Defaults.js"], e["Core/Globals.js"], e["Stock/Navigator/NavigatorDefaults.js"], e["Stock/RangeSelector/RangeSelectorDefaults.js"], e["Stock/Scrollbar/ScrollbarDefaults.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, r, a, n) {\n    let {\n        format: l\n      } = e,\n      {\n        getOptions: h\n      } = i,\n      {\n        composed: d\n      } = s,\n      {\n        addEvent: c,\n        clamp: p,\n        defined: u,\n        extend: g,\n        find: f,\n        isNumber: m,\n        isString: x,\n        merge: y,\n        pick: b,\n        pushUnique: v,\n        splat: M\n      } = n;\n    function S(t, e, i) {\n      return "xAxis" === t ? {\n        minPadding: 0,\n        maxPadding: 0,\n        overscroll: 0,\n        ordinal: !0\n      } : "yAxis" === t ? {\n        labels: {\n          y: -2\n        },\n        opposite: i.opposite ?? e.opposite ?? !0,\n        showLastLabel: !!(e.categories || "category" === e.type),\n        title: {\n          text: i.title?.text !== "Values" ? i.title?.text : null\n        }\n      } : {};\n    }\n    function k(t, e) {\n      if ("xAxis" === t) {\n        let t = b(e.navigator && e.navigator.enabled, o.enabled, !0),\n          i = {\n            type: "datetime",\n            categories: void 0\n          };\n        return t && (i.startOnTick = !1, i.endOnTick = !1), i;\n      }\n      return {};\n    }\n    class C extends t {\n      init(t, e) {\n        let i = h(),\n          s = t.xAxis,\n          n = t.yAxis,\n          l = b(t.navigator && t.navigator.enabled, o.enabled, !0);\n        t.xAxis = t.yAxis = void 0;\n        let d = y({\n          chart: {\n            panning: {\n              enabled: !0,\n              type: "x"\n            },\n            zooming: {\n              pinchType: "x",\n              mouseWheel: {\n                type: "x"\n              }\n            }\n          },\n          navigator: {\n            enabled: l\n          },\n          scrollbar: {\n            enabled: b(a.enabled, !0)\n          },\n          rangeSelector: {\n            enabled: b(r.rangeSelector.enabled, !0)\n          },\n          title: {\n            text: null\n          },\n          tooltip: {\n            split: b(i.tooltip && i.tooltip.split, !0),\n            crosshairs: !0\n          },\n          legend: {\n            enabled: !1\n          }\n        }, t, {\n          isStock: !0\n        });\n        t.xAxis = s, t.yAxis = n, d.xAxis = M(t.xAxis || {}).map((e, s) => y(S("xAxis", e, i.xAxis), e, k("xAxis", t))), d.yAxis = M(t.yAxis || {}).map((t, e) => y(S("yAxis", t, i.yAxis), t)), super.init(d, e);\n      }\n      createAxis(t, e) {\n        return e.axis = y(S(t, e.axis, h()[t]), e.axis, k(t, this.userOptions)), super.createAxis(t, e);\n      }\n    }\n    return c(t, "update", function (t) {\n      let e = t.options;\n      "scrollbar" in e && this.navigator && (y(!0, this.options.scrollbar, e.scrollbar), this.navigator.update({}), delete e.scrollbar);\n    }), function (t) {\n      function e(t) {\n        if (!this.crosshair || !this.crosshair.label || !this.crosshair.label.enabled || !this.cross || !m(this.min) || !m(this.max)) return;\n        let e = this.chart,\n          i = this.logarithmic,\n          s = this.crosshair.label,\n          o = this.horiz,\n          r = this.opposite,\n          a = this.left,\n          n = this.top,\n          h = this.width,\n          d = "inside" === this.options.tickPosition,\n          c = !1 !== this.crosshair.snap,\n          p = t.e || this.cross && this.cross.e,\n          u = t.point,\n          f = this.crossLabel,\n          x,\n          y,\n          v = s.format,\n          M = "",\n          S,\n          k = 0,\n          C = this.min,\n          A = this.max;\n        i && (C = i.lin2log(this.min), A = i.lin2log(this.max));\n        let w = o ? "center" : r ? "right" === this.labelAlign ? "right" : "left" : "left" === this.labelAlign ? "left" : "center";\n        f || (f = this.crossLabel = e.renderer.label("", 0, void 0, s.shape || "callout").addClass("highcharts-crosshair-label highcharts-color-" + (u && u.series ? u.series.colorIndex : this.series[0] && this.series[0].colorIndex)).attr({\n          align: s.align || w,\n          padding: b(s.padding, 8),\n          r: b(s.borderRadius, 3),\n          zIndex: 2\n        }).add(this.labelGroup), e.styledMode || f.attr({\n          fill: s.backgroundColor || u && u.series && u.series.color || "#666666",\n          stroke: s.borderColor || "",\n          "stroke-width": s.borderWidth || 0\n        }).css(g({\n          color: "#ffffff",\n          fontWeight: "normal",\n          fontSize: "0.7em",\n          textAlign: "center"\n        }, s.style || {}))), o ? (x = c ? (u.plotX || 0) + a : p.chartX, y = n + (r ? 0 : this.height)) : (x = a + this.offset + (r ? h : 0), y = c ? (u.plotY || 0) + n : p.chartY), v || s.formatter || (this.dateTime && (M = "%b %d, %Y"), v = "{value" + (M ? ":" + M : "") + "}");\n        let T = c ? this.isXAxis ? u.x : u.y : this.toValue(o ? p.chartX : p.chartY),\n          P = u && u.series ? u.series.isPointInside(u) : m(T) && T > C && T < A,\n          L = "";\n        v ? L = l(v, {\n          value: T\n        }, e) : s.formatter && m(T) && (L = s.formatter.call(this, T)), f.attr({\n          text: L,\n          x: x,\n          y: y,\n          visibility: P ? "inherit" : "hidden"\n        });\n        let D = f.getBBox();\n        !m(f.x) || o || r || (x = f.x - D.width / 2), m(f.y) && (o ? (d && !r || !d && r) && (y = f.y - D.height) : y = f.y - D.height / 2), S = o ? {\n          left: a - D.x,\n          right: a + this.width - D.x\n        } : {\n          left: "left" === this.labelAlign ? a : 0,\n          right: "right" === this.labelAlign ? a + this.width : e.chartWidth\n        };\n        let O = f.translateX || 0;\n        O < S.left && (k = S.left - O), O + D.width >= S.right && (k = -(O + D.width - S.right)), f.attr({\n          x: x + k,\n          y: y,\n          anchorX: o ? x : this.opposite ? 0 : e.chartWidth,\n          anchorY: o ? this.opposite ? e.chartHeight : 0 : y + D.height / 2\n        });\n      }\n      function i() {\n        this.crossLabel && (this.crossLabel = this.crossLabel.hide());\n      }\n      function s(t) {\n        let e = this.chart,\n          i = this.options,\n          s = e._labelPanes = e._labelPanes || {},\n          o = i.labels;\n        if (e.options.isStock && "yAxis" === this.coll) {\n          let e = i.top + "," + i.height;\n          !s[e] && o.enabled && (15 === o.distance && 1 === this.side && (o.distance = 0), void 0 === o.align && (o.align = "right"), s[e] = this, t.align = "right", t.preventDefault());\n        }\n      }\n      function o() {\n        let t = this.chart,\n          e = this.options && this.options.top + "," + this.options.height;\n        e && t._labelPanes && t._labelPanes[e] === this && delete t._labelPanes[e];\n      }\n      function r(t) {\n        let e = this,\n          i = e.isLinked && !e.series && e.linkedParent ? e.linkedParent.series : e.series,\n          s = e.chart,\n          o = s.renderer,\n          r = e.left,\n          a = e.top,\n          n = [],\n          l = t.translatedValue,\n          h = t.value,\n          d = t.force,\n          c,\n          g,\n          y,\n          v,\n          M = [],\n          S,\n          k;\n        if (s.options.isStock && !1 !== t.acrossPanes && "xAxis" === e.coll || "yAxis" === e.coll) {\n          for (let o of (t.preventDefault(), M = (t => {\n            let o = "xAxis" === t ? "yAxis" : "xAxis",\n              r = e.options[o];\n            return m(r) ? [s[o][r]] : x(r) ? [s.get(r)] : i.map(t => t[o]);\n          })(e.coll), e.isXAxis ? s.yAxis : s.xAxis)) if (!u(o.options.id) || -1 === o.options.id.indexOf("navigator")) {\n            let t = o.isXAxis ? "yAxis" : "xAxis",\n              i = u(o.options[t]) ? s[t][o.options[t]] : s[t][0];\n            e === i && M.push(o);\n          }\n          for (let t of (S = M.length ? [] : [e.isXAxis ? s.yAxis[0] : s.xAxis[0]], M)) -1 !== S.indexOf(t) || f(S, e => e.pos === t.pos && e.len === t.len) || S.push(t);\n          if (m(k = b(l, e.translate(h || 0, void 0, void 0, t.old)))) {\n            if (e.horiz) for (let t of S) {\n              let i;\n              v = (g = t.pos) + t.len, c = y = Math.round(k + e.transB), "pass" !== d && (c < r || c > r + e.width) && (d ? c = y = p(c, r, r + e.width) : i = !0), i || n.push(["M", c, g], ["L", y, v]);\n            } else for (let t of S) {\n              let i;\n              y = (c = t.pos) + t.len, g = v = Math.round(a + e.height - k), "pass" !== d && (g < a || g > a + e.height) && (d ? g = v = p(g, a, a + e.height) : i = !0), i || n.push(["M", c, g], ["L", y, v]);\n            }\n          }\n          t.path = n.length > 0 ? o.crispPolyLine(n, t.lineWidth || 1) : void 0;\n        }\n      }\n      function a(t) {\n        if (this.chart.options.isStock) {\n          let e;\n          this.is("column") || this.is("columnrange") ? e = {\n            borderWidth: 0,\n            shadow: !1\n          } : this.is("scatter") || this.is("sma") || (e = {\n            marker: {\n              enabled: !1,\n              radius: 2\n            }\n          }), e && (t.plotOptions[this.type] = y(t.plotOptions[this.type], e));\n        }\n      }\n      function n() {\n        let t = this.chart,\n          e = this.options,\n          i = e.dataGrouping,\n          s = !1 !== this.allowDG && i && b(i.enabled, t.options.isStock);\n        return s;\n      }\n      function h(t, e) {\n        for (let i = 0; i < t.length; i += 2) {\n          let s = t[i],\n            o = t[i + 1];\n          s[1] === o[1] && (s[1] = o[1] = Math.round(s[1]) - e % 2 / 2), s[2] === o[2] && (s[2] = o[2] = Math.round(s[2]) + e % 2 / 2);\n        }\n        return t;\n      }\n      t.compose = function t(l, p, u) {\n        v(d, t) && (c(l, "afterDrawCrosshair", e), c(l, "afterHideCrosshair", i), c(l, "autoLabelAlign", s), c(l, "destroy", o), c(l, "getPlotLinePath", r), p.prototype.forceCropping = n, c(p, "setOptions", a), u.prototype.crispPolyLine = h);\n      }, t.stockChart = function (e, i, s) {\n        return new t(e, i, s);\n      };\n    }(C || (C = {})), C;\n  }), i(e, "masters/modules/stock.src.js", [e["Core/Globals.js"], e["Series/DataModifyComposition.js"], e["Stock/Navigator/Navigator.js"], e["Stock/RangeSelector/RangeSelector.js"], e["Stock/Scrollbar/Scrollbar.js"], e["Core/Axis/OrdinalAxis.js"], e["Series/OHLC/OHLCSeries.js"], e["Series/Flags/FlagsSeries.js"], e["Core/Chart/StockChart.js"]], function (t, e, i, s, o, r, a, n, l) {\n    t.Navigator = i, t.RangeSelector = s, t.Scrollbar = o, t.StockChart = t.stockChart = l.stockChart, e.compose(t.Series, t.Axis, t.Point), n.compose(t.Renderer), i.compose(t.Axis, t.Chart, t.Series), a.compose(t.Series), r.compose(t.Axis, t.Series, t.Chart), s.compose(t.Axis, t.Chart), o.compose(t.Axis), l.compose(t.Axis, t.Series, t.SVGRenderer);\n  }), i(e, "masters/highstock.src.js", [e["masters/highcharts.src.js"]], function (t) {\n    return t.product = "Highstock", t;\n  }), e["masters/highstock.src.js"]._modules = e, e["masters/highstock.src.js"];\n});\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/highcharts/highstock.js?')},"./src/candlestick-builder-panel.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandlestickBuilderPanel: () => (/* binding */ CandlestickBuilderPanel)\n/* harmony export */ });\nfunction _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar builderTemplate = document.createElement(\'template\');\nbuilderTemplate.innerHTML = "\\n\\t\\t<form id=\\"form\\">\\n\\t\\t\\t<fieldset>\\n\\t\\t\\t\\t<legend>Candlesticks chart Properties</legend>\\n\\t\\t\\t\\t<table>\\n\\t\\t\\t\\t\\t<tr>\\n\\t\\t\\t\\t\\t\\t<td>Opacity</td>\\n\\t\\t\\t\\t\\t\\t<td><input id=\\"builder_opacity\\" type=\\"text\\" size=\\"5\\" maxlength=\\"5\\"></td>\\n\\t\\t\\t\\t\\t</tr>\\n\\t\\t\\t\\t</table>\\n\\t\\t\\t\\t<input type=\\"submit\\">\\n\\t\\t\\t</fieldset>\\n\\t\\t</form>\\n\\t\\t<style>\\n\\t\\t:host {\\n\\t\\t\\tdisplay: block;\\n\\t\\t\\tpadding: 1em 1em 1em 1em;\\n\\t\\t}\\n\\t\\t</style>\\n\\t";\nvar CandlestickBuilderPanel = /*#__PURE__*/function (_HTMLElement) {\n  _inherits(CandlestickBuilderPanel, _HTMLElement);\n  function CandlestickBuilderPanel() {\n    var _this;\n    _classCallCheck(this, CandlestickBuilderPanel);\n    _this = _callSuper(this, CandlestickBuilderPanel);\n    _this._shadowRoot = _this.attachShadow({\n      mode: \'open\'\n    });\n    _this._shadowRoot.appendChild(builderTemplate.content.cloneNode(true));\n    _this._shadowRoot.getElementById(\'form\').addEventListener(\'submit\', _this._submit.bind(_assertThisInitialized(_this)));\n    return _this;\n  }\n  _createClass(CandlestickBuilderPanel, [{\n    key: "_submit",\n    value: function _submit(e) {\n      e.preventDefault();\n      this.dispatchEvent(new CustomEvent(\'propertiesChanged\', {\n        detail: {\n          properties: {\n            opacity: this.opacity\n          }\n        }\n      }));\n    }\n  }, {\n    key: "opacity",\n    get: function get() {\n      return this._shadowRoot.getElementById(\'builder_opacity\').value;\n    },\n    set: function set(newOpacity) {\n      this._shadowRoot.getElementById(\'builder_opacity\').value = newOpacity;\n    }\n  }]);\n  return CandlestickBuilderPanel;\n}( /*#__PURE__*/_wrapNativeSuper(HTMLElement));\n\n//# sourceURL=webpack://my-webpack-project/./src/candlestick-builder-panel.js?')},"./src/candlestick-chart.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandlestickChart: () => (/* binding */ CandlestickChart)\n/* harmony export */ });\n/* harmony import */ var highcharts_highstock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! highcharts/highstock */ "./node_modules/highcharts/highstock.js");\n/* harmony import */ var highcharts_highstock__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(highcharts_highstock__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _constants_init_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/init-data */ "./constants/init-data.js");\nfunction _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\nvar CandlestickChart = /*#__PURE__*/function (_HTMLElement) {\n  _inherits(CandlestickChart, _HTMLElement);\n  function CandlestickChart() {\n    var _this;\n    _classCallCheck(this, CandlestickChart);\n    _this = _callSuper(this, CandlestickChart);\n    _this._shadowRoot = _this.attachShadow({\n      mode: \'open\'\n    });\n    var template = document.createElement(\'template\');\n    template.innerHTML = "<div id=\\"container\\" style=\\"width: 100%; height: 100%\\"></div>";\n    _this._shadowRoot.appendChild(template.content.cloneNode(true));\n    _this.addEventListener(\'click\', function () {\n      var event = new Event(\'onClick\');\n      _this.dispatchEvent(event);\n    });\n\n    // test event emission\n    // triggerRendering.subscribe(() => {\n    //     this.onCustomWidgetBeforeUpdate()\n    // });\n    //\n    // triggerSelectChange.subscribe(() => {\n    //     this.select15min()\n    // });\n\n    _this._props = {};\n    _this.renderCandlesticksHighcharts();\n    return _this;\n  }\n  _createClass(CandlestickChart, [{\n    key: "onCustomWidgetBeforeUpdate",\n    value: function onCustomWidgetBeforeUpdate(changedProperties) {\n      this._props = _objectSpread(_objectSpread({}, this._props), changedProperties);\n    }\n  }, {\n    key: "renderCandlesticksHighcharts",\n    value: function renderCandlesticksHighcharts() {\n      var options = {\n        title: {\n          text: \'Simulated data displayed as candlesticks\'\n        },\n        xAxis: {\n          overscroll: 500000,\n          range: 4 * 200000,\n          gridLineWidth: 1\n        },\n        rangeSelector: {\n          buttons: [{\n            type: \'minute\',\n            count: 15,\n            text: \'15m\'\n          }, {\n            type: \'hour\',\n            count: 1,\n            text: \'1h\'\n          }, {\n            type: \'all\',\n            count: 1,\n            text: \'All\'\n          }],\n          selected: 1,\n          inputEnabled: false\n        },\n        navigator: {\n          xAxis: {\n            overscroll: 500000\n          },\n          series: {\n            color: \'#000000\'\n          }\n        },\n        series: [{\n          type: \'candlestick\',\n          color: \'#FF7F7F\',\n          upColor: \'#90EE90\',\n          lastPrice: {\n            enabled: true,\n            label: {\n              enabled: true,\n              backgroundColor: \'#FF7F7F\'\n            }\n          }\n        }]\n      };\n\n      // Imitate getting point from backend\n      function getNewPoint(i, data) {\n        var lastPoint = data[data.length - 1];\n\n        // Add new point\n        if (i === 0 || i % 10 === 0) {\n          return [lastPoint[0] + 60000, lastPoint[4], lastPoint[4], lastPoint[4], lastPoint[4]];\n        }\n        var updatedLastPoint = data[data.length - 1],\n          newClose = highcharts_highstock__WEBPACK_IMPORTED_MODULE_0___default().correctFloat(lastPoint[4] + highcharts_highstock__WEBPACK_IMPORTED_MODULE_0___default().correctFloat(Math.random() - 0.5, 2), 4);\n\n        // Modify last data point\n        return [updatedLastPoint[0], data[data.length - 2][4], newClose >= updatedLastPoint[2] ? newClose : updatedLastPoint[2], newClose <= updatedLastPoint[3] ? newClose : updatedLastPoint[3], newClose];\n      }\n\n      // On load, start the interval that adds points\n      options.chart = {\n        events: {\n          load: function load() {\n            var chart = this,\n              series = chart.series[0];\n            var i = 0;\n            setInterval(function () {\n              var data = series.options.data,\n                newPoint = getNewPoint(i, data),\n                lastPoint = data[data.length - 1];\n\n              // Different x-value, we need to add a new point\n              if (lastPoint[0] !== newPoint[0]) {\n                series.addPoint(newPoint);\n              } else {\n                // Existing point, update it\n                series.options.data[data.length - 1] = newPoint;\n                series.setData(data);\n              }\n              i++;\n            }, 100);\n          }\n        }\n      };\n\n      // Apply the data to the options\n      options.series[0].data = _constants_init_data__WEBPACK_IMPORTED_MODULE_1__.initData;\n\n      // Create the chart\n      var container = this._shadowRoot.querySelector(\'#container\');\n      this.stockChart = highcharts_highstock__WEBPACK_IMPORTED_MODULE_0___default().stockChart(container, options);\n    }\n  }, {\n    key: "setRange",\n    value: function setRange(selectionIdx) {\n      this.stockChart.rangeSelector.clickButton(selectionIdx);\n    }\n  }, {\n    key: "onCustomWidgetAfterUpdate",\n    value: function onCustomWidgetAfterUpdate(changedProperties) {\n      if (\'borderWidth\' in changedProperties) {\n        this.style[\'border-width\'] = changedProperties[\'borderWidth\'];\n      }\n      if (\'borderStyle\' in changedProperties) {\n        this.style[\'border-style\'] = changedProperties[\'borderStyle\'];\n      }\n      if (\'borderColor\' in changedProperties) {\n        this.style[\'border-color\'] = changedProperties[\'borderColor\'];\n      }\n      if (\'opacity\' in changedProperties) {\n        this.style[\'opacity\'] = changedProperties[\'opacity\'];\n      }\n    }\n  }]);\n  return CandlestickChart;\n}( /*#__PURE__*/_wrapNativeSuper(HTMLElement));\n\n//# sourceURL=webpack://my-webpack-project/./src/candlestick-chart.js?')},"./src/candlestick-styling-panel.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandlestickStylingPanel: () => (/* binding */ CandlestickStylingPanel)\n/* harmony export */ });\nfunction _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar stylingTemplate = document.createElement(\'template\');\nstylingTemplate.innerHTML = "\\n\\t\\t<form id=\\"form\\">\\n\\t\\t\\t<fieldset>\\n\\t\\t\\t\\t<legend>Candlesticks chart Properties</legend>\\n\\t\\t\\t\\t<table>\\n\\t\\t\\t\\t\\t<tr>\\n\\t\\t\\t\\t\\t\\t<td>Border-width</td>\\n\\t\\t\\t\\t\\t\\t<td><input id=\\"border_width\\" type=\\"text\\" size=\\"40\\" maxlength=\\"40\\"></td>\\n\\t\\t\\t\\t\\t</tr>\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t<tr>\\n\\t\\t\\t\\t\\t\\t<td>Border-style</td>\\n\\t\\t\\t\\t\\t\\t<td><input id=\\"border_style\\" type=\\"text\\" size=\\"40\\" maxlength=\\"40\\"></td>\\n\\t\\t\\t\\t\\t</tr>\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t<tr>\\n\\t\\t\\t\\t\\t\\t<td>Border-color</td>\\n\\t\\t\\t\\t\\t\\t<td><input id=\\"border_color\\" type=\\"text\\" size=\\"40\\" maxlength=\\"40\\"></td>\\n\\t\\t\\t\\t\\t</tr>\\n\\t\\t\\t\\t</table>\\n\\t\\t\\t\\t<input type=\\"submit\\">\\n\\t\\t\\t</fieldset>\\n\\t\\t</form>\\n\\t";\nvar CandlestickStylingPanel = /*#__PURE__*/function (_HTMLElement) {\n  _inherits(CandlestickStylingPanel, _HTMLElement);\n  function CandlestickStylingPanel() {\n    var _this;\n    _classCallCheck(this, CandlestickStylingPanel);\n    _this = _callSuper(this, CandlestickStylingPanel);\n    _this._shadowRoot = _this.attachShadow({\n      mode: \'open\'\n    });\n    _this._shadowRoot.appendChild(stylingTemplate.content.cloneNode(true));\n    _this._shadowRoot.getElementById(\'form\').addEventListener(\'submit\', _this._submit.bind(_assertThisInitialized(_this)));\n    return _this;\n  }\n  _createClass(CandlestickStylingPanel, [{\n    key: "_submit",\n    value: function _submit(e) {\n      e.preventDefault();\n      this.dispatchEvent(new CustomEvent(\'propertiesChanged\', {\n        detail: {\n          properties: {\n            borderWidth: this.borderWidth,\n            borderStyle: this.borderStyle,\n            borderColor: this.borderColor\n          }\n        }\n      }));\n    }\n  }, {\n    key: "borderWidth",\n    get: function get() {\n      return this._shadowRoot.getElementById(\'border_width\').value;\n    },\n    set: function set(newColor) {\n      this._shadowRoot.getElementById(\'border_width\').value = newColor;\n    }\n  }, {\n    key: "borderStyle",\n    get: function get() {\n      return this._shadowRoot.getElementById(\'border_style\').value;\n    },\n    set: function set(newColor) {\n      this._shadowRoot.getElementById(\'border_style\').value = newColor;\n    }\n  }, {\n    key: "borderColor",\n    get: function get() {\n      return this._shadowRoot.getElementById(\'border_color\').value;\n    },\n    set: function set(newColor) {\n      this._shadowRoot.getElementById(\'border_color\').value = newColor;\n    }\n  }]);\n  return CandlestickStylingPanel;\n}( /*#__PURE__*/_wrapNativeSuper(HTMLElement));\n\n//# sourceURL=webpack://my-webpack-project/./src/candlestick-styling-panel.js?')},"./src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _candlestick_chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./candlestick-chart */ "./src/candlestick-chart.js");\n/* harmony import */ var _candlestick_builder_panel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./candlestick-builder-panel */ "./src/candlestick-builder-panel.js");\n/* harmony import */ var _candlestick_styling_panel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./candlestick-styling-panel */ "./src/candlestick-styling-panel.js");\n// import {RenderTrigger} from "./trigger-rendering-button";\n\n\n\n\n// customElements.define("render-trigger", RenderTrigger)\ncustomElements.define(\'com-candlestick-chart\', _candlestick_chart__WEBPACK_IMPORTED_MODULE_0__.CandlestickChart);\ncustomElements.define(\'com-candlestick-builder\', _candlestick_builder_panel__WEBPACK_IMPORTED_MODULE_1__.CandlestickBuilderPanel);\ncustomElements.define(\'com-candlestick-styling\', _candlestick_styling_panel__WEBPACK_IMPORTED_MODULE_2__.CandlestickStylingPanel);\n\n//# sourceURL=webpack://my-webpack-project/./src/index.js?')}},__webpack_module_cache__={};function __webpack_require__(t){var n=__webpack_module_cache__[t];if(void 0!==n)return n.exports;var e=__webpack_module_cache__[t]={exports:{}};return __webpack_modules__[t].call(e.exports,e,e.exports,__webpack_require__),e.exports}__webpack_require__.n=t=>{var n=t&&t.__esModule?()=>t.default:()=>t;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(t,n)=>{for(var e in n)__webpack_require__.o(n,e)&&!__webpack_require__.o(t,e)&&Object.defineProperty(t,e,{enumerable:!0,get:n[e]})},__webpack_require__.o=(t,n)=>Object.prototype.hasOwnProperty.call(t,n),__webpack_require__.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/index.js")})();